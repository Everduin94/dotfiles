{"version":3,"file":"extensionWeb.js","mappings":"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AC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,MAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAO,CAAC,IAAK,KACb,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,MAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAO,CAAC,IAAK,MACb,KAAO,CAAC,IAAK,MACb,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAO,CAAC,IAAK,OACb,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAO,CAAC,IAAK,OACb,KAAO,CAAC,IAAK,OACb,KAAO,CAAC,IAAK,OACb,KAAO,CAAC,IAAK,OACb,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAO,CAAC,IAAK,OACb,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CA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","sources":["webpack://vim/webpack/universalModuleDefinition","webpack://vim/./node_modules/call-bind/callBound.js","webpack://vim/./node_modules/call-bind/index.js","webpack://vim/./node_modules/diff-match-patch/index.js","webpack://vim/./node_modules/events/events.js","webpack://vim/./node_modules/foreach/index.js","webpack://vim/./node_modules/function-bind/implementation.js","webpack://vim/./node_modules/function-bind/index.js","webpack://vim/./node_modules/get-intrinsic/index.js","webpack://vim/./node_modules/has-symbols/index.js","webpack://vim/./node_modules/has-symbols/shams.js","webpack://vim/./node_modules/has-tostringtag/node_modules/has-symbols/shams.js","webpack://vim/./node_modules/has-tostringtag/shams.js","webpack://vim/./node_modules/has/src/index.js","webpack://vim/./node_modules/inherits/inherits_browser.js","webpack://vim/./node_modules/is-arguments/index.js","webpack://vim/./node_modules/is-generator-function/index.js","webpack://vim/./node_modules/is-typed-array/index.js","webpack://vim/./node_modules/lodash/lodash.js","webpack://vim/./node_modules/os-browserify/browser.js","webpack://vim/./node_modules/parsimmon/build/parsimmon.umd.min.js","webpack://vim/./node_modules/path-browserify/index.js","webpack://vim/./node_modules/process/browser.js","webpack://vim/./node_modules/queue/index.js","webpack://vim/./node_modules/setimmediate/setImmediate.js","webpack://vim/./extensionBase.ts","webpack://vim/./src/actions/base.ts","webpack://vim/./src/actions/baseMotion.ts","webpack://vim/./src/actions/commands/actions.ts","webpack://vim/./src/actions/commands/commandLine.ts","webpack://vim/./src/actions/commands/digraphs.ts","webpack://vim/./src/actions/commands/insert.ts","webpack://vim/./src/actions/commands/put.ts","webpack://vim/./src/actions/commands/replace.ts","webpack://vim/./src/actions/commands/search.ts","webpack://vim/./src/actions/include-main.ts","webpack://vim/./src/actions/languages/python/motion.ts","webpack://vim/./src/actions/motion.ts","webpack://vim/./src/actions/operator.ts","webpack://vim/./src/actions/plugins/easymotion/easymotion.cmd.ts","webpack://vim/./src/actions/plugins/easymotion/easymotion.ts","webpack://vim/./src/actions/plugins/easymotion/markerGenerator.ts","webpack://vim/./src/actions/plugins/easymotion/types.ts","webpack://vim/./src/actions/plugins/pluginDefaultMappings.ts","webpack://vim/./src/actions/plugins/sneak.ts","webpack://vim/./src/actions/wrapping.ts","webpack://vim/./src/cmd_line/commandLine.ts","webpack://vim/./src/cmd_line/commands/bang.ts","webpack://vim/./src/cmd_line/commands/bufferDelete.ts","webpack://vim/./src/cmd_line/commands/close.ts","webpack://vim/./src/cmd_line/commands/copy.ts","webpack://vim/./src/cmd_line/commands/deleteRange.ts","webpack://vim/./src/cmd_line/commands/digraph.ts","webpack://vim/./src/cmd_line/commands/file.ts","webpack://vim/./src/cmd_line/commands/fileInfo.ts","webpack://vim/./src/cmd_line/commands/goto.ts","webpack://vim/./src/cmd_line/commands/gotoLine.ts","webpack://vim/./src/cmd_line/commands/history.ts","webpack://vim/./src/cmd_line/commands/jumps.ts","webpack://vim/./src/cmd_line/commands/marks.ts","webpack://vim/./src/cmd_line/commands/nohl.ts","webpack://vim/./src/cmd_line/commands/only.ts","webpack://vim/./src/cmd_line/commands/put.ts","webpack://vim/./src/cmd_line/commands/quit.ts","webpack://vim/./src/cmd_line/commands/read.ts","webpack://vim/./src/cmd_line/commands/register.ts","webpack://vim/./src/cmd_line/commands/setoptions.ts","webpack://vim/./src/cmd_line/commands/sh.ts","webpack://vim/./src/cmd_line/commands/smile.ts","webpack://vim/./src/cmd_line/commands/sort.ts","webpack://vim/./src/cmd_line/commands/substitute.ts","webpack://vim/./src/cmd_line/commands/tab.ts","webpack://vim/./src/cmd_line/commands/undo.ts","webpack://vim/./src/cmd_line/commands/vscode.ts","webpack://vim/./src/cmd_line/commands/wall.ts","webpack://vim/./src/cmd_line/commands/write.ts","webpack://vim/./src/cmd_line/commands/writequit.ts","webpack://vim/./src/cmd_line/commands/writequitall.ts","webpack://vim/./src/cmd_line/commands/yank.ts","webpack://vim/./src/cmd_line/scanner.ts","webpack://vim/./src/cmd_line/subparsers/bang.ts","webpack://vim/./src/cmd_line/subparsers/bufferDelete.ts","webpack://vim/./src/cmd_line/subparsers/close.ts","webpack://vim/./src/cmd_line/subparsers/deleteRange.ts","webpack://vim/./src/cmd_line/subparsers/digraph.ts","webpack://vim/./src/cmd_line/subparsers/file.ts","webpack://vim/./src/cmd_line/subparsers/fileInfo.ts","webpack://vim/./src/cmd_line/subparsers/history.ts","webpack://vim/./src/cmd_line/subparsers/marks.ts","webpack://vim/./src/cmd_line/subparsers/put.ts","webpack://vim/./src/cmd_line/subparsers/quit.ts","webpack://vim/./src/cmd_line/subparsers/read.ts","webpack://vim/./src/cmd_line/subparsers/register.ts","webpack://vim/./src/cmd_line/subparsers/setoptions.ts","webpack://vim/./src/cmd_line/subparsers/sort.ts","webpack://vim/./src/cmd_line/subparsers/substitute.ts","webpack://vim/./src/cmd_line/subparsers/tab.ts","webpack://vim/./src/cmd_line/subparsers/wall.ts","webpack://vim/./src/cmd_line/subparsers/write.ts","webpack://vim/./src/cmd_line/subparsers/writequit.ts","webpack://vim/./src/cmd_line/subparsers/writequitall.ts","webpack://vim/./src/common/matching/matcher.ts","webpack://vim/./src/common/matching/quoteMatcher.ts","webpack://vim/./src/common/matching/tagMatcher.ts","webpack://vim/./src/common/motion/cursor.ts","webpack://vim/./src/common/motion/position.ts","webpack://vim/./src/common/number/numericString.ts","webpack://vim/./src/completion/lineCompletionProvider.ts","webpack://vim/./src/configuration/configuration.ts","webpack://vim/./src/configuration/configurationValidator.ts","webpack://vim/./src/configuration/decoration.ts","webpack://vim/./src/configuration/iconfigurationValidator.ts","webpack://vim/./src/configuration/notation.ts","webpack://vim/./src/configuration/remapper.ts","webpack://vim/./src/configuration/validators/inputMethodSwitcherValidator.ts","webpack://vim/./src/configuration/validators/remappingValidator.ts","webpack://vim/./src/editorIdentity.ts","webpack://vim/./src/error.ts","webpack://vim/./src/globals.ts","webpack://vim/./src/history/historyFile.ts","webpack://vim/./src/history/historyTracker.ts","webpack://vim/./src/jumps/jump.ts","webpack://vim/./src/jumps/jumpTracker.ts","webpack://vim/./src/mode/mode.ts","webpack://vim/./src/mode/modeHandler.ts","webpack://vim/./src/mode/modeHandlerMap.ts","webpack://vim/./src/platform/browser/constants.ts","webpack://vim/./src/platform/browser/fs.ts","webpack://vim/./src/platform/browser/history.ts","webpack://vim/./src/platform/browser/loggerImpl.ts","webpack://vim/./src/register/register.ts","webpack://vim/./src/state/compositionState.ts","webpack://vim/./src/state/globalState.ts","webpack://vim/./src/state/recordedState.ts","webpack://vim/./src/state/remapState.ts","webpack://vim/./src/state/replaceState.ts","webpack://vim/./src/state/searchState.ts","webpack://vim/./src/state/substituteState.ts","webpack://vim/./src/state/vimState.ts","webpack://vim/./src/statusBar.ts","webpack://vim/./src/taskQueue.ts","webpack://vim/./src/textEditor.ts","webpack://vim/./src/textobject/paragraph.ts","webpack://vim/./src/textobject/sentence.ts","webpack://vim/./src/textobject/textobject.ts","webpack://vim/./src/textobject/util.ts","webpack://vim/./src/textobject/word.ts","webpack://vim/./src/transformations/execute.ts","webpack://vim/./src/transformations/transformations.ts","webpack://vim/./src/transformations/transformer.ts","webpack://vim/./src/util/clipboard.ts","webpack://vim/./src/util/externalCommand.ts","webpack://vim/./src/util/logger.ts","webpack://vim/./src/util/os.ts","webpack://vim/./src/util/path.ts","webpack://vim/./src/util/specialKeys.ts","webpack://vim/./src/util/statusBarTextUtils.ts","webpack://vim/./src/util/util.ts","webpack://vim/./src/util/vscodeContext.ts","webpack://vim/./src/vimscript/exCommand.ts","webpack://vim/./src/vimscript/exCommandParser.ts","webpack://vim/./src/vimscript/lineRange.ts","webpack://vim/./src/vimscript/parserUtils.ts","webpack://vim/./node_modules/untildify/index.js","webpack://vim/./node_modules/util/support/isBufferBrowser.js","webpack://vim/./node_modules/util/support/types.js","webpack://vim/./node_modules/util/util.js","webpack://vim/./node_modules/which-typed-array/index.js","webpack://vim/external commonjs \"vscode\"","webpack://vim/./node_modules/available-typed-arrays/index.js","webpack://vim/./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js","webpack://vim/webpack/bootstrap","webpack://vim/webpack/runtime/global","webpack://vim/webpack/runtime/node module decorator","webpack://vim/./extensionWeb.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function() {\nreturn ","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar callBind = require('./');\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n","'use strict';\n\nvar bind = require('function-bind');\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n","/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nvar diff_match_patch = function() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n};\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * ~Attempts to look like a two-element array (which is what this used to be).~\n * Constructor returns an actual two-element array, to allow destructing @JackuB\n * See https://github.com/JackuB/diff-match-patch/issues/14 for details\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\ndiff_match_patch.Diff = function(op, text) {\n  return [op, text];\n};\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number=} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));\n  }\n  if (commonsuffix) {\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),\n             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),\n             new diff_match_patch.Diff(DIFF_INSERT,\n                 longtext.substring(i + shorttext.length))];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n            new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],\n                          diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var subDiff =\n              this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = subDiff.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, subDiff[j]);\n          }\n          pointer = pointer + subDiff.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n          new diff_match_patch.Diff(DIFF_INSERT, text2)];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        if (lineArrayLength == maxLines) {\n          // Bail out at 65535 because\n          // String.fromCharCode(65536) == String.fromCharCode(0)\n          line = text.substring(lineStart);\n          lineEnd = text.length;\n        }\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n      lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  // Allocate 2/3rds of the space for text1, the rest for text2.\n  var maxLines = 40000;\n  var chars1 = diff_linesToCharsMunge_(text1);\n  maxLines = 65535;\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var i = 0; i < diffs.length; i++) {\n    var chars = diffs[i][1];\n    var text = [];\n    for (var j = 0; j < chars.length; j++) {\n      text[j] = lineArray[chars.charCodeAt(j)];\n    }\n    diffs[i][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastEquality && (lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastEquality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastEquality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastEquality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastEquality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastEquality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n                    text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] =\n              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);\n        } else {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  if (patch.start2 === null) {\n    throw Error('patch not initialized');\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // https://github.com/google/diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] =\n          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indices are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports['diff_match_patch'] = diff_match_patch;\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n    var errorListener;\n\n    // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n","\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = require('has-symbols')();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = require('function-bind');\nvar hasOwn = require('has');\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n","'use strict';\n\nvar origSymbol = global.Symbol;\nvar hasSymbolSham = require('./shams');\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n","'use strict';\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n","'use strict';\n\nvar hasSymbols = require('has-symbols/shams');\n\nmodule.exports = function hasToStringTagShams() {\n\treturn hasSymbols() && !!Symbol.toStringTag;\n};\n","'use strict';\n\nvar bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","'use strict';\n\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n","'use strict';\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = require('has-tostringtag/shams')();\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar GeneratorFunction;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\tif (!getProto) {\n\t\treturn false;\n\t}\n\tif (typeof GeneratorFunction === 'undefined') {\n\t\tvar generatorFunc = getGeneratorFunc();\n\t\tGeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;\n\t}\n\treturn getProto(fn) === GeneratorFunction;\n};\n","'use strict';\n\nvar forEach = require('foreach');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new g[typedArray]();\n\t\tif (Symbol.toStringTag in arr) {\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n","/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.21';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function',\n      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading whitespace. */\n  var reTrimStart = /^\\s+/;\n\n  /** Used to match a single whitespace character. */\n  var reWhitespace = /\\s/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /**\n   * Used to validate the `validate` option in `_.template` variable.\n   *\n   * Forbids characters which could potentially change the meaning of the function argument definition:\n   * - \"(),\" (modification of function parameters)\n   * - \"=\" (default value)\n   * - \"[]{}\" (destructuring of function parameters)\n   * - \"/\" (beginning of a comment)\n   * - whitespace\n   */\n  var reForbiddenIdentifierChars = /[()=,{}\\[\\]\\/\\s]/;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function baseTrim(string) {\n    return string\n      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n      : string;\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedEndIndex(string) {\n    var index = string.length;\n\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n          if (isArray(iteratee)) {\n            return function(value) {\n              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n          }\n          return iteratee;\n        });\n      } else {\n        iteratees = [identity];\n      }\n\n      var index = -1;\n      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n          return object;\n        }\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      var low = 0,\n          high = array == null ? 0 : array.length;\n      if (high === 0) {\n        return 0;\n      }\n\n      value = iteratee(value);\n      var valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Check that cyclic values are equal.\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Check that cyclic values are equal.\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     *\n     * // Combining several predicates using `_.overEvery` or `_.overSome`.\n     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n     * // => objects for ['fred', 'barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 30 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = baseTrim(value);\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('déjà vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in\n      // and escape the comment, thus injecting code that gets evaled.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/\\s/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Throw an error if a forbidden character was found in `variable`, to prevent\n      // potential command injection attacks.\n      else if (reForbiddenIdentifierChars.test(variable)) {\n        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);\n      }\n\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return baseTrim(string);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.slice(0, trimmedEndIndex(string) + 1);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     *\n     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])\n     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function() {\n      return _;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else if (freeModule) {\n    // Export for Node.js.\n    (freeModule.exports = _)._ = _;\n    // Export for CommonJS support.\n    freeExports._ = _;\n  }\n  else {\n    // Export to the global object.\n    root._ = _;\n  }\n}.call(this));\n","exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n","!function(n,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.Parsimmon=t():n.Parsimmon=t()}(\"undefined\"!=typeof self?self:this,function(){return function(n){var t={};function r(e){if(t[e])return t[e].exports;var u=t[e]={i:e,l:!1,exports:{}};return n[e].call(u.exports,u,u.exports,r),u.l=!0,u.exports}return r.m=n,r.c=t,r.d=function(n,t,e){r.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:e})},r.r=function(n){Object.defineProperty(n,\"__esModule\",{value:!0})},r.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(t,\"a\",t),t},r.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},r.p=\"\",r(r.s=0)}([function(n,t,r){\"use strict\";function e(n){if(!(this instanceof e))return new e(n);this._=n}var u=e.prototype;function o(n,t){for(var r=0;r<n;r++)t(r)}function i(n,t,r){return function(n,t){o(t.length,function(r){n(t[r],r,t)})}(function(r,e,u){t=n(t,r,e,u)},r),t}function f(n,t){return i(function(t,r,e,u){return t.concat([n(r,e,u)])},[],t)}function a(n,t){var r={v:0,buf:t};return o(n,function(){var n;r={v:r.v<<1|(n=r.buf,n[0]>>7),buf:function(n){var t=i(function(n,t,r,e){return n.concat(r===e.length-1?Buffer.from([t,0]).readUInt16BE(0):e.readUInt16BE(r))},[],n);return Buffer.from(f(function(n){return(n<<1&65535)>>8},t))}(r.buf)}}),r}function c(){return\"undefined\"!=typeof Buffer}function s(){if(!c())throw new Error(\"Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.\")}function l(n){s();var t=i(function(n,t){return n+t},0,n);if(t%8!=0)throw new Error(\"The bits [\"+n.join(\", \")+\"] add up to \"+t+\" which is not an even number of bytes; the total should be divisible by 8\");var r,u=t/8,o=(r=function(n){return n>48},i(function(n,t){return n||(r(t)?t:n)},null,n));if(o)throw new Error(o+\" bit range requested exceeds 48 bit (6 byte) Number max.\");return new e(function(t,r){var e=u+r;return e>t.length?x(r,u.toString()+\" bytes\"):b(e,i(function(n,t){var r=a(t,n.buf);return{coll:n.coll.concat(r.v),buf:r.buf}},{coll:[],buf:t.slice(r,e)},n).coll)})}function p(n,t){return new e(function(r,e){return s(),e+t>r.length?x(e,t+\" bytes for \"+n):b(e+t,r.slice(e,e+t))})}function h(n,t){if(\"number\"!=typeof(r=t)||Math.floor(r)!==r||t<0||t>6)throw new Error(n+\" requires integer length in range [0, 6].\");var r}function d(n){return h(\"uintBE\",n),p(\"uintBE(\"+n+\")\",n).map(function(t){return t.readUIntBE(0,n)})}function v(n){return h(\"uintLE\",n),p(\"uintLE(\"+n+\")\",n).map(function(t){return t.readUIntLE(0,n)})}function g(n){return h(\"intBE\",n),p(\"intBE(\"+n+\")\",n).map(function(t){return t.readIntBE(0,n)})}function m(n){return h(\"intLE\",n),p(\"intLE(\"+n+\")\",n).map(function(t){return t.readIntLE(0,n)})}function y(n){return n instanceof e}function E(n){return\"[object Array]\"==={}.toString.call(n)}function w(n){return c()&&Buffer.isBuffer(n)}function b(n,t){return{status:!0,index:n,value:t,furthest:-1,expected:[]}}function x(n,t){return E(t)||(t=[t]),{status:!1,index:-1,value:null,furthest:n,expected:t}}function B(n,t){if(!t)return n;if(n.furthest>t.furthest)return n;var r=n.furthest===t.furthest?function(n,t){if(function(){if(void 0!==e._supportsSet)return e._supportsSet;var n=\"undefined\"!=typeof Set;return e._supportsSet=n,n}()&&Array.from){for(var r=new Set(n),u=0;u<t.length;u++)r.add(t[u]);var o=Array.from(r);return o.sort(),o}for(var i={},f=0;f<n.length;f++)i[n[f]]=!0;for(var a=0;a<t.length;a++)i[t[a]]=!0;var c=[];for(var s in i)({}).hasOwnProperty.call(i,s)&&c.push(s);return c.sort(),c}(n.expected,t.expected):t.expected;return{status:n.status,index:n.index,value:n.value,furthest:t.furthest,expected:r}}var j={};function S(n,t){if(w(n))return{offset:t,line:-1,column:-1};n in j||(j[n]={});for(var r=j[n],e=0,u=0,o=0,i=t;i>=0;){if(i in r){e=r[i].line,0===o&&(o=r[i].lineStart);break}\"\\n\"===n.charAt(i)&&(u++,0===o&&(o=i+1)),i--}var f=e+u,a=t-o;return r[t]={line:f,lineStart:o},{offset:t,line:f+1,column:a+1}}function _(n){if(!y(n))throw new Error(\"not a parser: \"+n)}function L(n,t){return\"string\"==typeof n?n.charAt(t):n[t]}function O(n){if(\"number\"!=typeof n)throw new Error(\"not a number: \"+n)}function k(n){if(\"function\"!=typeof n)throw new Error(\"not a function: \"+n)}function P(n){if(\"string\"!=typeof n)throw new Error(\"not a string: \"+n)}var q=2,A=3,I=8,F=5*I,M=4*I,z=\"  \";function R(n,t){return new Array(t+1).join(n)}function U(n,t,r){var e=t-n.length;return e<=0?n:R(r,e)+n}function W(n,t,r,e){return{from:n-t>0?n-t:0,to:n+r>e?e:n+r}}function D(n,t){var r,e,u,o,a,c=t.index,s=c.offset,l=1;if(s===n.length)return\"Got the end of the input\";if(w(n)){var p=s-s%I,h=s-p,d=W(p,F,M+I,n.length),v=f(function(n){return f(function(n){return U(n.toString(16),2,\"0\")},n)},function(n,t){var r=n.length,e=[],u=0;if(r<=t)return[n.slice()];for(var o=0;o<r;o++)e[u]||e.push([]),e[u].push(n[o]),(o+1)%t==0&&u++;return e}(n.slice(d.from,d.to).toJSON().data,I));o=function(n){return 0===n.from&&1===n.to?{from:n.from,to:n.to}:{from:n.from/I,to:Math.floor(n.to/I)}}(d),e=p/I,r=3*h,h>=4&&(r+=1),l=2,u=f(function(n){return n.length<=4?n.join(\" \"):n.slice(0,4).join(\" \")+\"  \"+n.slice(4).join(\" \")},v),(a=(8*(o.to>0?o.to-1:o.to)).toString(16).length)<2&&(a=2)}else{var g=n.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);r=c.column-1,e=c.line-1,o=W(e,q,A,g.length),u=g.slice(o.from,o.to),a=o.to.toString().length}var m=e-o.from;return w(n)&&(a=(8*(o.to>0?o.to-1:o.to)).toString(16).length)<2&&(a=2),i(function(t,e,u){var i,f=u===m,c=f?\"> \":z;return i=w(n)?U((8*(o.from+u)).toString(16),a,\"0\"):U((o.from+u+1).toString(),a,\" \"),[].concat(t,[c+i+\" | \"+e],f?[z+R(\" \",a)+\" | \"+U(\"\",r,\" \")+R(\"^\",l)]:[])},[],u).join(\"\\n\")}function N(n,t){return[\"\\n\",\"-- PARSING FAILED \"+R(\"-\",50),\"\\n\\n\",D(n,t),\"\\n\\n\",(r=t.expected,1===r.length?\"Expected:\\n\\n\"+r[0]:\"Expected one of the following: \\n\\n\"+r.join(\", \")),\"\\n\"].join(\"\");var r}function G(n){return void 0!==n.flags?n.flags:[n.global?\"g\":\"\",n.ignoreCase?\"i\":\"\",n.multiline?\"m\":\"\",n.unicode?\"u\":\"\",n.sticky?\"y\":\"\"].join(\"\")}function C(){for(var n=[].slice.call(arguments),t=n.length,r=0;r<t;r+=1)_(n[r]);return e(function(r,e){for(var u,o=new Array(t),i=0;i<t;i+=1){if(!(u=B(n[i]._(r,e),u)).status)return u;o[i]=u.value,e=u.index}return B(b(e,o),u)})}function J(){var n=[].slice.call(arguments);if(0===n.length)throw new Error(\"seqMap needs at least one argument\");var t=n.pop();return k(t),C.apply(null,n).map(function(n){return t.apply(null,n)})}function T(){var n=[].slice.call(arguments),t=n.length;if(0===t)return Y(\"zero alternates\");for(var r=0;r<t;r+=1)_(n[r]);return e(function(t,r){for(var e,u=0;u<n.length;u+=1)if((e=B(n[u]._(t,r),e)).status)return e;return e})}function V(n,t){return H(n,t).or(X([]))}function H(n,t){return _(n),_(t),J(n,t.then(n).many(),function(n,t){return[n].concat(t)})}function K(n){P(n);var t=\"'\"+n+\"'\";return e(function(r,e){var u=e+n.length,o=r.slice(e,u);return o===n?b(u,o):x(e,t)})}function Q(n,t){!function(n){if(!(n instanceof RegExp))throw new Error(\"not a regexp: \"+n);for(var t=G(n),r=0;r<t.length;r++){var e=t.charAt(r);if(\"i\"!==e&&\"m\"!==e&&\"u\"!==e&&\"s\"!==e)throw new Error('unsupported regexp flag \"'+e+'\": '+n)}}(n),arguments.length>=2?O(t):t=0;var r=function(n){return RegExp(\"^(?:\"+n.source+\")\",G(n))}(n),u=\"\"+n;return e(function(n,e){var o=r.exec(n.slice(e));if(o){if(0<=t&&t<=o.length){var i=o[0],f=o[t];return b(e+i.length,f)}return x(e,\"valid match group (0 to \"+o.length+\") in \"+u)}return x(e,u)})}function X(n){return e(function(t,r){return b(r,n)})}function Y(n){return e(function(t,r){return x(r,n)})}function Z(n){if(y(n))return e(function(t,r){var e=n._(t,r);return e.index=r,e.value=\"\",e});if(\"string\"==typeof n)return Z(K(n));if(n instanceof RegExp)return Z(Q(n));throw new Error(\"not a string, regexp, or parser: \"+n)}function $(n){return _(n),e(function(t,r){var e=n._(t,r),u=t.slice(r,e.index);return e.status?x(r,'not \"'+u+'\"'):b(r,null)})}function nn(n){return k(n),e(function(t,r){var e=L(t,r);return r<t.length&&n(e)?b(r+1,e):x(r,\"a character/byte matching \"+n)})}function tn(n,t){arguments.length<2&&(t=n,n=void 0);var r=e(function(n,e){return r._=t()._,r._(n,e)});return n?r.desc(n):r}function rn(){return Y(\"fantasy-land/empty\")}u.parse=function(n){if(\"string\"!=typeof n&&!w(n))throw new Error(\".parse must be called with a string or Buffer as its argument\");var t,r=this.skip(fn)._(n,0);return t=r.status?{status:!0,value:r.value}:{status:!1,index:S(n,r.furthest),expected:r.expected},delete j[n],t},u.tryParse=function(n){var t=this.parse(n);if(t.status)return t.value;var r=N(n,t),e=new Error(r);throw e.type=\"ParsimmonError\",e.result=t,e},u.assert=function(n,t){return this.chain(function(r){return n(r)?X(r):Y(t)})},u.or=function(n){return T(this,n)},u.trim=function(n){return this.wrap(n,n)},u.wrap=function(n,t){return J(n,this,t,function(n,t){return t})},u.thru=function(n){return n(this)},u.then=function(n){return _(n),C(this,n).map(function(n){return n[1]})},u.many=function(){var n=this;return e(function(t,r){for(var e=[],u=void 0;;){if(!(u=B(n._(t,r),u)).status)return B(b(r,e),u);if(r===u.index)throw new Error(\"infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause\");r=u.index,e.push(u.value)}})},u.tieWith=function(n){return P(n),this.map(function(t){if(function(n){if(!E(n))throw new Error(\"not an array: \"+n)}(t),t.length){P(t[0]);for(var r=t[0],e=1;e<t.length;e++)P(t[e]),r+=n+t[e];return r}return\"\"})},u.tie=function(){return this.tieWith(\"\")},u.times=function(n,t){var r=this;return arguments.length<2&&(t=n),O(n),O(t),e(function(e,u){for(var o=[],i=void 0,f=void 0,a=0;a<n;a+=1){if(f=B(i=r._(e,u),f),!i.status)return f;u=i.index,o.push(i.value)}for(;a<t&&(f=B(i=r._(e,u),f),i.status);a+=1)u=i.index,o.push(i.value);return B(b(u,o),f)})},u.result=function(n){return this.map(function(){return n})},u.atMost=function(n){return this.times(0,n)},u.atLeast=function(n){return J(this.times(n),this.many(),function(n,t){return n.concat(t)})},u.map=function(n){k(n);var t=this;return e(function(r,e){var u=t._(r,e);return u.status?B(b(u.index,n(u.value)),u):u})},u.contramap=function(n){k(n);var t=this;return e(function(r,e){var u=t.parse(n(r.slice(e)));return u.status?b(e+r.length,u.value):u})},u.promap=function(n,t){return k(n),k(t),this.contramap(n).map(t)},u.skip=function(n){return C(this,n).map(function(n){return n[0]})},u.mark=function(){return J(en,this,en,function(n,t,r){return{start:n,value:t,end:r}})},u.node=function(n){return J(en,this,en,function(t,r,e){return{name:n,value:r,start:t,end:e}})},u.sepBy=function(n){return V(this,n)},u.sepBy1=function(n){return H(this,n)},u.lookahead=function(n){return this.skip(Z(n))},u.notFollowedBy=function(n){return this.skip($(n))},u.desc=function(n){E(n)||(n=[n]);var t=this;return e(function(r,e){var u=t._(r,e);return u.status||(u.expected=n),u})},u.fallback=function(n){return this.or(X(n))},u.ap=function(n){return J(n,this,function(n,t){return n(t)})},u.chain=function(n){var t=this;return e(function(r,e){var u=t._(r,e);return u.status?B(n(u.value)._(r,u.index),u):u})},u.concat=u.or,u.empty=rn,u.of=X,u[\"fantasy-land/ap\"]=u.ap,u[\"fantasy-land/chain\"]=u.chain,u[\"fantasy-land/concat\"]=u.concat,u[\"fantasy-land/empty\"]=u.empty,u[\"fantasy-land/of\"]=u.of,u[\"fantasy-land/map\"]=u.map;var en=e(function(n,t){return b(t,S(n,t))}),un=e(function(n,t){return t>=n.length?x(t,\"any character/byte\"):b(t+1,L(n,t))}),on=e(function(n,t){return b(n.length,n.slice(t))}),fn=e(function(n,t){return t<n.length?x(t,\"EOF\"):b(t,null)}),an=Q(/[0-9]/).desc(\"a digit\"),cn=Q(/[0-9]*/).desc(\"optional digits\"),sn=Q(/[a-z]/i).desc(\"a letter\"),ln=Q(/[a-z]*/i).desc(\"optional letters\"),pn=Q(/\\s*/).desc(\"optional whitespace\"),hn=Q(/\\s+/).desc(\"whitespace\"),dn=K(\"\\r\"),vn=K(\"\\n\"),gn=K(\"\\r\\n\"),mn=T(gn,vn,dn).desc(\"newline\"),yn=T(mn,fn);e.all=on,e.alt=T,e.any=un,e.cr=dn,e.createLanguage=function(n){var t={};for(var r in n)({}).hasOwnProperty.call(n,r)&&function(r){t[r]=tn(function(){return n[r](t)})}(r);return t},e.crlf=gn,e.custom=function(n){return e(n(b,x))},e.digit=an,e.digits=cn,e.empty=rn,e.end=yn,e.eof=fn,e.fail=Y,e.formatError=N,e.index=en,e.isParser=y,e.lazy=tn,e.letter=sn,e.letters=ln,e.lf=vn,e.lookahead=Z,e.makeFailure=x,e.makeSuccess=b,e.newline=mn,e.noneOf=function(n){return nn(function(t){return n.indexOf(t)<0}).desc(\"none of '\"+n+\"'\")},e.notFollowedBy=$,e.of=X,e.oneOf=function(n){for(var t=n.split(\"\"),r=0;r<t.length;r++)t[r]=\"'\"+t[r]+\"'\";return nn(function(t){return n.indexOf(t)>=0}).desc(t)},e.optWhitespace=pn,e.Parser=e,e.range=function(n,t){return nn(function(r){return n<=r&&r<=t}).desc(n+\"-\"+t)},e.regex=Q,e.regexp=Q,e.sepBy=V,e.sepBy1=H,e.seq=C,e.seqMap=J,e.seqObj=function(){for(var n,t={},r=0,u=(n=arguments,Array.prototype.slice.call(n)),o=u.length,i=0;i<o;i+=1){var f=u[i];if(!y(f)){if(E(f)&&2===f.length&&\"string\"==typeof f[0]&&y(f[1])){var a=f[0];if(Object.prototype.hasOwnProperty.call(t,a))throw new Error(\"seqObj: duplicate key \"+a);t[a]=!0,r++;continue}throw new Error(\"seqObj arguments must be parsers or [string, parser] array pairs.\")}}if(0===r)throw new Error(\"seqObj expects at least one named parser, found zero\");return e(function(n,t){for(var r,e={},i=0;i<o;i+=1){var f,a;if(E(u[i])?(f=u[i][0],a=u[i][1]):(f=null,a=u[i]),!(r=B(a._(n,t),r)).status)return r;f&&(e[f]=r.value),t=r.index}return B(b(t,e),r)})},e.string=K,e.succeed=X,e.takeWhile=function(n){return k(n),e(function(t,r){for(var e=r;e<t.length&&n(L(t,e));)e++;return b(e,t.slice(r,e))})},e.test=nn,e.whitespace=hn,e[\"fantasy-land/empty\"]=rn,e[\"fantasy-land/of\"]=X,e.Binary={bitSeq:l,bitSeqObj:function(n){s();var t={},r=0,e=f(function(n){if(E(n)){var e=n;if(2!==e.length)throw new Error(\"[\"+e.join(\", \")+\"] should be length 2, got length \"+e.length);if(P(e[0]),O(e[1]),Object.prototype.hasOwnProperty.call(t,e[0]))throw new Error(\"duplicate key in bitSeqObj: \"+e[0]);return t[e[0]]=!0,r++,e}return O(n),[null,n]},n);if(r<1)throw new Error(\"bitSeqObj expects at least one named pair, got [\"+n.join(\", \")+\"]\");var u=f(function(n){return n[0]},e);return l(f(function(n){return n[1]},e)).map(function(n){return i(function(n,t){return null!==t[0]&&(n[t[0]]=t[1]),n},{},f(function(t,r){return[t,n[r]]},u))})},byte:function(n){if(s(),O(n),n>255)throw new Error(\"Value specified to byte constructor (\"+n+\"=0x\"+n.toString(16)+\") is larger in value than a single byte.\");var t=(n>15?\"0x\":\"0x0\")+n.toString(16);return e(function(r,e){var u=L(r,e);return u===n?b(e+1,u):x(e,t)})},buffer:function(n){return p(\"buffer\",n).map(function(n){return Buffer.from(n)})},encodedString:function(n,t){return p(\"string\",t).map(function(t){return t.toString(n)})},uintBE:d,uint8BE:d(1),uint16BE:d(2),uint32BE:d(4),uintLE:v,uint8LE:v(1),uint16LE:v(2),uint32LE:v(4),intBE:g,int8BE:g(1),int16BE:g(2),int32BE:g(4),intLE:m,int8LE:m(1),int16LE:m(2),int32LE:m(4),floatBE:p(\"floatBE\",4).map(function(n){return n.readFloatBE(0)}),floatLE:p(\"floatLE\",4).map(function(n){return n.readFloatLE(0)}),doubleBE:p(\"doubleBE\",8).map(function(n){return n.readDoubleBE(0)}),doubleLE:p(\"doubleLE\",8).map(function(n){return n.readDoubleLE(0)})},n.exports=e}])});","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var inherits = require('inherits')\nvar EventEmitter = require('events').EventEmitter\n\nmodule.exports = Queue\nmodule.exports.default = Queue\n\nfunction Queue (options) {\n  if (!(this instanceof Queue)) {\n    return new Queue(options)\n  }\n\n  EventEmitter.call(this)\n  options = options || {}\n  this.concurrency = options.concurrency || Infinity\n  this.timeout = options.timeout || 0\n  this.autostart = options.autostart || false\n  this.results = options.results || null\n  this.pending = 0\n  this.session = 0\n  this.running = false\n  this.jobs = []\n  this.timers = {}\n}\ninherits(Queue, EventEmitter)\n\nvar arrayMethods = [\n  'pop',\n  'shift',\n  'indexOf',\n  'lastIndexOf'\n]\n\narrayMethods.forEach(function (method) {\n  Queue.prototype[method] = function () {\n    return Array.prototype[method].apply(this.jobs, arguments)\n  }\n})\n\nQueue.prototype.slice = function (begin, end) {\n  this.jobs = this.jobs.slice(begin, end)\n  return this\n}\n\nQueue.prototype.reverse = function () {\n  this.jobs.reverse()\n  return this\n}\n\nvar arrayAddMethods = [\n  'push',\n  'unshift',\n  'splice'\n]\n\narrayAddMethods.forEach(function (method) {\n  Queue.prototype[method] = function () {\n    var methodResult = Array.prototype[method].apply(this.jobs, arguments)\n    if (this.autostart) {\n      this.start()\n    }\n    return methodResult\n  }\n})\n\nObject.defineProperty(Queue.prototype, 'length', {\n  get: function () {\n    return this.pending + this.jobs.length\n  }\n})\n\nQueue.prototype.start = function (cb) {\n  if (cb) {\n    callOnErrorOrEnd.call(this, cb)\n  }\n\n  this.running = true\n\n  if (this.pending >= this.concurrency) {\n    return\n  }\n\n  if (this.jobs.length === 0) {\n    if (this.pending === 0) {\n      done.call(this)\n    }\n    return\n  }\n\n  var self = this\n  var job = this.jobs.shift()\n  var once = true\n  var session = this.session\n  var timeoutId = null\n  var didTimeout = false\n  var resultIndex = null\n  var timeout = job.hasOwnProperty('timeout') ? job.timeout : this.timeout\n\n  function next (err, result) {\n    if (once && self.session === session) {\n      once = false\n      self.pending--\n      if (timeoutId !== null) {\n        delete self.timers[timeoutId]\n        clearTimeout(timeoutId)\n      }\n\n      if (err) {\n        self.emit('error', err, job)\n      } else if (didTimeout === false) {\n        if (resultIndex !== null) {\n          self.results[resultIndex] = Array.prototype.slice.call(arguments, 1)\n        }\n        self.emit('success', result, job)\n      }\n\n      if (self.session === session) {\n        if (self.pending === 0 && self.jobs.length === 0) {\n          done.call(self)\n        } else if (self.running) {\n          self.start()\n        }\n      }\n    }\n  }\n\n  if (timeout) {\n    timeoutId = setTimeout(function () {\n      didTimeout = true\n      if (self.listeners('timeout').length > 0) {\n        self.emit('timeout', next, job)\n      } else {\n        next()\n      }\n    }, timeout)\n    this.timers[timeoutId] = timeoutId\n  }\n\n  if (this.results) {\n    resultIndex = this.results.length\n    this.results[resultIndex] = null\n  }\n\n  this.pending++\n  self.emit('start', job)\n  var promise = job(next)\n  if (promise && promise.then && typeof promise.then === 'function') {\n    promise.then(function (result) {\n      return next(null, result)\n    }).catch(function (err) {\n      return next(err || true)\n    })\n  }\n\n  if (this.running && this.jobs.length > 0) {\n    this.start()\n  }\n}\n\nQueue.prototype.stop = function () {\n  this.running = false\n}\n\nQueue.prototype.end = function (err) {\n  clearTimers.call(this)\n  this.jobs.length = 0\n  this.pending = 0\n  done.call(this, err)\n}\n\nfunction clearTimers () {\n  for (var key in this.timers) {\n    var timeoutId = this.timers[key]\n    delete this.timers[key]\n    clearTimeout(timeoutId)\n  }\n}\n\nfunction callOnErrorOrEnd (cb) {\n  var self = this\n  this.on('error', onerror)\n  this.on('end', onend)\n\n  function onerror (err) { self.end(err) }\n  function onend (err) {\n    self.removeListener('error', onerror)\n    self.removeListener('end', onend)\n    cb(err, this.results)\n  }\n}\n\nfunction done (err) {\n  this.session++\n  this.running = false\n  this.emit('end', err)\n}\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","import * as vscode from 'vscode';\nimport * as path from 'path';\n\nimport { CompositionState } from './src/state/compositionState';\nimport { EditorIdentity } from './src/editorIdentity';\nimport { Globals } from './src/globals';\nimport { Jump } from './src/jumps/jump';\nimport { ModeHandler } from './src/mode/modeHandler';\nimport { ModeHandlerMap } from './src/mode/modeHandlerMap';\nimport { Mode } from './src/mode/mode';\nimport { Notation } from './src/configuration/notation';\nimport { Logger } from './src/util/logger';\nimport { StatusBar } from './src/statusBar';\nimport { VSCodeContext } from './src/util/vscodeContext';\nimport { commandLine } from './src/cmd_line/commandLine';\nimport { configuration } from './src/configuration/configuration';\nimport { globalState } from './src/state/globalState';\nimport { taskQueue } from './src/taskQueue';\nimport { Register, RegisterMode } from './src/register/register';\nimport { SpecialKeys } from './src/util/specialKeys';\nimport { HistoryTracker } from './src/history/historyTracker';\n\nlet extensionContext: vscode.ExtensionContext;\nlet previousActiveEditorId: EditorIdentity | undefined;\nlet lastClosedModeHandler: ModeHandler | null = null;\n\ninterface ICodeKeybinding {\n  after?: string[];\n  commands?: Array<{ command: string; args: any[] }>;\n}\n\nexport async function getAndUpdateModeHandler(\n  forceSyncAndUpdate = false\n): Promise<ModeHandler | undefined> {\n  const activeTextEditor = vscode.window.activeTextEditor;\n  if (activeTextEditor === undefined || activeTextEditor.document.isClosed) {\n    return undefined;\n  }\n\n  const activeEditorId = EditorIdentity.fromEditor(activeTextEditor);\n\n  const [curHandler, isNew] = await ModeHandlerMap.getOrCreate(activeEditorId);\n  if (isNew) {\n    extensionContext.subscriptions.push(curHandler);\n  }\n\n  curHandler.vimState.editor = activeTextEditor;\n\n  if (\n    forceSyncAndUpdate ||\n    !previousActiveEditorId ||\n    !previousActiveEditorId.isEqual(activeEditorId)\n  ) {\n    // We sync the cursors here because ModeHandler is specific to a document, not an editor, so we\n    // need to update our representation of the cursors when switching between editors for the same document.\n    // This will be unnecessary once #4889 is fixed.\n    curHandler.syncCursors();\n    await curHandler.updateView({ drawSelection: false, revealRange: false });\n  }\n\n  previousActiveEditorId = activeEditorId;\n\n  if (curHandler.focusChanged) {\n    curHandler.focusChanged = false;\n\n    if (previousActiveEditorId) {\n      const prevHandler = ModeHandlerMap.get(previousActiveEditorId);\n      prevHandler!.focusChanged = true;\n    }\n  }\n\n  return curHandler;\n}\n\n/**\n * Loads and validates the user's configuration\n */\nasync function loadConfiguration() {\n  const validatorResults = await configuration.load();\n\n  Logger.configChanged(configuration);\n\n  const logger = Logger.get('Configuration');\n  logger.debug(`${validatorResults.numErrors} errors found with vim configuration`);\n\n  if (validatorResults.numErrors > 0) {\n    for (const validatorResult of validatorResults.get()) {\n      switch (validatorResult.level) {\n        case 'error':\n          logger.error(validatorResult.message);\n          break;\n        case 'warning':\n          logger.warn(validatorResult.message);\n          break;\n      }\n    }\n  }\n}\n\n/**\n * The extension's entry point\n */\nexport async function activate(context: vscode.ExtensionContext, handleLocal: boolean = true) {\n  // before we do anything else, we need to load the configuration\n  await loadConfiguration();\n\n  const logger = Logger.get('Extension Startup');\n  logger.debug('Start');\n\n  extensionContext = context;\n  extensionContext.subscriptions.push(StatusBar);\n\n  // Load state\n  Register.loadFromDisk(handleLocal);\n  await Promise.all([commandLine.load(context), globalState.load(context)]);\n\n  if (vscode.window.activeTextEditor) {\n    const filepathComponents = vscode.window.activeTextEditor.document.fileName.split(/\\\\|\\//);\n    Register.setReadonlyRegister('%', filepathComponents[filepathComponents.length - 1]);\n  }\n\n  // workspace events\n  registerEventListener(\n    context,\n    vscode.workspace.onDidChangeConfiguration,\n    async () => {\n      await loadConfiguration();\n    },\n    false\n  );\n\n  registerEventListener(context, vscode.workspace.onDidChangeTextDocument, async (event) => {\n    const textWasDeleted = (changeEvent: vscode.TextDocumentChangeEvent) =>\n      changeEvent.contentChanges.length === 1 &&\n      changeEvent.contentChanges[0].text === '' &&\n      changeEvent.contentChanges[0].range.start.line !==\n        changeEvent.contentChanges[0].range.end.line;\n\n    const textWasAdded = (changeEvent: vscode.TextDocumentChangeEvent) =>\n      changeEvent.contentChanges.length === 1 &&\n      (changeEvent.contentChanges[0].text === '\\n' ||\n        changeEvent.contentChanges[0].text === '\\r\\n') &&\n      changeEvent.contentChanges[0].range.start.line ===\n        changeEvent.contentChanges[0].range.end.line;\n\n    if (textWasDeleted(event)) {\n      globalState.jumpTracker.handleTextDeleted(event.document, event.contentChanges[0].range);\n    } else if (textWasAdded(event)) {\n      globalState.jumpTracker.handleTextAdded(\n        event.document,\n        event.contentChanges[0].range,\n        event.contentChanges[0].text\n      );\n    }\n\n    // Change from VSCode editor should set document.isDirty to true but they initially don't!\n    // There is a timing issue in VSCode codebase between when the isDirty flag is set and\n    // when registered callbacks are fired. https://github.com/Microsoft/vscode/issues/11339\n    const contentChangeHandler = (modeHandler: ModeHandler) => {\n      if (modeHandler.vimState.currentMode === Mode.Insert) {\n        if (modeHandler.vimState.historyTracker.currentContentChanges === undefined) {\n          modeHandler.vimState.historyTracker.currentContentChanges = [];\n        }\n\n        modeHandler.vimState.historyTracker.currentContentChanges =\n          modeHandler.vimState.historyTracker.currentContentChanges.concat(event.contentChanges);\n      }\n    };\n\n    ModeHandlerMap.getAll()\n      .filter((modeHandler) => modeHandler.vimState.identity.fileName === event.document.fileName)\n      .forEach((modeHandler) => {\n        contentChangeHandler(modeHandler);\n      });\n\n    if (handleLocal) {\n      setTimeout(() => {\n        if (!event.document.isDirty && !event.document.isUntitled && event.contentChanges.length) {\n          handleContentChangedFromDisk(event.document);\n        }\n      }, 0);\n    }\n  });\n\n  registerEventListener(\n    context,\n    vscode.workspace.onDidCloseTextDocument,\n    async (closedDocument) => {\n      const documents = vscode.workspace.textDocuments;\n\n      // Delete modehandler once all tabs of this document have been closed\n      for (const editorIdentity of ModeHandlerMap.getKeys()) {\n        const modeHandler = ModeHandlerMap.get(editorIdentity);\n\n        let shouldDelete = false;\n        if (modeHandler == null || modeHandler.vimState.editor === undefined) {\n          shouldDelete = true;\n        } else {\n          const document = modeHandler.vimState.document;\n          if (!documents.includes(document)) {\n            shouldDelete = true;\n            if (closedDocument === document) {\n              lastClosedModeHandler = modeHandler;\n            }\n          }\n        }\n\n        if (shouldDelete) {\n          ModeHandlerMap.delete(editorIdentity);\n        }\n      }\n    },\n    false\n  );\n\n  registerEventListener(context, vscode.workspace.onDidSaveTextDocument, async (document) => {\n    if (\n      configuration.vimrc.enable &&\n      path.relative(document.fileName, configuration.vimrc.path) === ''\n    ) {\n      await configuration.load();\n      vscode.window.showInformationMessage('Sourced new .vimrc');\n    }\n  });\n\n  // window events\n  registerEventListener(\n    context,\n    vscode.window.onDidChangeActiveTextEditor,\n    async () => {\n      const mhPrevious: ModeHandler | undefined = previousActiveEditorId\n        ? ModeHandlerMap.get(previousActiveEditorId)\n        : undefined;\n      // Track the closed editor so we can use it the next time an open event occurs.\n      // When vscode changes away from a temporary file, onDidChangeActiveTextEditor first twice.\n      // First it fires when leaving the closed editor. Then onDidCloseTextDocument first, and we delete\n      // the old ModeHandler. Then a new editor opens.\n      //\n      // This also applies to files that are merely closed, which allows you to jump back to that file similarly\n      // once a new file is opened.\n      lastClosedModeHandler = mhPrevious || lastClosedModeHandler;\n\n      if (vscode.window.activeTextEditor === undefined) {\n        Register.setReadonlyRegister('%', '');\n        return;\n      }\n\n      const oldFileRegister = (await Register.get('%'))?.text;\n      const relativePath = vscode.workspace.asRelativePath(\n        vscode.window.activeTextEditor.document.uri,\n        false\n      );\n\n      if (relativePath !== oldFileRegister) {\n        if (oldFileRegister && oldFileRegister !== '') {\n          Register.setReadonlyRegister('#', oldFileRegister as string);\n        }\n        Register.setReadonlyRegister('%', relativePath);\n      }\n\n      taskQueue.enqueueTask(async () => {\n        const mh = await getAndUpdateModeHandler(true);\n        if (mh) {\n          globalState.jumpTracker.handleFileJump(\n            lastClosedModeHandler ? Jump.fromStateNow(lastClosedModeHandler.vimState) : null,\n            Jump.fromStateNow(mh.vimState)\n          );\n        }\n      });\n    },\n    true,\n    true\n  );\n\n  registerEventListener(\n    context,\n    vscode.window.onDidChangeTextEditorSelection,\n    async (e: vscode.TextEditorSelectionChangeEvent) => {\n      if (\n        vscode.window.activeTextEditor === undefined ||\n        e.textEditor.document !== vscode.window.activeTextEditor.document\n      ) {\n        // We don't care if user selection changed in a paneled window (e.g debug console/terminal)\n        return;\n      }\n\n      const mh = ModeHandlerMap.get(EditorIdentity.fromEditor(vscode.window.activeTextEditor));\n      if (mh === undefined) {\n        // We don't care if there is no active editor\n        return;\n      }\n\n      if (e.kind !== vscode.TextEditorSelectionChangeKind.Mouse) {\n        const selectionsHash = e.selections.reduce(\n          (hash, s) =>\n            hash +\n            `[${s.anchor.line}, ${s.anchor.character}; ${s.active.line}, ${s.active.character}]`,\n          ''\n        );\n        const idx = mh.vimState.selectionsChanged.ourSelections.indexOf(selectionsHash);\n        if (idx > -1) {\n          mh.vimState.selectionsChanged.ourSelections.splice(idx, 1);\n          logger.debug(\n            `Selections: Ignoring selection: ${selectionsHash}, Count left: ${mh.vimState.selectionsChanged.ourSelections.length}`\n          );\n          return;\n        } else if (mh.vimState.selectionsChanged.ignoreIntermediateSelections) {\n          logger.debug(`Selections: ignoring intermediate selection change: ${selectionsHash}`);\n          return;\n        } else if (mh.vimState.selectionsChanged.ourSelections.length > 0) {\n          // Some intermediate selection must have slipped in after setting the\n          // 'ignoreIntermediateSelections' to false. Which means we didn't count\n          // for it yet, but since we have selections to be ignored then we probably\n          // wanted this one to be ignored as well.\n          logger.debug(`Selections: Ignoring slipped selection: ${selectionsHash}`);\n          return;\n        }\n      }\n\n      // We may receive changes from other panels when, having selections in them containing the same file\n      // and changing text before the selection in current panel.\n      if (e.textEditor !== mh.vimState.editor) {\n        return;\n      }\n\n      if (mh.focusChanged) {\n        mh.focusChanged = false;\n        return;\n      }\n\n      if (mh.currentMode === Mode.EasyMotionMode) {\n        return;\n      }\n\n      taskQueue.enqueueTask(() => mh.handleSelectionChange(e));\n    },\n    true,\n    false\n  );\n\n  registerEventListener(\n    context,\n    vscode.window.onDidChangeTextEditorVisibleRanges,\n    async (e: vscode.TextEditorVisibleRangesChangeEvent) => {\n      taskQueue.enqueueTask(async () => {\n        // Scrolling the viewport clears any status bar message, even errors.\n        const mh = await getAndUpdateModeHandler();\n        if (mh && StatusBar.lastMessageTime) {\n          // TODO: Using the time elapsed works most of the time, but is a bit of a hack\n          const timeElapsed = Number(new Date()) - Number(StatusBar.lastMessageTime);\n          if (timeElapsed > 100) {\n            StatusBar.clear(mh.vimState, true);\n          }\n        }\n      });\n    }\n  );\n\n  const compositionState = new CompositionState();\n\n  // Override VSCode commands\n  overrideCommand(context, 'type', async (args) => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh) {\n        if (compositionState.isInComposition) {\n          compositionState.composingText += args.text;\n          if (mh.vimState.currentMode === Mode.Insert) {\n            compositionState.insertedText = true;\n            vscode.commands.executeCommand('default:type', { text: args.text });\n          }\n        } else {\n          await mh.handleKeyEvent(args.text);\n        }\n      }\n    });\n  });\n\n  overrideCommand(context, 'replacePreviousChar', async (args) => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh) {\n        if (compositionState.isInComposition) {\n          compositionState.composingText =\n            compositionState.composingText.substr(\n              0,\n              compositionState.composingText.length - args.replaceCharCnt\n            ) + args.text;\n        }\n        if (compositionState.insertedText) {\n          await vscode.commands.executeCommand('default:replacePreviousChar', {\n            text: args.text,\n            replaceCharCnt: args.replaceCharCnt,\n          });\n          mh.vimState.cursorStopPosition = mh.vimState.editor.selection.start;\n          mh.vimState.cursorStartPosition = mh.vimState.editor.selection.start;\n        }\n      } else {\n        await vscode.commands.executeCommand('default:replacePreviousChar', {\n          text: args.text,\n          replaceCharCnt: args.replaceCharCnt,\n        });\n      }\n    });\n  });\n\n  overrideCommand(context, 'compositionStart', async () => {\n    taskQueue.enqueueTask(async () => {\n      compositionState.isInComposition = true;\n    });\n  });\n\n  overrideCommand(context, 'compositionEnd', async () => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh) {\n        if (compositionState.insertedText) {\n          mh.vimState.selectionsChanged.ignoreIntermediateSelections = true;\n          await vscode.commands.executeCommand('default:replacePreviousChar', {\n            text: '',\n            replaceCharCnt: compositionState.composingText.length,\n          });\n          mh.vimState.cursorStopPosition = mh.vimState.editor.selection.active;\n          mh.vimState.cursorStartPosition = mh.vimState.editor.selection.active;\n          mh.vimState.selectionsChanged.ignoreIntermediateSelections = false;\n        }\n        const text = compositionState.composingText;\n        await mh.handleMultipleKeyEvents(text.split(''));\n      }\n      compositionState.reset();\n    });\n  });\n\n  // Register extension commands\n  registerCommand(context, 'vim.showQuickpickCmdLine', async () => {\n    const mh = await getAndUpdateModeHandler();\n    if (mh) {\n      await commandLine.PromptAndRun('', mh.vimState);\n      mh.updateView();\n    }\n  });\n\n  registerCommand(context, 'vim.remap', async (args: ICodeKeybinding) => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh === undefined) {\n        return;\n      }\n\n      if (!args) {\n        throw new Error(\n          \"'args' is undefined. For this remap to work it needs to have 'args' with an '\\\"after\\\": string[]' and/or a '\\\"commands\\\": { command: string; args: any[] }[]'\"\n        );\n      }\n\n      if (args.after) {\n        for (const key of args.after) {\n          await mh.handleKeyEvent(Notation.NormalizeKey(key, configuration.leader));\n        }\n      }\n\n      if (args.commands) {\n        for (const command of args.commands) {\n          // Check if this is a vim command by looking for :\n          if (command.command.startsWith(':')) {\n            await commandLine.Run(command.command.slice(1, command.command.length), mh.vimState);\n            mh.updateView();\n          } else {\n            vscode.commands.executeCommand(command.command, command.args);\n          }\n        }\n      }\n    });\n  });\n\n  registerCommand(context, 'toggleVim', async () => {\n    configuration.disableExtension = !configuration.disableExtension;\n    toggleExtension(configuration.disableExtension, compositionState);\n  });\n\n  registerCommand(\n    context,\n    'vim.editVimrc',\n    async () => {\n      const document = await vscode.workspace.openTextDocument(configuration.vimrc.path);\n      await vscode.window.showTextDocument(document);\n    },\n    false\n  );\n\n  for (const boundKey of configuration.boundKeyCombinations) {\n    const command = ['<Esc>', '<C-c>'].includes(boundKey.key)\n      ? async () => {\n          const mh = await getAndUpdateModeHandler();\n          if (mh && !(await forceStopRecursiveRemap(mh))) {\n            await mh.handleKeyEvent(`${boundKey.key}`);\n          }\n        }\n      : async () => {\n          const mh = await getAndUpdateModeHandler();\n          if (mh) {\n            await mh.handleKeyEvent(`${boundKey.key}`);\n          }\n        };\n    registerCommand(context, boundKey.command, async () => {\n      taskQueue.enqueueTask(command);\n    });\n  }\n\n  {\n    // Initialize mode handler for current active Text Editor at startup.\n    const modeHandler = await getAndUpdateModeHandler();\n    if (modeHandler) {\n      if (!configuration.startInInsertMode) {\n        const vimState = modeHandler.vimState;\n\n        // Make sure no cursors start on the EOL character (which is invalid in normal mode)\n        // This can happen if we quit last session in insert mode at the end of the line\n        vimState.cursors = vimState.cursors.map((cursor) => {\n          const eolColumn = vimState.document.lineAt(cursor.stop).text.length;\n          if (cursor.stop.character >= eolColumn) {\n            const character = Math.max(eolColumn - 1, 0);\n            return cursor.withNewStop(cursor.stop.with({ character }));\n          } else {\n            return cursor;\n          }\n        });\n      }\n\n      // This is called last because getAndUpdateModeHandler() will change cursor\n      modeHandler.updateView({ drawSelection: true, revealRange: false });\n    }\n  }\n\n  // Disable automatic keyboard navigation in lists, so it doesn't interfere\n  // with our list navigation keybindings\n  await VSCodeContext.set('listAutomaticKeyboardNavigation', false);\n\n  await toggleExtension(configuration.disableExtension, compositionState);\n\n  logger.debug('Finish.');\n}\n\n/**\n * Toggles the VSCodeVim extension between Enabled mode and Disabled mode. This\n * function is activated by calling the 'toggleVim' command from the Command Palette.\n *\n * @param isDisabled if true, sets VSCodeVim to Disabled mode; else sets to enabled mode\n */\nasync function toggleExtension(isDisabled: boolean, compositionState: CompositionState) {\n  await VSCodeContext.set('vim.active', !isDisabled);\n  const mh = await getAndUpdateModeHandler();\n  if (mh) {\n    if (isDisabled) {\n      await mh.handleKeyEvent(SpecialKeys.ExtensionDisable);\n      compositionState.reset();\n      ModeHandlerMap.clear();\n    } else {\n      await mh.handleKeyEvent(SpecialKeys.ExtensionEnable);\n    }\n  }\n}\n\nfunction overrideCommand(\n  context: vscode.ExtensionContext,\n  command: string,\n  callback: (...args: any[]) => any\n) {\n  const disposable = vscode.commands.registerCommand(command, async (args) => {\n    if (configuration.disableExtension) {\n      return vscode.commands.executeCommand('default:' + command, args);\n    }\n\n    if (!vscode.window.activeTextEditor) {\n      return;\n    }\n\n    if (\n      vscode.window.activeTextEditor.document &&\n      vscode.window.activeTextEditor.document.uri.toString() === 'debug:input'\n    ) {\n      return vscode.commands.executeCommand('default:' + command, args);\n    }\n\n    return callback(args);\n  });\n  context.subscriptions.push(disposable);\n}\n\nfunction registerCommand(\n  context: vscode.ExtensionContext,\n  command: string,\n  callback: (...args: any[]) => any,\n  requiresActiveEditor: boolean = true\n) {\n  const disposable = vscode.commands.registerCommand(command, async (args) => {\n    if (requiresActiveEditor && !vscode.window.activeTextEditor) {\n      return;\n    }\n\n    callback(args);\n  });\n  context.subscriptions.push(disposable);\n}\n\nfunction registerEventListener<T>(\n  context: vscode.ExtensionContext,\n  event: vscode.Event<T>,\n  listener: (e: T) => void,\n  exitOnExtensionDisable = true,\n  exitOnTests = false\n) {\n  const disposable = event(async (e) => {\n    if (exitOnExtensionDisable && configuration.disableExtension) {\n      return;\n    }\n\n    if (exitOnTests && Globals.isTesting) {\n      return;\n    }\n\n    listener(e);\n  });\n  context.subscriptions.push(disposable);\n}\n\n/**\n * @returns true if there was a remap being executed to stop\n */\nasync function forceStopRecursiveRemap(mh: ModeHandler): Promise<boolean> {\n  if (mh.remapState.isCurrentlyPerformingRecursiveRemapping) {\n    mh.remapState.forceStopRecursiveRemapping = true;\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleContentChangedFromDisk(document: vscode.TextDocument): void {\n  ModeHandlerMap.getAll()\n    .filter((modeHandler) => modeHandler.vimState.identity.fileName === document.fileName)\n    .forEach((modeHandler) => {\n      modeHandler.vimState.historyTracker = new HistoryTracker(modeHandler.vimState);\n    });\n}\n","import { Position } from 'vscode';\nimport { Cursor } from '../common/motion/cursor';\nimport { Notation } from '../configuration/notation';\nimport { IBaseAction } from '../state/recordedState';\nimport { isTextTransformation } from '../transformations/transformations';\nimport { configuration } from './../configuration/configuration';\nimport { Mode } from './../mode/mode';\nimport { VimState } from './../state/vimState';\n\nexport abstract class BaseAction implements IBaseAction {\n  /**\n   * Can this action be paired with an operator (is it like w in dw)? All\n   * BaseMovements can be, and some more sophisticated commands also can be.\n   */\n  public readonly isMotion: boolean = false;\n\n  public readonly isOperator: boolean = false;\n  public readonly isCommand: boolean = false;\n  public readonly isNumber: boolean = false;\n\n  /**\n   * If true, the cursor position will be added to the jump list on completion.\n   */\n  public readonly isJump: boolean = false;\n\n  /**\n   * TODO: This property is a lie - it pertains to whether an action creates an undo point...\n   *       See #5058 and rationalize ASAP.\n   */\n  public readonly canBeRepeatedWithDot: boolean = false;\n\n  /**\n   * If this is being run in multi cursor mode, the index of the cursor\n   * this action is being applied to.\n   */\n  public multicursorIndex: number | undefined;\n\n  /**\n   * Whether we should change `vimState.desiredColumn`\n   */\n  public readonly preservesDesiredColumn: boolean = false;\n\n  /**\n   * Modes that this action can be run in.\n   */\n  public abstract readonly modes: readonly Mode[];\n\n  /**\n   * The sequence of keys you use to trigger the action, or a list of such sequences.\n   */\n  public abstract readonly keys: readonly string[] | readonly string[][];\n\n  /**\n   * The keys pressed at the time that this action was triggered.\n   */\n  // TODO: make readonly\n  public keysPressed: string[] = [];\n\n  private static readonly isSingleNumber: RegExp = /^[0-9]$/;\n  private static readonly isSingleAlpha: RegExp = /^[a-zA-Z]$/;\n\n  /**\n   * Is this action valid in the current Vim state?\n   */\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (\n      vimState.currentModeIncludingPseudoModes === Mode.OperatorPendingMode &&\n      !this.isMotion &&\n      !this.isOperator &&\n      !this.isNumber\n    ) {\n      return false;\n    }\n\n    return (\n      this.modes.includes(vimState.currentMode) &&\n      BaseAction.CompareKeypressSequence(this.keys, keysPressed)\n    );\n  }\n\n  /**\n   * Could the user be in the process of doing this action.\n   */\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (\n      vimState.currentModeIncludingPseudoModes === Mode.OperatorPendingMode &&\n      !this.isMotion &&\n      !this.isOperator &&\n      !this.isNumber\n    ) {\n      return false;\n    }\n\n    if (!this.modes.includes(vimState.currentMode)) {\n      return false;\n    }\n\n    const keys2D = BaseAction.is2DArray(this.keys) ? this.keys : [this.keys];\n    const keysSlice = keys2D.map((x) => x.slice(0, keysPressed.length));\n    if (!BaseAction.CompareKeypressSequence(keysSlice, keysPressed)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public static CompareKeypressSequence(\n    one: readonly string[] | readonly string[][],\n    two: readonly string[]\n  ): boolean {\n    if (BaseAction.is2DArray(one)) {\n      for (const sequence of one) {\n        if (BaseAction.CompareKeypressSequence(sequence, two)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    if (one.length !== two.length) {\n      return false;\n    }\n\n    for (let i = 0, j = 0; i < one.length; i++, j++) {\n      const left = one[i];\n      const right = two[j];\n\n      if (left === right && right !== configuration.leader) {\n        continue;\n      } else if (left === '<any>') {\n        continue;\n      } else if (left === '<leader>' && right === configuration.leader) {\n        continue;\n      } else if (left === '<number>' && this.isSingleNumber.test(right)) {\n        continue;\n      } else if (left === '<alpha>' && this.isSingleAlpha.test(right)) {\n        continue;\n      } else if (left === '<character>' && !Notation.IsControlKey(right)) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public toString(): string {\n    return this.keys.join('');\n  }\n\n  private static is2DArray<T>(x: readonly T[] | readonly T[][]): x is readonly T[][] {\n    return Array.isArray(x[0]);\n  }\n}\n\n/**\n * A command is something like <Esc>, :, v, i, etc.\n */\nexport abstract class BaseCommand extends BaseAction {\n  override isCommand = true;\n\n  /**\n   * If isCompleteAction is true, then triggering this command is a complete action -\n   * that means that we'll go and try to run it.\n   */\n  public isCompleteAction = true;\n\n  /**\n   * In multi-cursor mode, do we run this command for every cursor, or just once?\n   */\n  public runsOnceForEveryCursor(): boolean {\n    return true;\n  }\n\n  /**\n   * If true, exec() will get called N times where N is the count.\n   *\n   * If false, exec() will only be called once, and you are expected to\n   * handle count prefixes (e.g. the 3 in 3w) yourself.\n   */\n  public readonly runsOnceForEachCountPrefix: boolean = false;\n\n  /**\n   * Run the command a single time.\n   */\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    throw new Error('Not implemented!');\n  }\n\n  /**\n   * Run the command the number of times VimState wants us to.\n   */\n  public async execCount(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = this.runsOnceForEachCountPrefix ? vimState.recordedState.count || 1 : 1;\n\n    if (!this.runsOnceForEveryCursor()) {\n      for (let i = 0; i < timesToRepeat; i++) {\n        await this.exec(position, vimState);\n      }\n\n      for (const transformation of vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = 0;\n        }\n      }\n\n      return;\n    }\n\n    const resultingCursors: Cursor[] = [];\n\n    const cursorsToIterateOver = vimState.cursors\n      .map((x) => new Cursor(x.start, x.stop))\n      .sort((a, b) =>\n        a.start.line > b.start.line ||\n        (a.start.line === b.start.line && a.start.character > b.start.character)\n          ? 1\n          : -1\n      );\n\n    let cursorIndex = 0;\n    for (const { start, stop } of cursorsToIterateOver) {\n      this.multicursorIndex = cursorIndex++;\n\n      vimState.cursorStopPosition = stop;\n      vimState.cursorStartPosition = start;\n\n      for (let j = 0; j < timesToRepeat; j++) {\n        await this.exec(stop, vimState);\n      }\n\n      resultingCursors.push(new Cursor(vimState.cursorStartPosition, vimState.cursorStopPosition));\n\n      for (const transformation of vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = this.multicursorIndex;\n        }\n      }\n    }\n\n    vimState.cursors = resultingCursors;\n  }\n}\n\nexport enum KeypressState {\n  WaitingOnKeys,\n  NoPossibleMatch,\n}\n\n/**\n * Every Vim action will be added here with the @RegisterAction decorator.\n */\nconst actionMap = new Map<Mode, Array<new () => BaseAction>>();\n\n/**\n * Gets the action that should be triggered given a key sequence.\n *\n * If there is a definitive action that matched, returns that action.\n *\n * If an action could potentially match if more keys were to be pressed, returns `KeyPressState.WaitingOnKeys`\n * (e.g. you pressed \"g\" and are about to press \"g\" action to make the full action \"gg\")\n *\n * If no action could ever match, returns `KeypressState.NoPossibleMatch`.\n */\nexport function getRelevantAction(\n  keysPressed: string[],\n  vimState: VimState\n): BaseAction | KeypressState {\n  const possibleActionsForMode = actionMap.get(vimState.currentMode) ?? [];\n\n  let hasPotentialMatch = false;\n  for (const actionType of possibleActionsForMode) {\n    // TODO: Constructing up to several hundred Actions every time we hit a key is moronic.\n    //       I think we can make `doesActionApply` and `couldActionApply` static...\n    const action = new actionType();\n    if (action.doesActionApply(vimState, keysPressed)) {\n      action.keysPressed = vimState.recordedState.actionKeys.slice(0);\n      return action;\n    }\n\n    hasPotentialMatch ||= action.couldActionApply(vimState, keysPressed);\n  }\n\n  return hasPotentialMatch ? KeypressState.WaitingOnKeys : KeypressState.NoPossibleMatch;\n}\n\nexport function RegisterAction(action: new () => BaseAction): void {\n  const actionInstance = new action();\n  for (const modeName of actionInstance.modes) {\n    let actions = actionMap.get(modeName);\n    if (!actions) {\n      actions = [];\n      actionMap.set(modeName, actions);\n    }\n\n    if (actionInstance.keys === undefined) {\n      // action that can't be called directly\n      continue;\n    }\n\n    actions.push(action);\n  }\n}\n","import { BaseAction } from './base';\nimport { Mode } from '../mode/mode';\nimport { VimState } from '../state/vimState';\nimport { clamp } from '../util/util';\nimport { Position } from 'vscode';\n\nexport function isIMovement(o: IMovement | Position): o is IMovement {\n  return (o as IMovement).start !== undefined && (o as IMovement).stop !== undefined;\n}\n\nexport enum SelectionType {\n  Concatenating, // Selections that concatenate repeated movements\n  Expanding, // Selections that expand the start and end of the previous selection\n}\n\n/**\n * The result of a (more sophisticated) Movement.\n */\nexport interface IMovement {\n  start: Position;\n  stop: Position;\n\n  /**\n   * Whether this motion succeeded. Some commands, like fx when 'x' can't be found,\n   * will not move the cursor. Furthermore, dfx won't delete *anything*, even though\n   * deleting to the current character would generally delete 1 character.\n   */\n  failed?: boolean;\n\n  /**\n   * Wheter this motion resulted in the current multicursor index being removed. This\n   * happens when multiple selections combine into one.\n   */\n  removed?: boolean;\n}\n\nexport function failedMovement(vimState: VimState): IMovement {\n  return {\n    start: vimState.cursorStartPosition,\n    stop: vimState.cursorStopPosition,\n    failed: true,\n  };\n}\n\nexport abstract class BaseMovement extends BaseAction {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  override isMotion = true;\n\n  /**\n   * If movement can be repeated with semicolon or comma this will be true when\n   * running the repetition.\n   */\n  isRepeat = false;\n\n  /**\n   * This is for commands like $ which force the desired column to be at\n   * the end of even the longest line.\n   */\n  public setsDesiredColumnToEOL = false;\n\n  protected minCount = 1;\n  protected maxCount = 99999;\n  protected selectionType = SelectionType.Concatenating;\n\n  constructor(keysPressed?: string[], isRepeat?: boolean) {\n    super();\n\n    if (keysPressed) {\n      this.keysPressed = keysPressed;\n    }\n\n    if (isRepeat) {\n      this.isRepeat = isRepeat;\n    }\n  }\n\n  /**\n   * Run the movement a single time.\n   *\n   * Generally returns a new Position. If necessary, it can return an IMovement instead.\n   * Note: If returning an IMovement, make sure that repeated actions on a\n   * visual selection work. For example, V}}\n   */\n  public async execAction(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<Position | IMovement> {\n    throw new Error('Not implemented!');\n  }\n\n  /**\n   * Run the movement in an operator context a single time.\n   *\n   * Some movements operate over different ranges when used for operators.\n   */\n  public async execActionForOperator(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<Position | IMovement> {\n    return this.execAction(position, vimState, firstIteration, lastIteration);\n  }\n\n  /**\n   * Run a movement count times.\n   *\n   * count: the number prefix the user entered, or 0 if they didn't enter one.\n   */\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    let result!: Position | IMovement;\n    let prevResult = failedMovement(vimState);\n    let firstMovementStart = position;\n\n    count = clamp(count, this.minCount, this.maxCount);\n\n    for (let i = 0; i < count; i++) {\n      const firstIteration = i === 0;\n      const lastIteration = i === count - 1;\n      result = await this.createMovementResult(position, vimState, firstIteration, lastIteration);\n\n      if (result instanceof Position) {\n        /**\n         * This position will be passed to the `motion` on the next iteration,\n         * it may cause some issues when count > 1.\n         */\n        position = result;\n      } else {\n        if (result.failed) {\n          return prevResult;\n        }\n\n        if (firstIteration) {\n          firstMovementStart = result.start;\n        }\n\n        position = this.adjustPosition(position, result, lastIteration);\n        prevResult = result;\n      }\n    }\n\n    if (this.selectionType === SelectionType.Concatenating && isIMovement(result)) {\n      result.start = firstMovementStart;\n    }\n\n    return result;\n  }\n\n  protected async createMovementResult(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<Position | IMovement> {\n    const result =\n      vimState.recordedState.operator && lastIteration\n        ? await this.execActionForOperator(position, vimState, firstIteration, lastIteration)\n        : await this.execAction(position, vimState, firstIteration, lastIteration);\n    return result;\n  }\n\n  protected adjustPosition(position: Position, result: IMovement, lastIteration: boolean) {\n    if (!lastIteration) {\n      position = result.stop.getRightThroughLineBreaks();\n    }\n    return position;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { RecordedState } from '../../state/recordedState';\nimport { ReplaceState } from '../../state/replaceState';\nimport { VimState } from '../../state/vimState';\nimport { getCursorsAfterSync, clamp } from '../../util/util';\nimport { Clipboard } from '../../util/clipboard';\nimport { FileCommand } from './../../cmd_line/commands/file';\nimport { OnlyCommand } from './../../cmd_line/commands/only';\nimport { QuitCommand } from './../../cmd_line/commands/quit';\nimport { Tab, TabCommand } from './../../cmd_line/commands/tab';\nimport { PositionDiff, earlierOf, laterOf, sorted } from './../../common/motion/position';\nimport { Cursor } from '../../common/motion/cursor';\nimport { NumericString } from './../../common/number/numericString';\nimport { configuration } from './../../configuration/configuration';\nimport {\n  Mode,\n  visualBlockGetTopLeftPosition,\n  isVisualMode,\n  visualBlockGetBottomRightPosition,\n} from './../../mode/mode';\nimport { Register, RegisterMode } from './../../register/register';\nimport { SearchDirection } from './../../state/searchState';\nimport { EditorScrollByUnit, EditorScrollDirection, TextEditor } from './../../textEditor';\nimport { isTextTransformation, Transformation } from './../../transformations/transformations';\nimport { RegisterAction, BaseCommand } from './../base';\nimport { commandLine } from './../../cmd_line/commandLine';\nimport * as operator from './../operator';\nimport { StatusBar } from '../../statusBar';\nimport { reportFileInfo } from '../../util/statusBarTextUtils';\nimport { globalState } from '../../state/globalState';\nimport { SpecialKeys } from '../../util/specialKeys';\nimport { WordType } from '../../textobject/word';\nimport { Position } from 'vscode';\nimport { WriteQuitCommand } from '../../cmd_line/commands/writequit';\nimport { shouldWrapKey } from '../wrapping';\nimport { ErrorCode, VimError } from '../../error';\n\n/**\n * A very special snowflake.\n *\n * Each keystroke when typing in Insert mode is its own Action, which means naively replaying a\n * realistic insertion (via `.` or a macro) does many small insertions, which is very slow.\n * So instead, we fold all those actions after the fact into a single DocumentContentChangeAction,\n * which compresses the changes, generally into a single document edit per cursor.\n */\nexport class DocumentContentChangeAction extends BaseCommand {\n  modes = [];\n  keys = [];\n  private readonly cursorStart: Position;\n  private cursorEnd: Position;\n\n  constructor(cursorStart: Position) {\n    super();\n    this.cursorStart = cursorStart;\n    this.cursorEnd = cursorStart;\n  }\n\n  private contentChanges: vscode.TextDocumentContentChangeEvent[] = [];\n\n  public addChanges(changes: vscode.TextDocumentContentChangeEvent[], cursorPosition: Position) {\n    this.contentChanges = [...this.contentChanges, ...changes];\n    this.compressChanges();\n    this.cursorEnd = cursorPosition;\n  }\n\n  public getTransformation(positionDiff: PositionDiff): Transformation {\n    return {\n      type: 'contentChange',\n      changes: this.contentChanges,\n      diff: positionDiff,\n    };\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (this.contentChanges.length === 0) {\n      return;\n    }\n\n    let originalLeftBoundary = this.cursorStart;\n\n    let rightBoundary: Position = position;\n    for (const change of this.contentChanges) {\n      if (change.range.start.line < originalLeftBoundary.line) {\n        // This change should be ignored\n        const linesAffected = change.range.end.line - change.range.start.line + 1;\n        const resultLines = change.text.split('\\n').length;\n        originalLeftBoundary = originalLeftBoundary.with(\n          Math.max(0, originalLeftBoundary.line + resultLines - linesAffected)\n        );\n        continue;\n      }\n\n      // Translates diffPos from a position relative to originalLeftBoundary to one relative to position\n      const translate = (diffPos: Position): Position => {\n        const lineOffset = diffPos.line - originalLeftBoundary.line;\n        const char =\n          lineOffset === 0\n            ? position.character + diffPos.character - originalLeftBoundary.character\n            : diffPos.character;\n        // TODO: Should we document.validate() this position?\n        return new Position(Math.max(position.line + lineOffset, 0), Math.max(char, 0));\n      };\n\n      const replaceRange = new vscode.Range(\n        translate(change.range.start),\n        translate(change.range.end)\n      );\n\n      if (replaceRange.start.isAfter(rightBoundary)) {\n        // This change should be ignored as it's out of boundary\n        continue;\n      }\n\n      // Calculate new right boundary\n      const textDiffLines = change.text.split('\\n');\n      const numLinesAdded = textDiffLines.length - 1;\n      const newRightBoundary =\n        numLinesAdded === 0\n          ? new Position(replaceRange.start.line, replaceRange.start.character + change.text.length)\n          : new Position(replaceRange.start.line + numLinesAdded, textDiffLines.pop()!.length);\n\n      rightBoundary = laterOf(rightBoundary, newRightBoundary);\n\n      if (replaceRange.start.isEqual(replaceRange.end)) {\n        vimState.recordedState.transformer.insert(\n          replaceRange.start,\n          change.text,\n          PositionDiff.exactPosition(translate(this.cursorEnd))\n        );\n      } else {\n        vimState.recordedState.transformer.replace(\n          replaceRange,\n          change.text,\n          PositionDiff.exactPosition(translate(this.cursorEnd))\n        );\n      }\n    }\n  }\n\n  private compressChanges(): void {\n    function merge(\n      first: vscode.TextDocumentContentChangeEvent,\n      second: vscode.TextDocumentContentChangeEvent\n    ): vscode.TextDocumentContentChangeEvent | undefined {\n      if (first.rangeOffset + first.text.length === second.rangeOffset) {\n        // Simple concatenation\n        return {\n          text: first.text + second.text,\n          range: first.range,\n          rangeOffset: first.rangeOffset,\n          rangeLength: first.rangeLength,\n        };\n      } else if (\n        first.rangeOffset <= second.rangeOffset &&\n        first.text.length >= second.rangeLength\n      ) {\n        const start = second.rangeOffset - first.rangeOffset;\n        const end = start + second.rangeLength;\n        const text = first.text.slice(0, start) + second.text + first.text.slice(end);\n        // `second` replaces part of `first`\n        // Most often, this is the result of confirming an auto-completion\n        return {\n          text,\n          range: first.range,\n          rangeOffset: first.rangeOffset,\n          rangeLength: first.rangeLength,\n        };\n      } else {\n        // TODO: Do any of the cases falling into this `else` matter?\n        // TODO: YES - make an insertion and then autocomplete to something totally different (replace subsumes insert)\n        return undefined;\n      }\n    }\n\n    const compressed: vscode.TextDocumentContentChangeEvent[] = [];\n    let prev: vscode.TextDocumentContentChangeEvent | undefined;\n    for (const change of this.contentChanges) {\n      if (prev === undefined) {\n        prev = change;\n      } else {\n        const merged = merge(prev, change);\n        if (merged) {\n          prev = merged;\n        } else {\n          compressed.push(prev);\n          prev = change;\n        }\n      }\n    }\n    if (prev !== undefined) {\n      compressed.push(prev);\n    }\n    this.contentChanges = compressed;\n  }\n}\n\n@RegisterAction\nclass DisableExtension extends BaseCommand {\n  modes = [\n    Mode.Normal,\n    Mode.Insert,\n    Mode.Visual,\n    Mode.VisualBlock,\n    Mode.VisualLine,\n    Mode.SearchInProgressMode,\n    Mode.CommandlineInProgress,\n    Mode.Replace,\n    Mode.EasyMotionMode,\n    Mode.EasyMotionInputMode,\n    Mode.SurroundInputMode,\n  ];\n  keys = [SpecialKeys.ExtensionDisable];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Disabled);\n  }\n}\n\n@RegisterAction\nclass EnableExtension extends BaseCommand {\n  modes = [Mode.Disabled];\n  keys = [SpecialKeys.ExtensionEnable];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class CommandNumber extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['<number>'];\n  override isCompleteAction = false;\n  override isNumber = true;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const num = parseInt(this.keysPressed[0], 10);\n    const operatorCount = vimState.recordedState.operatorCount;\n\n    if (operatorCount > 0) {\n      const lastAction =\n        vimState.recordedState.actionsRun[vimState.recordedState.actionsRun.length - 2];\n      if (!(lastAction instanceof CommandNumber)) {\n        // We have set an operatorCount !== 0 after an operator, but now we got another count\n        // number so we need to multiply them.\n        vimState.recordedState.count = operatorCount * num;\n      } else {\n        // We are now getting another digit which means we need to multiply by 10 and add\n        // the new digit multiplied by operatorCount.\n        //\n        // Example: user presses '2d31w':\n        // - After '2' the number 2 is stored in 'count'\n        // - After 'd' the count (2) is stored in 'operatorCount'\n        // - After '3' the number 3 multiplied by 'operatorCount' (3 x 2 = 6) is stored in 'count'\n        // - After '1' the count is multiplied by 10 and added by number 1 multiplied by 'operatorCount'\n        //   (6 * 10 + 1 * 2 = 62)\n        // The final result will be the deletion of 62 words.\n        vimState.recordedState.count = vimState.recordedState.count * 10 + num * operatorCount;\n      }\n    } else {\n      vimState.recordedState.count = vimState.recordedState.count * 10 + num;\n    }\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const isZero = keysPressed[0] === '0';\n\n    return (\n      super.doesActionApply(vimState, keysPressed) &&\n      ((isZero && vimState.recordedState.count > 0) || !isZero)\n    );\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const isZero = keysPressed[0] === '0';\n\n    return (\n      super.couldActionApply(vimState, keysPressed) &&\n      ((isZero && vimState.recordedState.count > 0) || !isZero)\n    );\n  }\n}\n\n@RegisterAction\nexport class CommandRegister extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['\"', '<character>'];\n  override isCompleteAction = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = this.keysPressed[1];\n\n    if (Register.isValidRegister(register)) {\n      vimState.recordedState.registerName = register;\n    } else {\n      // TODO: Changing isCompleteAction here is maybe a bit janky - should it be a function?\n      this.isCompleteAction = true;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandRecordMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['q', '<alpha>'],\n    ['q', '<number>'],\n    ['q', '\"'],\n  ];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const registerKey = this.keysPressed[1];\n    const register = registerKey.toLocaleLowerCase();\n    vimState.macro = new RecordedState();\n    vimState.macro.registerKey = registerKey;\n    vimState.macro.registerName = register;\n\n    if (!Register.isValidUppercaseRegister(registerKey) || !Register.has(register)) {\n      // TODO: this seems suspect - why are we not putting `vimState.macro` in the register? Why are we setting `registerName`?\n      const newRegister = new RecordedState();\n      newRegister.registerName = register;\n\n      vimState.recordedState.registerName = register;\n      Register.put(vimState, newRegister);\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandQuitRecordMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['q'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const macro = vimState.macro!;\n\n    const existingMacro = (await Register.get(macro.registerName))?.text;\n    if (existingMacro instanceof RecordedState) {\n      if (Register.isValidUppercaseRegister(macro.registerKey)) {\n        existingMacro.actionsRun = existingMacro.actionsRun.concat(macro.actionsRun);\n      } else {\n        existingMacro.actionsRun = macro.actionsRun;\n      }\n    }\n\n    vimState.macro = undefined;\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && vimState.macro !== undefined;\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.couldActionApply(vimState, keysPressed) && vimState.macro !== undefined;\n  }\n}\n\n@RegisterAction\nclass CommandExecuteLastMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['@', '@'];\n  override runsOnceForEachCountPrefix = true;\n  override canBeRepeatedWithDot = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const { lastInvokedMacro } = vimState;\n\n    if (lastInvokedMacro) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register: lastInvokedMacro.registerName,\n        replay: 'contentChange',\n      });\n    } else {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NoPreviouslyUsedRegister));\n    }\n  }\n}\n\n@RegisterAction\nclass CommandExecuteMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['@', '<character>'];\n  override runsOnceForEachCountPrefix = true;\n  override canBeRepeatedWithDot = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = this.keysPressed[1].toLocaleLowerCase();\n\n    if (!Register.isValidRegister(register)) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.InvalidRegisterName, `'${register}'`)\n      );\n    }\n\n    if (Register.has(register)) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register,\n        replay: 'contentChange',\n      });\n    }\n  }\n}\n\n@RegisterAction\nclass CommandEsc extends BaseCommand {\n  modes = [\n    Mode.Visual,\n    Mode.VisualLine,\n    Mode.VisualBlock,\n    Mode.Normal,\n    Mode.SurroundInputMode,\n    Mode.EasyMotionMode,\n    Mode.EasyMotionInputMode,\n  ];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  override preservesDesiredColumn = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Normal) {\n      vimState.surround = undefined;\n\n      if (vimState.isMultiCursor) {\n        vimState.cursors = [vimState.cursors[0]];\n      } else {\n        // If there's nothing to do on the vim side, we might as well call some\n        // of vscode's default \"close notification\" actions. I think we should\n        // just add to this list as needed.\n        await Promise.allSettled([\n          vscode.commands.executeCommand('closeReferenceSearchEditor'),\n          vscode.commands.executeCommand('closeMarkersNavigation'),\n          vscode.commands.executeCommand('closeDirtyDiff'),\n        ]);\n      }\n    } else {\n      if (vimState.currentMode === Mode.EasyMotionMode) {\n        vimState.easyMotion.clearDecorations(vimState.editor);\n      } else if (vimState.currentMode === Mode.SurroundInputMode) {\n        vimState.surround = undefined;\n      }\n\n      await vimState.setCurrentMode(Mode.Normal);\n    }\n  }\n}\n\nabstract class CommandEditorScroll extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  override runsOnceForEachCountPrefix = false;\n  abstract to: EditorScrollDirection;\n  abstract by: EditorScrollByUnit;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.recordedState.count || 1;\n    const scrolloff = configuration\n      .getConfiguration('editor')\n      .get<number>('cursorSurroundingLines', 0);\n\n    const visibleRange = vimState.editor.visibleRanges[0];\n    if (visibleRange === undefined) {\n      return;\n    }\n\n    const linesAboveCursor =\n      visibleRange.end.line - vimState.cursorStopPosition.line - timesToRepeat;\n    const linesBelowCursor =\n      vimState.cursorStopPosition.line - visibleRange.start.line - timesToRepeat;\n    if (this.to === 'up' && scrolloff > linesAboveCursor) {\n      vimState.cursorStopPosition = vimState.cursorStopPosition\n        .getUp(scrolloff - linesAboveCursor)\n        .withColumn(vimState.desiredColumn);\n    } else if (this.to === 'down' && scrolloff > linesBelowCursor) {\n      vimState.cursorStopPosition = vimState.cursorStopPosition\n        .getDown(scrolloff - linesBelowCursor)\n        .withColumn(vimState.desiredColumn);\n    }\n\n    vimState.postponedCodeViewChanges.push({\n      command: 'editorScroll',\n      args: {\n        to: this.to,\n        by: this.by,\n        value: timesToRepeat,\n        revealCursor: true,\n        select: isVisualMode(vimState.currentMode),\n      },\n    });\n  }\n}\n\n@RegisterAction\nclass CommandCtrlE extends CommandEditorScroll {\n  keys = ['<C-e>'];\n  override preservesDesiredColumn = true;\n  to: EditorScrollDirection = 'down';\n  by: EditorScrollByUnit = 'line';\n}\n\n@RegisterAction\nclass CommandCtrlY extends CommandEditorScroll {\n  keys = ['<C-y>'];\n  override preservesDesiredColumn = true;\n  to: EditorScrollDirection = 'up';\n  by: EditorScrollByUnit = 'line';\n}\n\n/**\n * Commands like `<C-d>` and `<C-f>` act *sort* of like `<count><C-e>`, but they move\n * your cursor down and put it on the first non-whitespace character of the line.\n */\nabstract class CommandScrollAndMoveCursor extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  override runsOnceForEachCountPrefix = false;\n  abstract to: EditorScrollDirection;\n\n  /**\n   * @returns the number of lines this command should move the cursor\n   */\n  protected abstract getNumLines(visibleRanges: vscode.Range[]): number;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const { visibleRanges } = vimState.editor;\n    if (visibleRanges.length === 0) {\n      return;\n    }\n    const smoothScrolling = configuration\n      .getConfiguration('editor')\n      .get<boolean>('smoothScrolling', false);\n    const moveLines = (vimState.actionCount || 1) * this.getNumLines(visibleRanges);\n\n    let scrollLines = moveLines;\n    if (this.to === 'down') {\n      // This makes <C-d> less wonky when `editor.scrollBeyondLastLine` is enabled\n      scrollLines = Math.min(\n        moveLines,\n        vimState.document.lineCount - 1 - visibleRanges[visibleRanges.length - 1].end.line\n      );\n    }\n\n    if (scrollLines > 0) {\n      const args = {\n        to: this.to,\n        by: 'line',\n        value: scrollLines,\n        revealCursor: smoothScrolling,\n        select: isVisualMode(vimState.currentMode),\n      };\n      if (smoothScrolling) {\n        await vscode.commands.executeCommand('editorScroll', args);\n      } else {\n        vimState.postponedCodeViewChanges.push({\n          command: 'editorScroll',\n          args,\n        });\n      }\n    }\n\n    const newPositionLine = clamp(\n      position.line + (this.to === 'down' ? moveLines : -moveLines),\n      0,\n      vimState.document.lineCount - 1\n    );\n    vimState.cursorStopPosition = new Position(\n      newPositionLine,\n      vimState.desiredColumn\n    ).obeyStartOfLine(vimState.document);\n  }\n}\n\n@RegisterAction\nclass CommandMoveFullPageUp extends CommandScrollAndMoveCursor {\n  keys = ['<C-b>'];\n  to: EditorScrollDirection = 'up';\n\n  protected getNumLines(visibleRanges: vscode.Range[]) {\n    return visibleRanges[0].end.line - visibleRanges[0].start.line;\n  }\n}\n\n@RegisterAction\nclass CommandMoveFullPageDown extends CommandScrollAndMoveCursor {\n  keys = ['<C-f>'];\n  to: EditorScrollDirection = 'down';\n\n  protected getNumLines(visibleRanges: vscode.Range[]) {\n    return visibleRanges[0].end.line - visibleRanges[0].start.line;\n  }\n}\n\n@RegisterAction\nclass CommandMoveHalfPageDown extends CommandScrollAndMoveCursor {\n  keys = ['<C-d>'];\n  to: EditorScrollDirection = 'down';\n\n  protected getNumLines(visibleRanges: vscode.Range[]) {\n    return configuration.getScrollLines(visibleRanges);\n  }\n}\n\n@RegisterAction\nclass CommandMoveHalfPageUp extends CommandScrollAndMoveCursor {\n  keys = ['<C-u>'];\n  to: EditorScrollDirection = 'up';\n\n  protected getNumLines(visibleRanges: vscode.Range[]) {\n    return configuration.getScrollLines(visibleRanges);\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtCursor extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['i'], ['<Insert>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Only allow this command to be prefixed with a count or nothing, no other\n    // actions or operators before\n    let previousActionsNumbers = true;\n    for (const prevAction of vimState.recordedState.actionsRun) {\n      if (!(prevAction instanceof CommandNumber)) {\n        previousActionsNumbers = false;\n        break;\n      }\n    }\n\n    if (vimState.recordedState.actionsRun.length === 0 || previousActionsNumbers) {\n      return super.couldActionApply(vimState, keysPressed);\n    }\n    return false;\n  }\n}\n\n@RegisterAction\nexport class CommandReplaceAtCursorFromNormalMode extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['R'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.recordedState.count || 1;\n\n    await vimState.setCurrentMode(Mode.Replace);\n    vimState.replaceState = new ReplaceState(vimState, position, timesToRepeat);\n  }\n}\n\n/**\n * Our Vim implementation selects up to but not including the final character\n * of a visual selection, instead opting to render a block cursor on the final\n * character. This works for everything except VSCode's native copy command,\n * which loses the final character because it's not selected. We override that\n * copy command here by default to include the final character.\n */\n@RegisterAction\nclass CommandOverrideCopy extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock, Mode.Insert, Mode.Normal];\n  keys = ['<copy>']; // A special key - see ModeHandler\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    let text = '';\n\n    if (vimState.currentMode === Mode.Visual) {\n      text = vimState.cursors\n        .map((range) => {\n          const [start, stop] = sorted(range.start, range.stop);\n          return vimState.document.getText(new vscode.Range(start, stop.getRight()));\n        })\n        .join('\\n');\n    } else if (vimState.currentMode === Mode.VisualLine) {\n      text = vimState.cursors\n        .map((range) => {\n          return vimState.document.getText(\n            new vscode.Range(\n              earlierOf(range.start.getLineBegin(), range.stop.getLineBegin()),\n              laterOf(range.start.getLineEnd(), range.stop.getLineEnd())\n            )\n          );\n        })\n        .join('\\n');\n    } else if (vimState.currentMode === Mode.VisualBlock) {\n      for (const { line } of TextEditor.iterateLinesInBlock(vimState)) {\n        text += line + '\\n';\n      }\n    } else if (vimState.currentMode === Mode.Insert || vimState.currentMode === Mode.Normal) {\n      text = vimState.editor.selections\n        .map((selection) => {\n          return vimState.document.getText(new vscode.Range(selection.start, selection.end));\n        })\n        .join('\\n');\n    }\n\n    await Clipboard.Copy(text);\n    // all vim yank operations return to normal mode.\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandCmdA extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['<D-a>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.cursorStartPosition = new Position(0, vimState.desiredColumn);\n    vimState.cursorStopPosition = new Position(\n      vimState.document.lineCount - 1,\n      vimState.desiredColumn\n    );\n    await vimState.setCurrentMode(Mode.VisualLine);\n  }\n}\n\n@RegisterAction\nclass MarkCommand extends BaseCommand {\n  keys = ['m', '<character>'];\n  modes = [Mode.Normal];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const markName = this.keysPressed[1];\n\n    vimState.historyTracker.addMark(position, markName);\n  }\n}\n\n@RegisterAction\nclass CommandShowCommandLine extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = [':'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Normal) {\n      if (vimState.recordedState.count) {\n        vimState.currentCommandlineText = `.,.+${vimState.recordedState.count - 1}`;\n      } else {\n        vimState.currentCommandlineText = '';\n      }\n    } else {\n      vimState.currentCommandlineText = \"'<,'>\";\n    }\n\n    // Initialize the cursor position\n    vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n\n    // Store the current mode for use in retaining selection\n    commandLine.previousMode = vimState.currentMode;\n\n    // Change to the new mode\n    await vimState.setCurrentMode(Mode.CommandlineInProgress);\n\n    // Reset history navigation index\n    commandLine.commandLineHistoryIndex = commandLine.historyEntries.length;\n  }\n}\n\n@RegisterAction\nexport class CommandShowCommandHistory extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['q', ':'];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.transformer.addTransformation({\n      type: 'showCommandHistory',\n    });\n\n    if (vimState.currentMode === Mode.Normal) {\n      vimState.currentCommandlineText = '';\n    } else {\n      vimState.currentCommandlineText = \"'<,'>\";\n    }\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class CommandShowSearchHistory extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = [\n    ['q', '/'],\n    ['q', '?'],\n  ];\n\n  private direction = SearchDirection.Forward;\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public constructor(direction = SearchDirection.Forward) {\n    super();\n    this.direction = direction;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (this.keysPressed.includes('?')) {\n      this.direction = SearchDirection.Backward;\n    }\n    vimState.recordedState.transformer.addTransformation({\n      type: 'showSearchHistory',\n      direction: this.direction,\n    });\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandDot extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['.'];\n\n  public override async execCount(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.previousFullAction) {\n      const count = vimState.recordedState.count || 1;\n\n      for (let i = 0; i < count; i++) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replayRecordedState',\n          recordedState: globalState.previousFullAction,\n        });\n      }\n    }\n  }\n}\n\n@RegisterAction\nclass CommandRepeatSubstitution extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['&'];\n  override canBeRepeatedWithDot = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // Parsing the command from a string, while not ideal, is currently\n    // necessary to make this work with and without neovim integration\n    await commandLine.Run('s', vimState);\n  }\n}\n\ntype FoldDirection = 'up' | 'down' | undefined;\nabstract class CommandFold extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  abstract commandName: string;\n  direction: FoldDirection | undefined;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.recordedState.count || 1;\n    const args =\n      this.direction !== undefined\n        ? { levels: timesToRepeat, direction: this.direction }\n        : undefined;\n    await vscode.commands.executeCommand(this.commandName, args);\n    vimState.cursors = getCursorsAfterSync();\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandToggleFold extends CommandFold {\n  keys = ['z', 'a'];\n  commandName = 'editor.toggleFold';\n}\n\n@RegisterAction\nclass CommandCloseFold extends CommandFold {\n  keys = ['z', 'c'];\n  commandName = 'editor.fold';\n  override direction: FoldDirection = 'up';\n}\n\n@RegisterAction\nclass CommandCloseAllFolds extends CommandFold {\n  keys = ['z', 'M'];\n  commandName = 'editor.foldAll';\n}\n\n@RegisterAction\nclass CommandOpenFold extends CommandFold {\n  keys = ['z', 'o'];\n  commandName = 'editor.unfold';\n  override direction: FoldDirection = 'down';\n}\n\n@RegisterAction\nclass CommandOpenAllFolds extends CommandFold {\n  keys = ['z', 'R'];\n  commandName = 'editor.unfoldAll';\n}\n\n@RegisterAction\nclass CommandCloseAllFoldsRecursively extends CommandFold {\n  override modes = [Mode.Normal];\n  keys = ['z', 'C'];\n  commandName = 'editor.foldRecursively';\n}\n\n@RegisterAction\nclass CommandOpenAllFoldsRecursively extends CommandFold {\n  override modes = [Mode.Normal];\n  keys = ['z', 'O'];\n  commandName = 'editor.unfoldRecursively';\n}\n\n@RegisterAction\nclass CommandCenterScroll extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'z'];\n\n  override preservesDesiredColumn = true;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    vimState.editor.revealRange(\n      new vscode.Range(vimState.cursorStopPosition, vimState.cursorStopPosition),\n      vscode.TextEditorRevealType.InCenter\n    );\n  }\n}\n\n@RegisterAction\nclass CommandCenterScrollFirstChar extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', '.'];\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    // This particular one moves cursor to first non blank char though\n    vimState.editor.revealRange(\n      new vscode.Range(vimState.cursorStopPosition, vimState.cursorStopPosition),\n      vscode.TextEditorRevealType.InCenter\n    );\n\n    // Move cursor to first char of line\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStopPosition.line\n    );\n  }\n}\n\n@RegisterAction\nclass CommandTopScroll extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 't'];\n\n  override preservesDesiredColumn = true;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'top',\n      },\n    });\n  }\n}\n\n@RegisterAction\nclass CommandTopScrollFirstChar extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', '\\n'];\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    // This particular one moves cursor to first non blank char though\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'top',\n      },\n    });\n\n    // Move cursor to first char of line\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStopPosition.line\n    );\n  }\n}\n\n@RegisterAction\nclass CommandBottomScroll extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'b'];\n\n  override preservesDesiredColumn = true;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'bottom',\n      },\n    });\n  }\n}\n\n@RegisterAction\nclass CommandBottomScrollFirstChar extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', '-'];\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    // This particular one moves cursor to first non blank char though\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'bottom',\n      },\n    });\n\n    // Move cursor to first char of line\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStopPosition.line\n    );\n  }\n}\n\n@RegisterAction\nclass CommandGoToOtherEndOfHighlightedText extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['o'];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    [vimState.cursorStartPosition, vimState.cursorStopPosition] = [\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition,\n    ];\n  }\n}\n\n@RegisterAction\nclass CommandGoToOtherSideOfHighlightedText extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['O'];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.VisualBlock) {\n      [vimState.cursorStartPosition, vimState.cursorStopPosition] = [\n        new vscode.Position(\n          vimState.cursorStartPosition.line,\n          vimState.cursorStopPosition.character\n        ),\n        new vscode.Position(\n          vimState.cursorStopPosition.line,\n          vimState.cursorStartPosition.character\n        ),\n      ];\n    } else {\n      return new CommandGoToOtherEndOfHighlightedText().exec(position, vimState);\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandUndo extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['u'];\n  // we support a count to undo by this setting\n  override runsOnceForEachCountPrefix = true;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const newPosition = await vimState.historyTracker.goBackHistoryStep();\n\n    if (newPosition === undefined) {\n      StatusBar.setText(vimState, 'Already at oldest change');\n    } else {\n      vimState.cursors = [new Cursor(newPosition, newPosition)];\n    }\n  }\n}\n\n@RegisterAction\nclass CommandUndoOnLine extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['U'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const newPosition = await vimState.historyTracker.goBackHistoryStepsOnLine();\n\n    if (newPosition !== undefined) {\n      vimState.cursors = [new Cursor(newPosition, newPosition)];\n    }\n  }\n}\n\n@RegisterAction\nclass CommandRedo extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<C-r>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const newPosition = await vimState.historyTracker.goForwardHistoryStep();\n\n    if (newPosition === undefined) {\n      StatusBar.setText(vimState, 'Already at newest change');\n    } else {\n      vimState.cursors = [new Cursor(newPosition, newPosition)];\n    }\n  }\n}\n\n@RegisterAction\nclass CommandDeleteToLineEnd extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['D'];\n  override canBeRepeatedWithDot = true;\n  override runsOnceForEveryCursor() {\n    return true;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.isLineEnd()) {\n      return;\n    }\n\n    const linesDown = (vimState.recordedState.count || 1) - 1;\n    const start = position;\n    const end = position.getDown(linesDown).getLineEnd().getLeftThroughLineBreaks();\n\n    await new operator.DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nexport class CommandYankFullLine extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['Y'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const linesDown = (vimState.recordedState.count || 1) - 1;\n    const start = position.getLineBegin();\n    const end = position.getDown(linesDown).getLeft();\n\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    await new operator.YankOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nclass CommandChangeToLineEnd extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['C'];\n  override runsOnceForEachCountPrefix = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const count = vimState.recordedState.count || 1;\n\n    await new operator.ChangeOperator(this.multicursorIndex).run(\n      vimState,\n      position,\n      position\n        .getDown(Math.max(0, count - 1))\n        .getLineEnd()\n        .getLeft()\n    );\n  }\n}\n\n@RegisterAction\nclass CommandClearLine extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['S'];\n  override runsOnceForEachCountPrefix = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new operator.ChangeOperator(this.multicursorIndex).runRepeat(\n      vimState,\n      position,\n      vimState.recordedState.count || 1\n    );\n  }\n\n  // Don't clash with sneak\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && !configuration.sneak;\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.couldActionApply(vimState, keysPressed) && !configuration.sneak;\n  }\n}\n\n@RegisterAction\nclass CommandExitVisualMode extends BaseCommand {\n  modes = [Mode.Visual];\n  keys = ['v'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandVisualMode extends BaseCommand {\n  modes = [Mode.Normal, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['v'];\n  override isCompleteAction = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Normal && vimState.recordedState.count > 1) {\n      vimState.cursorStopPosition = position.getRight(vimState.recordedState.count - 1);\n    }\n    await vimState.setCurrentMode(Mode.Visual);\n  }\n}\n\n@RegisterAction\nclass CommandReselectVisual extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'v'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // Try to restore selection only if valid\n    if (vimState.lastVisualSelection !== undefined) {\n      if (vimState.lastVisualSelection.end.line <= vimState.document.lineCount - 1) {\n        await vimState.setCurrentMode(vimState.lastVisualSelection.mode);\n        vimState.cursorStartPosition = vimState.lastVisualSelection.start;\n        vimState.cursorStopPosition = vimState.lastVisualSelection.end.getLeft();\n      }\n    }\n  }\n}\n\n@RegisterAction\nclass CommandVisualBlockMode extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [['<C-v>'], ['<C-q>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Normal && vimState.recordedState.count > 1) {\n      vimState.cursorStopPosition = position.getRight(vimState.recordedState.count - 1);\n    }\n    await vimState.setCurrentMode(Mode.VisualBlock);\n  }\n}\n\n@RegisterAction\nclass CommandExitVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['<C-v>'], ['<C-q>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandVisualLineMode extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  keys = ['V'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Normal && vimState.recordedState.count > 1) {\n      vimState.cursorStopPosition = position.getDown(vimState.recordedState.count - 1);\n    }\n    await vimState.setCurrentMode(Mode.VisualLine);\n  }\n}\n\n@RegisterAction\nclass CommandExitVisualLineMode extends BaseCommand {\n  modes = [Mode.VisualLine];\n  keys = ['V'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandOpenFile extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = ['g', 'f'];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    let fullFilePath: string;\n    if (vimState.currentMode === Mode.Visual) {\n      fullFilePath = vimState.document.getText(vimState.editor.selection);\n    } else {\n      const range = new vscode.Range(\n        position.prevWordStart(vimState.document, { wordType: WordType.FileName, inclusive: true }),\n        position.nextWordStart(vimState.document, { wordType: WordType.FileName })\n      );\n\n      fullFilePath = vimState.document.getText(range).trim();\n    }\n\n    const fileInfo = fullFilePath.match(/(.*?(?=:[0-9]+)|.*):?([0-9]*)$/);\n    if (fileInfo) {\n      const filePath = fileInfo[1];\n      const lineNumber = parseInt(fileInfo[2], 10);\n      const fileCommand = new FileCommand({\n        name: filePath,\n        lineNumber,\n        createFileIfNotExists: false,\n      });\n      fileCommand.execute(vimState);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandGoToDefinition extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['g', 'd'], ['<C-]>']];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.goToDeclaration');\n\n    if (vimState.editor === vscode.window.activeTextEditor) {\n      // We didn't switch to a different editor\n      vimState.cursorStopPosition = vimState.editor.selection.start;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandOpenLink extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['g', 'x'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vscode.commands.executeCommand('editor.action.openLink');\n  }\n}\n\n@RegisterAction\nclass CommandGoBackInChangelist extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', ';'];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const prevPos = vimState.historyTracker.prevChangeInChangeList();\n\n    if (prevPos instanceof VimError) {\n      StatusBar.displayError(vimState, prevPos);\n    } else {\n      vimState.cursorStopPosition = prevPos;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandGoForwardInChangelist extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', ','];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const nextPos = vimState.historyTracker.nextChangeInChangeList();\n\n    if (nextPos instanceof VimError) {\n      StatusBar.displayError(vimState, nextPos);\n    } else {\n      vimState.cursorStopPosition = nextPos;\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtLastChange extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'i'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.cursorStopPosition = vimState.cursorStartPosition =\n      vimState.historyTracker.getLastChangeEndPosition() ?? new Position(0, 0);\n\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtFirstCharacter extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['I'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = vimState.cursorStartPosition =\n      TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.line);\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtLineBegin extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'I'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = vimState.cursorStartPosition = position.getLineBegin();\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAfterCursor extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['a'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = vimState.cursorStartPosition = position.getRight();\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Only allow this command to be prefixed with a count or nothing, no other actions or operators before\n    if (!vimState.recordedState.actionsRun.every((action) => action instanceof CommandNumber)) {\n      return false;\n    }\n\n    return super.couldActionApply(vimState, keysPressed);\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtLineEnd extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['A'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = vimState.cursorStartPosition = position.getLineEnd();\n  }\n}\n\n@RegisterAction\nexport class CommandInsertNewLineAbove extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['O'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async execCount(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    const count = vimState.recordedState.count || 1;\n\n    for (let i = 0; i < count; i++) {\n      await vscode.commands.executeCommand('editor.action.insertLineBefore');\n    }\n\n    vimState.cursors = getCursorsAfterSync();\n    for (let i = 0; i < count; i++) {\n      const newPos = new Position(\n        vimState.cursors[0].start.line + i,\n        vimState.cursors[0].start.character\n      );\n      vimState.cursors.push(new Cursor(newPos, newPos));\n    }\n    vimState.cursors = vimState.cursors.reverse();\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\n@RegisterAction\nexport class CommandInsertNewLineBefore extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['o'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async execCount(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    const count = vimState.recordedState.count || 1;\n\n    for (let i = 0; i < count; i++) {\n      await vscode.commands.executeCommand('editor.action.insertLineAfter');\n    }\n    vimState.cursors = getCursorsAfterSync();\n    for (let i = 1; i < count; i++) {\n      const newPos = new Position(\n        vimState.cursorStartPosition.line - i,\n        vimState.cursorStartPosition.character\n      );\n      vimState.cursors.push(new Cursor(newPos, newPos));\n\n      // Ahhhhhh. We have to manually set cursor position here as we need text\n      // transformations AND to set multiple cursors.\n      vimState.recordedState.transformer.addTransformation({\n        type: 'insertText',\n        text: TextEditor.setIndentationLevel('', newPos.character),\n        position: newPos,\n        cursorIndex: i,\n        manuallySetCursorPositions: true,\n      });\n    }\n    vimState.cursors = vimState.cursors.reverse();\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\n@RegisterAction\nclass CommandNavigateBack extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['<C-o>'], ['<C-t>']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await globalState.jumpTracker.jumpBack(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CommandNavigateForward extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<C-i>'];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await globalState.jumpTracker.jumpForward(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CommandQuit extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [\n    ['<C-w>', 'q'],\n    ['<C-w>', '<C-q>'],\n    ['<C-w>', 'c'],\n    ['<C-w>', '<C-c>'],\n  ];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    new QuitCommand({}).execute(vimState);\n  }\n}\n\n@RegisterAction\nclass CommandOnly extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [\n    ['<C-w>', 'o'],\n    ['<C-w>', '<C-o>'],\n  ];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    new OnlyCommand().execute(vimState);\n  }\n}\n\n@RegisterAction\nclass MoveToRightPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'l'],\n    ['<C-w>', '<right>'],\n    ['<C-w>', '<C-l>'],\n  ];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateRight',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass MoveToLowerPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'j'],\n    ['<C-w>', '<down>'],\n    ['<C-w>', '<C-j>'],\n  ];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateDown',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass MoveToUpperPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'k'],\n    ['<C-w>', '<up>'],\n    ['<C-w>', '<C-k>'],\n  ];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateUp',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass MoveToLeftPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'h'],\n    ['<C-w>', '<left>'],\n    ['<C-w>', '<C-h>'],\n  ];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateLeft',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass CycleThroughPanes extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', '<C-w>'],\n    ['<C-w>', 'w'],\n  ];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateEditorGroups',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass VerticalSplit extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'v'],\n    ['<C-w>', '<C-v>'],\n  ];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.splitEditor',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass OrthogonalSplit extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 's'],\n    ['<C-w>', '<C-s>'],\n  ];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.splitEditorOrthogonal',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass EvenPaneWidths extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['<C-w>', '='];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.evenEditorWidths',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass CommandTabNext extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [['g', 't'], ['<C-pagedown>']];\n  override runsOnceForEachCountPrefix = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // gt behaves differently than gT and goes to an absolute index tab\n    // (1-based), it does NOT iterate over next tabs\n    if (vimState.recordedState.count > 0) {\n      new TabCommand({\n        tab: Tab.Absolute,\n        count: vimState.recordedState.count - 1,\n      }).execute(vimState);\n    } else {\n      new TabCommand({\n        tab: Tab.Next,\n        count: 1,\n      }).execute(vimState);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandTabPrevious extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [['g', 'T'], ['<C-pageup>']];\n  override runsOnceForEachCountPrefix = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    new TabCommand({\n      tab: Tab.Previous,\n      count: 1,\n    }).execute(vimState);\n  }\n}\n\n@RegisterAction\nexport class ActionDeleteChar extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['x'];\n  override canBeRepeatedWithDot = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // If line is empty, do nothing\n    if (vimState.document.lineAt(position).text.length === 0) {\n      return;\n    }\n\n    const timesToRepeat = vimState.recordedState.count || 1;\n\n    await new operator.DeleteOperator(this.multicursorIndex).run(\n      vimState,\n      position,\n      position.getRight(timesToRepeat - 1).getLeftIfEOL()\n    );\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class ActionDeleteCharWithDeleteKey extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<Del>'];\n  override runsOnceForEachCountPrefix = true;\n  override canBeRepeatedWithDot = true;\n\n  public override async execCount(position: Position, vimState: VimState): Promise<void> {\n    // If <del> has a count in front of it, then <del> deletes a character\n    // off the count. Therefore, 100<del>x, would apply 'x' 10 times.\n    // http://vimdoc.sourceforge.net/htmldoc/change.html#<Del>\n    if (vimState.recordedState.count !== 0) {\n      vimState.recordedState.count = Math.floor(vimState.recordedState.count / 10);\n\n      // Change actionsRunPressedKeys so that showCmd updates correctly\n      vimState.recordedState.actionsRunPressedKeys =\n        vimState.recordedState.count > 0 ? vimState.recordedState.count.toString().split('') : [];\n      this.isCompleteAction = false;\n    } else {\n      await new ActionDeleteChar().execCount(position, vimState);\n    }\n  }\n}\n\n@RegisterAction\nexport class ActionDeleteLastChar extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['X'];\n  override canBeRepeatedWithDot = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.character === 0) {\n      return;\n    }\n\n    const timesToRepeat = vimState.recordedState.count || 1;\n\n    await new operator.DeleteOperator(this.multicursorIndex).run(\n      vimState,\n      position.getLeft(timesToRepeat),\n      position.getLeft()\n    );\n  }\n}\n\n@RegisterAction\nclass ActionJoin extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['J'];\n  override canBeRepeatedWithDot = true;\n  override runsOnceForEachCountPrefix = false;\n\n  private firstNonWhitespaceIndex(str: string): number {\n    for (let i = 0, len = str.length; i < len; i++) {\n      const chCode = str.charCodeAt(i);\n      if (chCode !== 32 /** space */ && chCode !== 9 /** tab */) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  public async execJoinLines(\n    startPosition: Position,\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<void> {\n    count = count - 1 || 1;\n\n    const joinspaces = configuration.joinspaces;\n\n    let startLineNumber: number;\n    let startColumn: number;\n    let endLineNumber: number;\n    let endColumn: number;\n    let columnDeltaOffset: number = 0;\n\n    if (startPosition.isEqual(position) || startPosition.line === position.line) {\n      if (position.line + 1 < vimState.document.lineCount) {\n        startLineNumber = position.line;\n        startColumn = 0;\n        endLineNumber = position.getDown(count).line;\n        endColumn = TextEditor.getLineLength(endLineNumber);\n      } else {\n        startLineNumber = position.line;\n        startColumn = 0;\n        endLineNumber = position.line;\n        endColumn = TextEditor.getLineLength(endLineNumber);\n      }\n    } else {\n      startLineNumber = startPosition.line;\n      startColumn = 0;\n      endLineNumber = position.line;\n      endColumn = TextEditor.getLineLength(endLineNumber);\n    }\n\n    let trimmedLinesContent = vimState.document.lineAt(startPosition).text;\n\n    for (let i = startLineNumber + 1; i <= endLineNumber; i++) {\n      const lineText = vimState.document.lineAt(i).text;\n\n      const firstNonWhitespaceIdx = this.firstNonWhitespaceIndex(lineText);\n\n      if (firstNonWhitespaceIdx >= 0) {\n        // Compute number of spaces to separate the lines\n        let insertSpace = ' ';\n\n        if (trimmedLinesContent === '' || trimmedLinesContent.endsWith('\\t')) {\n          insertSpace = '';\n        } else if (\n          joinspaces &&\n          (trimmedLinesContent.endsWith('.') ||\n            trimmedLinesContent.endsWith('!') ||\n            trimmedLinesContent.endsWith('?'))\n        ) {\n          insertSpace = '  ';\n        } else if (\n          joinspaces &&\n          (trimmedLinesContent.endsWith('. ') ||\n            trimmedLinesContent.endsWith('! ') ||\n            trimmedLinesContent.endsWith('? '))\n        ) {\n          insertSpace = ' ';\n        } else if (trimmedLinesContent.endsWith(' ')) {\n          insertSpace = '';\n        }\n\n        const lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx);\n\n        if (lineTextWithoutIndent.charAt(0) === ')') {\n          insertSpace = '';\n        }\n\n        trimmedLinesContent += insertSpace + lineTextWithoutIndent;\n        columnDeltaOffset = lineTextWithoutIndent.length + insertSpace.length;\n      }\n    }\n\n    const deleteStartPosition = new Position(startLineNumber, startColumn);\n    const deleteEndPosition = new Position(endLineNumber, endColumn);\n\n    if (!deleteStartPosition.isEqual(deleteEndPosition)) {\n      if (startPosition.isEqual(position)) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: trimmedLinesContent,\n          range: new vscode.Range(deleteStartPosition, deleteEndPosition),\n          diff: PositionDiff.offset({\n            character: trimmedLinesContent.length - columnDeltaOffset - position.character,\n          }),\n        });\n      } else {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: trimmedLinesContent,\n          range: new vscode.Range(deleteStartPosition, deleteEndPosition),\n          manuallySetCursorPositions: true,\n        });\n\n        vimState.cursorStartPosition = vimState.cursorStopPosition = new Position(\n          startPosition.line,\n          trimmedLinesContent.length - columnDeltaOffset\n        );\n        await vimState.setCurrentMode(Mode.Normal);\n      }\n    }\n  }\n\n  public override async execCount(position: Position, vimState: VimState): Promise<void> {\n    const cursorsToIterateOver = vimState.cursors\n      .map((x) => new Cursor(x.start, x.stop))\n      .sort((a, b) =>\n        a.start.line > b.start.line ||\n        (a.start.line === b.start.line && a.start.character > b.start.character)\n          ? 1\n          : -1\n      );\n\n    const resultingCursors: Cursor[] = [];\n    for (const [idx, { start, stop }] of cursorsToIterateOver.entries()) {\n      this.multicursorIndex = idx;\n\n      vimState.cursorStopPosition = stop;\n      vimState.cursorStartPosition = start;\n\n      await this.execJoinLines(start, stop, vimState, vimState.recordedState.count || 1);\n\n      resultingCursors.push(new Cursor(vimState.cursorStartPosition, vimState.cursorStopPosition));\n\n      for (const transformation of vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = this.multicursorIndex;\n        }\n      }\n    }\n\n    vimState.cursors = resultingCursors;\n  }\n}\n\n@RegisterAction\nclass ActionJoinVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['J'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.editor.selection.start, vimState.editor.selection.end);\n\n    /**\n     * For joining lines, Visual Line behaves the same as Visual so we align the register mode here.\n     */\n    vimState.currentRegisterMode = RegisterMode.CharacterWise;\n    await new ActionJoin().execJoinLines(start, end, vimState, 1);\n  }\n}\n\n@RegisterAction\nclass ActionJoinVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['J'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n\n    vimState.currentRegisterMode = RegisterMode.CharacterWise;\n    await new ActionJoin().execJoinLines(start, end, vimState, 1);\n  }\n}\n\n@RegisterAction\nclass ActionJoinNoWhitespace extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'J'];\n  override canBeRepeatedWithDot = true;\n\n  // gJ is essentially J without the edge cases. ;-)\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.line === vimState.document.lineCount - 1) {\n      return; // TODO: bell\n    }\n\n    const count = vimState.recordedState.count > 2 ? vimState.recordedState.count - 1 : 1;\n    await this.execJoin(count, position, vimState);\n  }\n\n  public async execJoin(count: number, position: Position, vimState: VimState): Promise<void> {\n    const replaceRange = new vscode.Range(\n      new Position(position.line, 0),\n      new Position(Math.min(position.line + count, vimState.document.lineCount - 1), 0).getLineEnd()\n    );\n\n    const joinedText = vimState.document.getText(replaceRange).replace(/\\r?\\n/g, '');\n\n    // Put the cursor at the start of the last joined line's text\n    const newCursorColumn =\n      joinedText.length - vimState.document.lineAt(replaceRange.end).text.length;\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      range: replaceRange,\n      text: joinedText,\n      diff: PositionDiff.exactCharacter({\n        character: newCursorColumn,\n      }),\n    });\n  }\n}\n\n@RegisterAction\nclass ActionJoinNoWhitespaceVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['g', 'J'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    const count = start.line === end.line ? 1 : end.line - start.line;\n    await new ActionJoinNoWhitespace().execJoin(count, start, vimState);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionReplaceCharacter extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['r', '<character>'];\n  override canBeRepeatedWithDot = true;\n  override runsOnceForEachCountPrefix = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.recordedState.count || 1;\n    const toReplace = this.keysPressed[1];\n\n    /**\n     * <character> includes <BS>, <S-BS> and <TAB> but not any control keys,\n     * so we ignore the former two keys and have a special handle for <tab>.\n     */\n\n    if (['<BS>', '<S-BS>'].includes(toReplace.toUpperCase())) {\n      return;\n    }\n\n    if (position.character + timesToRepeat > position.getLineEnd().character) {\n      return;\n    }\n\n    let endPos = new Position(position.line, position.character + timesToRepeat);\n\n    // Return if tried to repeat longer than linelength\n    if (endPos.character > vimState.document.lineAt(endPos).text.length) {\n      return;\n    }\n\n    // If last char (not EOL char), add 1 so that replace selection is complete\n    if (endPos.character > vimState.document.lineAt(endPos).text.length) {\n      endPos = new Position(endPos.line, endPos.character + 1);\n    }\n\n    if (toReplace === '<tab>') {\n      vimState.recordedState.transformer.delete(new vscode.Range(position, endPos));\n      vimState.recordedState.transformer.addTransformation({\n        type: 'tab',\n        cursorIndex: this.multicursorIndex,\n        diff: PositionDiff.offset({ character: -1 }),\n      });\n    } else if (toReplace === '\\n') {\n      // A newline replacement always inserts exactly one newline (regardless\n      // of count prefix) and puts the cursor on the next line.\n      // We use `insertTextVSCode` so we get the right indentation\n      vimState.recordedState.transformer.delete(new vscode.Range(position, endPos));\n      vimState.recordedState.transformer.addTransformation({\n        type: 'insertTextVSCode',\n        text: '\\n',\n      });\n    } else {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: toReplace.repeat(timesToRepeat),\n        range: new vscode.Range(position, endPos),\n        diff: PositionDiff.offset({ character: timesToRepeat - 1 }),\n      });\n    }\n  }\n}\n\n@RegisterAction\nclass ActionReplaceCharacterVisual extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['r', '<character>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override canBeRepeatedWithDot = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    let toInsert = this.keysPressed[1];\n\n    if (toInsert === '<tab>') {\n      toInsert = TextEditor.getTabCharacter(vimState.editor);\n    }\n\n    let visualSelectionOffset = 1;\n\n    // If selection is reversed, reorganize it so that the text replace logic always works\n    let [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    if (vimState.currentMode === Mode.VisualLine) {\n      [start, end] = [start.getLineBegin(), end.getLineEnd()];\n    }\n\n    // Limit to not replace EOL\n    const textLength = vimState.document.lineAt(end).text.length;\n    if (textLength <= 0) {\n      visualSelectionOffset = 0;\n    }\n    end = new Position(end.line, Math.min(end.character, textLength > 0 ? textLength - 1 : 0));\n\n    // Iterate over every line in the current selection\n    for (let lineNum = start.line; lineNum <= end.line; lineNum++) {\n      // Get line of text\n      const lineText = vimState.document.lineAt(lineNum).text;\n\n      if (start.line === end.line) {\n        // This is a visual section all on one line, only replace the part within the selection\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(end.character - start.character + 2).join(toInsert),\n          range: new vscode.Range(start, new Position(end.line, end.character + 1)),\n          manuallySetCursorPositions: true,\n        });\n      } else if (lineNum === start.line) {\n        // This is the first line of the selection so only replace after the cursor\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(lineText.length - start.character + 1).join(toInsert),\n          range: new vscode.Range(start, new Position(start.line, lineText.length)),\n          manuallySetCursorPositions: true,\n        });\n      } else if (lineNum === end.line) {\n        // This is the last line of the selection so only replace before the cursor\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(end.character + 1 + visualSelectionOffset).join(toInsert),\n          range: new vscode.Range(\n            new Position(end.line, 0),\n            new Position(end.line, end.character + visualSelectionOffset)\n          ),\n          manuallySetCursorPositions: true,\n        });\n      } else {\n        // Replace the entire line length since it is in the middle of the selection\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(lineText.length + 1).join(toInsert),\n          range: new vscode.Range(new Position(lineNum, 0), new Position(lineNum, lineText.length)),\n          manuallySetCursorPositions: true,\n        });\n      }\n    }\n\n    vimState.cursorStopPosition = start;\n    vimState.cursorStartPosition = start;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionReplaceCharacterVisualBlock extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['r', '<character>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override canBeRepeatedWithDot = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    let toInsert = this.keysPressed[1];\n\n    if (toInsert === '<tab>') {\n      toInsert = TextEditor.getTabCharacter(vimState.editor);\n    }\n\n    for (const { start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      if (end.isBeforeOrEqual(start)) {\n        continue;\n      }\n\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: Array(end.character - start.character + 1).join(toInsert),\n        range: new vscode.Range(start, end),\n        manuallySetCursorPositions: true,\n      });\n    }\n\n    const topLeft = visualBlockGetTopLeftPosition(\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition\n    );\n    vimState.cursors = [new Cursor(topLeft, topLeft)];\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionDeleteVisualBlock extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['d'], ['x'], ['X']];\n  override canBeRepeatedWithDot = true;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const lines: string[] = [];\n\n    for (const { line, start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      lines.push(line);\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new vscode.Range(start, end),\n        manuallySetCursorPositions: true,\n      });\n    }\n\n    const text = lines.length === 1 ? lines[0] : lines.join('\\n');\n    vimState.currentRegisterMode = RegisterMode.BlockWise;\n    Register.put(vimState, text, this.multicursorIndex, true);\n\n    const topLeft = visualBlockGetTopLeftPosition(\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition\n    );\n\n    vimState.cursors = [new Cursor(topLeft, topLeft)];\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionShiftDVisualBlock extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['D'];\n  override canBeRepeatedWithDot = true;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    for (const { start } of TextEditor.iterateLinesInBlock(vimState)) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new vscode.Range(start, start.getLineEnd()),\n        manuallySetCursorPositions: true,\n      });\n    }\n\n    const topLeft = visualBlockGetTopLeftPosition(\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition\n    );\n\n    vimState.cursors = [new Cursor(topLeft, topLeft)];\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['I'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const cursors: Cursor[] = [];\n    for (const cursor of vimState.cursors) {\n      for (const { line, start } of TextEditor.iterateLinesInBlock(vimState, cursor)) {\n        if (line === '' && start.character !== 0) {\n          continue;\n        }\n        cursors.push(new Cursor(start, start));\n      }\n    }\n    vimState.cursors = cursors;\n\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\n@RegisterAction\nclass ActionChangeInVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['c'], ['s']];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const cursors: Cursor[] = [];\n    for (const cursor of vimState.cursors) {\n      for (const { start, end } of TextEditor.iterateLinesInBlock(vimState, cursor)) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'deleteRange',\n          range: new vscode.Range(start, end),\n          manuallySetCursorPositions: true,\n        });\n        cursors.push(new Cursor(start, start));\n      }\n    }\n    vimState.cursors = cursors;\n\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\n@RegisterAction\nclass ActionChangeToEOLInVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['C'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const cursors: Cursor[] = [];\n    for (const cursor of vimState.cursors) {\n      for (const { start, end } of TextEditor.iterateLinesInBlock(vimState, cursor)) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'deleteRange',\n          range: new vscode.Range(start, start.getLineEnd()),\n          collapseRange: true,\n        });\n        cursors.push(new Cursor(end, end));\n      }\n    }\n    vimState.cursors = cursors;\n\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\nabstract class ActionGoToInsertVisualLineModeCommand extends BaseCommand {\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  abstract getCursorRangeForLine(\n    line: vscode.TextLine,\n    selectionStart: Position,\n    selectionEnd: Position\n  ): Cursor;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isFakeMultiCursor = true;\n\n    const resultingCursors: Cursor[] = [];\n    const cursorsOnBlankLines: Cursor[] = [];\n    for (const selection of vimState.editor.selections) {\n      const { start, end } = selection;\n\n      for (let i = start.line; i <= end.line; i++) {\n        const line = vimState.document.lineAt(i);\n\n        const cursorRange = this.getCursorRangeForLine(line, start, end);\n        if (!line.isEmptyOrWhitespace) {\n          resultingCursors.push(cursorRange);\n        } else {\n          cursorsOnBlankLines.push(cursorRange);\n        }\n      }\n    }\n\n    if (resultingCursors.length > 0) {\n      vimState.cursors = resultingCursors;\n    } else {\n      vimState.cursors = cursorsOnBlankLines;\n    }\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualLineMode extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.VisualLine];\n  keys = ['I'];\n\n  getCursorRangeForLine(line: vscode.TextLine): Cursor {\n    const startCharacterPosition = new Position(\n      line.lineNumber,\n      line.firstNonWhitespaceCharacterIndex\n    );\n    return new Cursor(startCharacterPosition, startCharacterPosition);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualLineModeAppend extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.VisualLine];\n  keys = ['A'];\n\n  getCursorRangeForLine(line: vscode.TextLine): Cursor {\n    const endCharacterPosition = new Position(line.lineNumber, line.range.end.character);\n    return new Cursor(endCharacterPosition, endCharacterPosition);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualMode extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.Visual];\n  keys = ['I'];\n\n  getCursorRangeForLine(\n    line: vscode.TextLine,\n    selectionStart: Position,\n    selectionEnd: Position\n  ): Cursor {\n    const startCharacterPosition =\n      line.lineNumber === selectionStart.line\n        ? selectionStart\n        : new Position(line.lineNumber, line.firstNonWhitespaceCharacterIndex);\n    return new Cursor(startCharacterPosition, startCharacterPosition);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualModeAppend extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.Visual];\n  keys = ['A'];\n\n  getCursorRangeForLine(\n    line: vscode.TextLine,\n    selectionStart: Position,\n    selectionEnd: Position\n  ): Cursor {\n    const endCharacterPosition =\n      line.lineNumber === selectionEnd.line\n        ? selectionEnd\n        : new Position(line.lineNumber, line.range.end.character);\n    return new Cursor(endCharacterPosition, endCharacterPosition);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualBlockModeAppend extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['A'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const newCursors: Cursor[] = [];\n    for (const cursor of vimState.cursors) {\n      const [start, end] = sorted(cursor.start, cursor.stop);\n      for (let lineNum = start.line; lineNum <= end.line; lineNum++) {\n        const line = vimState.document.lineAt(lineNum);\n        const insertionColumn =\n          vimState.desiredColumn === Number.POSITIVE_INFINITY\n            ? line.text.length\n            : Math.max(cursor.start.character, cursor.stop.character) + 1;\n        if (line.text.length < insertionColumn) {\n          await TextEditor.insert(\n            vimState.editor,\n            ' '.repeat(insertionColumn - line.text.length),\n            line.range.end,\n            false\n          );\n        }\n        const newCursor = new Position(lineNum, insertionColumn);\n        newCursors.push(new Cursor(newCursor, newCursor));\n      }\n    }\n\n    vimState.cursors = newCursors;\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\n@RegisterAction\nclass ActionDeleteLineVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['X'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    await new operator.DeleteOperator(this.multicursorIndex).run(\n      vimState,\n      start.getLineBegin(),\n      end.getLineEnd()\n    );\n  }\n}\n\n@RegisterAction\nclass ActionChangeLineVisualModeS extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['S'];\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return !configuration.surround && super.doesActionApply(vimState, keysPressed);\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    return new ActionChangeLineVisualMode().exec(position, vimState);\n  }\n}\n\n@RegisterAction\nclass ActionChangeLineVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = [['C'], ['R']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    await new operator.ChangeOperator(this.multicursorIndex).run(\n      vimState,\n      start.getLineBegin(),\n      end.getLineEnd().getLeftIfEOL()\n    );\n  }\n}\n\n@RegisterAction\nclass ActionChangeLineVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['R'], ['S']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    return new ActionChangeLineVisualMode().exec(position, vimState);\n  }\n}\n\n@RegisterAction\nclass ActionChangeChar extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['s'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new operator.ChangeOperator(this.multicursorIndex).run(\n      vimState,\n      position,\n      position.getRight((vimState.recordedState.count || 1) - 1)\n    );\n  }\n\n  // Don't clash with surround or sneak modes!\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return (\n      super.doesActionApply(vimState, keysPressed) &&\n      !configuration.sneak &&\n      !vimState.recordedState.operator\n    );\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return (\n      super.couldActionApply(vimState, keysPressed) &&\n      !configuration.sneak &&\n      !vimState.recordedState.operator\n    );\n  }\n}\n\n@RegisterAction\nclass ToggleCaseAndMoveForward extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['~'];\n  override canBeRepeatedWithDot = true;\n\n  private toggleCase(text: string): string {\n    let newText = '';\n    for (const char of text) {\n      let toggled = char.toLocaleLowerCase();\n      if (toggled === char) {\n        toggled = char.toLocaleUpperCase();\n      }\n      newText += toggled;\n    }\n    return newText;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const count = vimState.recordedState.count || 1;\n    const range = new vscode.Range(\n      position,\n      shouldWrapKey(vimState.currentMode, '~')\n        ? position.getOffsetThroughLineBreaks(count)\n        : position.getRight(count)\n    );\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      range,\n      text: this.toggleCase(vimState.document.getText(range)),\n      diff: PositionDiff.exactPosition(range.end),\n    });\n  }\n}\n\nabstract class IncrementDecrementNumberAction extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  override canBeRepeatedWithDot = true;\n  abstract offset: number;\n  abstract staircase: boolean;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const ranges = this.getSearchRanges(vimState);\n\n    let stepNum = 1;\n\n    for (const [idx, range] of ranges.entries()) {\n      position = range.start;\n\n      const text = vimState.document.lineAt(position).text;\n\n      // Make sure position within the text is possible and return if not\n      if (text.length <= position.character) {\n        continue;\n      }\n\n      // Start looking to the right for the next word to increment, unless we're\n      // already on a word to increment, in which case start at the beginning of\n      // that word.\n      const whereToStart = text[position.character].match(/\\s/)\n        ? position\n        : position.prevWordStart(vimState.document, { inclusive: true });\n\n      wordLoop: for (let { start, end, word } of TextEditor.iterateWords(\n        vimState.document,\n        whereToStart\n      )) {\n        if (start.isAfter(range.stop)) {\n          break;\n        }\n\n        // '-' doesn't count as a word, but is important to include in parsing\n        // the number, as long as it is not just part of the word (-foo2 for example)\n        if (text[start.character - 1] === '-' && /\\d/.test(text[start.character])) {\n          start = start.getLeft();\n          word = text[start.character] + word;\n        }\n        // Strict number parsing so \"1a\" doesn't silently get converted to \"1\"\n        do {\n          const result = NumericString.parse(word);\n          if (result === undefined) {\n            break;\n          }\n          const { num, suffixOffset } = result;\n\n          // Use suffix offset to check if current cursor is in or before detected number.\n          if (position.character < start.character + suffixOffset) {\n            const pos = await this.replaceNum(\n              vimState,\n              num,\n              this.offset * stepNum * (vimState.recordedState.count || 1),\n              start,\n              end\n            );\n\n            if (this.staircase) {\n              stepNum++;\n            }\n\n            if (vimState.currentMode === Mode.Normal) {\n              vimState.recordedState.transformer.addTransformation({\n                type: 'moveCursor',\n                diff: PositionDiff.exactPosition(pos.getLeft(num.suffix.length)),\n              });\n            }\n            break wordLoop;\n          } else {\n            // For situation like this: xyz1999em199[cursor]9m\n            word = word.slice(suffixOffset);\n            start = new Position(start.line, start.character + suffixOffset);\n          }\n        } while (true);\n      }\n    }\n\n    if (isVisualMode(vimState.currentMode)) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'moveCursor',\n        diff: PositionDiff.exactPosition(ranges[0].start),\n      });\n    }\n\n    vimState.setCurrentMode(Mode.Normal);\n  }\n\n  private async replaceNum(\n    vimState: VimState,\n    start: NumericString,\n    offset: number,\n    startPos: Position,\n    endPos: Position\n  ): Promise<Position> {\n    const oldLength = endPos.character + 1 - startPos.character;\n    start.value += offset;\n    const newNum = start.toString();\n\n    const range = new vscode.Range(startPos, endPos.getRight());\n\n    vimState.recordedState.transformer.replace(range, newNum);\n    if (oldLength !== newNum.length) {\n      // Adjust end position according to difference in width of number-string\n      endPos = new Position(endPos.line, startPos.character + newNum.length - 1);\n    }\n\n    return endPos;\n  }\n\n  /**\n   * @returns a list of Ranges in which to search for numbers\n   */\n  private getSearchRanges(vimState: VimState): Cursor[] {\n    const ranges: Cursor[] = [];\n    const [start, stop] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    switch (vimState.currentMode) {\n      case Mode.Normal: {\n        ranges.push(\n          new Cursor(vimState.cursorStopPosition, vimState.cursorStopPosition.getLineEnd())\n        );\n        break;\n      }\n\n      case Mode.Visual: {\n        ranges.push(new Cursor(start, start.getLineEnd()));\n        for (let line = start.line + 1; line < stop.line; line++) {\n          const lineStart = new Position(line, 0);\n          ranges.push(new Cursor(lineStart, lineStart.getLineEnd()));\n        }\n        ranges.push(new Cursor(stop.getLineBegin(), stop));\n        break;\n      }\n\n      case Mode.VisualLine: {\n        for (let line = start.line; line <= stop.line; line++) {\n          const lineStart = new Position(line, 0);\n          ranges.push(new Cursor(lineStart, lineStart.getLineEnd()));\n        }\n        break;\n      }\n\n      case Mode.VisualBlock: {\n        const topLeft = visualBlockGetTopLeftPosition(start, stop);\n        const bottomRight = visualBlockGetBottomRightPosition(start, stop);\n        for (let line = topLeft.line; line <= bottomRight.line; line++) {\n          ranges.push(\n            new Cursor(\n              new Position(line, topLeft.character),\n              new Position(line, bottomRight.character)\n            )\n          );\n        }\n        break;\n      }\n\n      default:\n        throw new Error(\n          `Unexpected mode ${vimState.currentMode} in IncrementDecrementNumberAction.getPositions()`\n        );\n    }\n    return ranges;\n  }\n}\n\n@RegisterAction\nclass IncrementNumberAction extends IncrementDecrementNumberAction {\n  keys = ['<C-a>'];\n  offset = +1;\n  staircase = false;\n}\n\n@RegisterAction\nclass DecrementNumberAction extends IncrementDecrementNumberAction {\n  keys = ['<C-x>'];\n  offset = -1;\n  staircase = false;\n}\n\n@RegisterAction\nclass IncrementNumberStaircaseAction extends IncrementDecrementNumberAction {\n  keys = ['g', '<C-a>'];\n  offset = +1;\n  staircase = true;\n}\n\n@RegisterAction\nclass DecrementNumberStaircaseAction extends IncrementDecrementNumberAction {\n  keys = ['g', '<C-x>'];\n  offset = -1;\n  staircase = true;\n}\n\n@RegisterAction\nclass CommandUnicodeName extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'a'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const char = vimState.document.getText(new vscode.Range(position, position.getRight()));\n    const charCode = char.charCodeAt(0);\n    // TODO: Handle charCode > 127 by also including <M-x>\n    StatusBar.setText(\n      vimState,\n      `<${char}>  ${charCode},  Hex ${charCode.toString(16)},  Octal ${charCode.toString(8)}`\n    );\n  }\n}\n\n@RegisterAction\nclass ActionTriggerHover extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'h'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.showHover');\n  }\n}\n\n/**\n * Multi-Cursor Command Overrides\n *\n * We currently have to override the VSCode key commands that get us into multi-cursor mode.\n *\n * Normally, we'd just listen for another cursor to be added in order to go into multi-cursor\n * mode rather than rewriting each keybinding one-by-one. We can't currently do that because\n * Visual Block Mode also creates additional cursors, but will get confused if you're in\n * multi-cursor mode.\n */\n\n@RegisterAction\nexport class ActionOverrideCmdD extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = [['<D-d>'], ['g', 'b']];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override runsOnceForEachCountPrefix = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.addSelectionToNextFindMatch');\n    vimState.cursors = getCursorsAfterSync();\n\n    // If this is the first cursor, select 1 character less\n    // so that only the word is selected, no extra character\n    vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getLeft()));\n\n    await vimState.setCurrentMode(Mode.Visual);\n  }\n}\n\n@RegisterAction\nclass ActionOverrideCmdDInsert extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<D-d>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override runsOnceForEachCountPrefix = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // Since editor.action.addSelectionToNextFindMatch uses the selection to\n    // determine where to add a word, we need to do a hack and manually set the\n    // selections to the word boundaries before we make the api call.\n    vimState.editor.selections = vimState.editor.selections.map((x, idx) => {\n      const curPos = x.active;\n      if (idx === 0) {\n        return new vscode.Selection(\n          curPos.prevWordStart(vimState.document),\n          curPos.getLeft().nextWordEnd(vimState.document, { inclusive: true }).getRight()\n        );\n      } else {\n        // Since we're adding the selections ourselves, we need to make sure\n        // that our selection is actually over what our original word is\n        const matchWordPos = vimState.editor.selections[0].active;\n        const matchWordLength =\n          matchWordPos.getLeft().nextWordEnd(vimState.document, { inclusive: true }).getRight()\n            .character - matchWordPos.prevWordStart(vimState.document).character;\n        const wordBegin = curPos.getLeft(matchWordLength);\n        return new vscode.Selection(wordBegin, curPos);\n      }\n    });\n    await vscode.commands.executeCommand('editor.action.addSelectionToNextFindMatch');\n    vimState.cursors = getCursorsAfterSync();\n  }\n}\n\n@RegisterAction\nclass ActionOverrideCmdAltDown extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = [\n    ['<D-alt+down>'], // OSX\n    ['<C-alt+down>'], // Windows\n  ];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override runsOnceForEachCountPrefix = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.insertCursorBelow');\n    vimState.cursors = getCursorsAfterSync();\n  }\n}\n\n@RegisterAction\nclass ActionOverrideCmdAltUp extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = [\n    ['<D-alt+up>'], // OSX\n    ['<C-alt+up>'], // Windows\n  ];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override runsOnceForEachCountPrefix = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.insertCursorAbove');\n    vimState.cursors = getCursorsAfterSync();\n  }\n}\n\n@RegisterAction\nclass ActionShowFileInfo extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<C-g>'];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    reportFileInfo(position, vimState);\n  }\n}\n\n@RegisterAction\nclass WriteQuit extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['Z', 'Z']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new WriteQuitCommand({}).execute(vimState);\n  }\n}\n\n@RegisterAction\nclass Quit extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['Z', 'Q']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new QuitCommand({ bang: true }).execute(vimState);\n  }\n}\n\n@RegisterAction\nclass ActionGoToAlternateFile extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['<C-6>'], ['<C-^>']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const altFile = await Register.get('#');\n    if (altFile === undefined || altFile.text === '') {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NoAlternateFile));\n    } else {\n      const files = await vscode.workspace.findFiles(altFile.text as string);\n      // TODO: if the path matches a file from multiple workspace roots, we may not choose the right one\n      if (files.length > 0) {\n        const document = await vscode.workspace.openTextDocument(files[0]);\n        await vscode.window.showTextDocument(document);\n      }\n    }\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { RegisterAction, BaseCommand } from '../base';\nimport { CommandShowCommandHistory, CommandShowSearchHistory } from './actions';\nimport { Mode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { commandLine } from '../../cmd_line/commandLine';\nimport { globalState } from '../../state/globalState';\nimport { Register, RegisterMode } from '../../register/register';\nimport { reportSearch } from '../../util/statusBarTextUtils';\nimport { RecordedState } from '../../state/recordedState';\nimport { TextEditor } from '../../textEditor';\nimport { StatusBar } from '../../statusBar';\nimport { getPathDetails, readDirectory } from '../../util/path';\nimport { Clipboard } from '../../util/clipboard';\nimport { VimError, ErrorCode } from '../../error';\nimport { SearchDirection } from '../../state/searchState';\nimport { scrollView } from '../../util/util';\nimport { getWordLeftInText, getWordRightInText, WordType } from '../../textobject/word';\nimport { Position } from 'vscode';\nimport { commandParsers } from '../../vimscript/exCommandParser';\n\n/**\n * Commands that are only relevant when entering a command or search\n */\n\n// TODO: Much of the code in this file is duplicated.\n//       We need an interface to the status bar which can be used by both modes.\n\n// Command tab backward from behind shift tab\n@RegisterAction\nclass CommandTabInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [['<tab>'], ['<S-tab>']];\n  override runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  private cycleCompletion(vimState: VimState, isTabForward: boolean) {\n    const autoCompleteItems = commandLine.autoCompleteItems;\n    if (autoCompleteItems.length === 0) {\n      return;\n    }\n\n    commandLine.autoCompleteIndex = isTabForward\n      ? (commandLine.autoCompleteIndex + 1) % autoCompleteItems.length\n      : (commandLine.autoCompleteIndex - 1 + autoCompleteItems.length) % autoCompleteItems.length;\n\n    const lastPos = commandLine.preCompleteCharacterPos;\n    const lastCmd = commandLine.preCompleteCommand;\n    const evalCmd = lastCmd.slice(0, lastPos);\n    const restCmd = lastCmd.slice(lastPos);\n\n    vimState.currentCommandlineText =\n      evalCmd + autoCompleteItems[commandLine.autoCompleteIndex] + restCmd;\n    vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length - restCmd.length;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    const isTabForward = key === '<tab>';\n\n    if (\n      commandLine.autoCompleteItems.length !== 0 &&\n      this.keys.some((k) => commandLine.lastKeyPressed === k[0])\n    ) {\n      this.cycleCompletion(vimState, isTabForward);\n      commandLine.lastKeyPressed = key;\n      return;\n    }\n\n    let newCompletionItems: string[] = [];\n    const currentCmd = vimState.currentCommandlineText;\n    const cursorPos = vimState.statusBarCursorCharacterPos;\n\n    // Sub string since vim does completion before the cursor\n    let evalCmd = currentCmd.slice(0, cursorPos);\n    const restCmd = currentCmd.slice(cursorPos);\n\n    // \\s* is the match the extra space before any character like ':  edit'\n    const cmdRegex = /^\\s*\\w+$/;\n    const fileRegex = /^\\s*\\w+\\s+/g;\n    if (cmdRegex.test(evalCmd)) {\n      // Command completion\n      newCompletionItems = Object.keys(commandParsers)\n        .filter((cmd) => cmd.startsWith(evalCmd))\n        // Remove the already typed portion in the array\n        .map((cmd) => cmd.slice(cmd.search(evalCmd) + evalCmd.length))\n        .sort();\n    } else if (fileRegex.exec(evalCmd)) {\n      // File completion by searching if there is a space after the first word/command\n      // ideally it should be a process of white-listing to selected commands like :e and :vsp\n      const filePathInCmd = evalCmd.substring(fileRegex.lastIndex);\n      const currentUri = vimState.document.uri;\n      const isRemote = !!vscode.env.remoteName;\n\n      const {\n        fullDirPath,\n        baseName,\n        partialPath,\n        path: p,\n      } = getPathDetails(filePathInCmd, currentUri, isRemote);\n      // Update the evalCmd in case of windows, where we change / to \\\n      evalCmd = evalCmd.slice(0, fileRegex.lastIndex) + partialPath;\n\n      // test if the baseName is . or ..\n      const shouldAddDotItems = /^\\.\\.?$/g.test(baseName);\n      const dirItems = await readDirectory(\n        fullDirPath,\n        p.sep,\n        currentUri,\n        isRemote,\n        shouldAddDotItems\n      );\n      newCompletionItems = dirItems\n        .filter((name) => name.startsWith(baseName))\n        .map((name) => name.slice(name.search(baseName) + baseName.length))\n        .sort();\n    }\n\n    const newIndex = isTabForward ? 0 : newCompletionItems.length - 1;\n    commandLine.autoCompleteIndex = newIndex;\n    // If here only one items we fill cmd direct, so the next tab will not cycle the one item array\n    commandLine.autoCompleteItems = newCompletionItems.length <= 1 ? [] : newCompletionItems;\n    commandLine.preCompleteCharacterPos = cursorPos;\n    commandLine.preCompleteCommand = evalCmd + restCmd;\n\n    const completion = newCompletionItems.length === 0 ? '' : newCompletionItems[newIndex];\n    vimState.currentCommandlineText = evalCmd + completion + restCmd;\n    vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length - restCmd.length;\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\nclass CommandEnterInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [['\\n'], ['<C-m>']];\n  override runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await commandLine.Run(vimState.currentCommandlineText, vimState);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandRemoveWordCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [['<C-w>'], ['<C-BS>']];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    const pos = vimState.statusBarCursorCharacterPos;\n    const cmdText = vimState.currentCommandlineText;\n    const characterAt = getWordLeftInText(cmdText, pos, WordType.Normal);\n    // Needs explicit check undefined because zero is falsy and zero is a valid character pos.\n    if (characterAt !== undefined) {\n      vimState.currentCommandlineText = cmdText\n        .substring(0, characterAt)\n        .concat(cmdText.slice(pos));\n      vimState.statusBarCursorCharacterPos = pos - (pos - characterAt);\n    }\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\nclass CommandRemoveWordInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = [['<C-w>'], ['<C-BS>']];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const searchState = globalState.searchState;\n    if (searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const pos = vimState.statusBarCursorCharacterPos;\n    const searchString = searchState.searchString;\n    const characterAt = getWordLeftInText(searchString, pos, WordType.Normal);\n    // Needs explicit check undefined because zero is falsy and zero is a valid character pos.\n    if (characterAt !== undefined) {\n      searchState.searchString = searchString\n        .substring(0, characterAt)\n        .concat(searchString.slice(pos));\n      vimState.statusBarCursorCharacterPos = pos - (pos - characterAt);\n    }\n  }\n}\n\n@RegisterAction\nclass WordLeftInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = ['<C-left>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const cmdText = vimState.currentCommandlineText;\n    vimState.statusBarCursorCharacterPos =\n      getWordLeftInText(cmdText, vimState.statusBarCursorCharacterPos, WordType.Big) ?? 0;\n  }\n}\n\n@RegisterAction\nclass WordRightInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = ['<C-right>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const cmdText = vimState.currentCommandlineText;\n    vimState.statusBarCursorCharacterPos =\n      getWordRightInText(cmdText, vimState.statusBarCursorCharacterPos, WordType.Big) ??\n      cmdText.length;\n  }\n}\n\n@RegisterAction\nclass WordLeftInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = ['<C-left>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const searchState = globalState.searchState;\n    if (searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const searchString = searchState.searchString;\n    vimState.statusBarCursorCharacterPos =\n      getWordLeftInText(searchString, vimState.statusBarCursorCharacterPos, WordType.Big) ?? 0;\n  }\n}\n\n@RegisterAction\nclass WordRightInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = ['<C-right>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const searchState = globalState.searchState;\n    if (searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const searchString = searchState.searchString;\n    vimState.statusBarCursorCharacterPos =\n      getWordRightInText(searchString, vimState.statusBarCursorCharacterPos, WordType.Big) ??\n      searchString.length;\n  }\n}\n\n@RegisterAction\n// TODO: break up\nclass CommandInsertInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [\n    ['<character>'],\n    ['<up>'],\n    ['<down>'],\n    ['<C-b>'], // Beginning\n    ['<C-e>'], // End\n    ['<C-h>'], // Backspace\n    ['<C-p>'], // Previous\n    ['<C-n>'], // Next\n    ['<C-f>'], // Find\n    ['<C-u>'], // Delete to beginning\n    ['<Home>'],\n    ['<End>'],\n    ['<Del>'],\n  ];\n  override runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n\n    // handle special keys first\n    if (key === '<BS>' || key === '<S-BS>' || key === '<C-h>') {\n      if (vimState.statusBarCursorCharacterPos === 0) {\n        await vimState.setCurrentMode(Mode.Normal);\n        return;\n      }\n\n      vimState.currentCommandlineText =\n        vimState.currentCommandlineText.slice(0, vimState.statusBarCursorCharacterPos - 1) +\n        vimState.currentCommandlineText.slice(vimState.statusBarCursorCharacterPos);\n      vimState.statusBarCursorCharacterPos = Math.max(vimState.statusBarCursorCharacterPos - 1, 0);\n    } else if (key === '<C-f>') {\n      new CommandShowCommandHistory().exec(position, vimState);\n    } else if (key === '<C-u>') {\n      vimState.currentCommandlineText = vimState.currentCommandlineText.slice(\n        vimState.statusBarCursorCharacterPos\n      );\n      vimState.statusBarCursorCharacterPos = 0;\n    } else if (key === '<Del>') {\n      vimState.currentCommandlineText =\n        vimState.currentCommandlineText.slice(0, vimState.statusBarCursorCharacterPos) +\n        vimState.currentCommandlineText.slice(vimState.statusBarCursorCharacterPos + 1);\n    } else if (key === '<Home>' || key === '<C-b>') {\n      vimState.statusBarCursorCharacterPos = 0;\n    } else if (key === '<End>' || key === '<C-e>') {\n      vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n    } else if (key === '<up>' || key === '<C-p>') {\n      commandLine.commandLineHistoryIndex -= 1;\n\n      // Clamp the history index to stay within bounds of command history length\n      commandLine.commandLineHistoryIndex = Math.max(commandLine.commandLineHistoryIndex, 0);\n\n      if (commandLine.historyEntries[commandLine.commandLineHistoryIndex] !== undefined) {\n        vimState.currentCommandlineText =\n          commandLine.historyEntries[commandLine.commandLineHistoryIndex];\n      }\n      vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n    } else if (key === '<down>' || key === '<C-n>') {\n      commandLine.commandLineHistoryIndex += 1;\n\n      // If past the first history item, allow user to enter their own new command string (not using history)\n      if (commandLine.commandLineHistoryIndex > commandLine.historyEntries.length - 1) {\n        if (commandLine.previousMode === Mode.Normal) {\n          vimState.currentCommandlineText = '';\n        } else {\n          vimState.currentCommandlineText = \"'<,'>\";\n        }\n\n        commandLine.commandLineHistoryIndex = commandLine.historyEntries.length;\n        vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n        return;\n      }\n\n      if (commandLine.historyEntries[commandLine.commandLineHistoryIndex] !== undefined) {\n        vimState.currentCommandlineText =\n          commandLine.historyEntries[commandLine.commandLineHistoryIndex];\n      }\n\n      vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n    } else {\n      const modifiedString = vimState.currentCommandlineText.split('');\n      modifiedString.splice(vimState.statusBarCursorCharacterPos, 0, key);\n      vimState.currentCommandlineText = modifiedString.join('');\n      vimState.statusBarCursorCharacterPos += key.length;\n    }\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\n// TODO: break up\nclass CommandInsertInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = [\n    ['<character>'],\n    ['<up>'],\n    ['<down>'],\n    ['<C-b>'], // Beginning\n    ['<C-e>'], // End\n    ['<C-h>'], // Backspace\n    ['<C-p>'], // Previous\n    ['<C-n>'], // Next\n    ['<C-f>'], // Find\n    ['<C-u>'], // Delete to beginning\n    ['<C-m>'], // Another way to run search\n    ['<Home>'],\n    ['<End>'],\n    ['<Del>'],\n  ];\n  override isJump = true;\n\n  override runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const searchState = globalState.searchState;\n    const key = this.keysPressed[0];\n    const prevSearchList = globalState.searchStatePrevious;\n\n    // handle special keys first\n    if (key === '<BS>' || key === '<S-BS>' || key === '<C-h>') {\n      if (searchState.searchString.length === 0) {\n        await new CommandEscInSearchMode().exec(position, vimState);\n      }\n      if (vimState.statusBarCursorCharacterPos === 0) {\n        return;\n      }\n\n      searchState.searchString =\n        searchState.searchString.slice(0, vimState.statusBarCursorCharacterPos - 1) +\n        searchState.searchString.slice(vimState.statusBarCursorCharacterPos);\n      vimState.statusBarCursorCharacterPos = Math.max(vimState.statusBarCursorCharacterPos - 1, 0);\n    } else if (key === '<C-f>') {\n      await new CommandShowSearchHistory(searchState.searchDirection).exec(position, vimState);\n    } else if (key === '<C-u>') {\n      searchState.searchString = searchState.searchString.slice(\n        vimState.statusBarCursorCharacterPos\n      );\n      vimState.statusBarCursorCharacterPos = 0;\n    } else if (key === '<Del>') {\n      searchState.searchString =\n        searchState.searchString.slice(0, vimState.statusBarCursorCharacterPos) +\n        searchState.searchString.slice(vimState.statusBarCursorCharacterPos + 1);\n    } else if (key === '<Home>' || key === '<C-b>') {\n      vimState.statusBarCursorCharacterPos = 0;\n    } else if (key === '<End>' || key === '<C-e>') {\n      vimState.statusBarCursorCharacterPos = searchState.searchString.length;\n    } else if (key === '\\n' || key === '<C-m>') {\n      await vimState.setCurrentMode(searchState.previousMode);\n\n      // Repeat the previous search if no new string is entered\n      if (searchState.searchString === '') {\n        if (prevSearchList.length > 0) {\n          searchState.searchString = prevSearchList[prevSearchList.length - 1].searchString;\n        }\n      }\n\n      vimState.statusBarCursorCharacterPos = 0;\n      Register.setReadonlyRegister('/', searchState.searchString);\n      globalState.addSearchStateToHistory(searchState);\n      globalState.hl = true;\n\n      if (searchState.getMatchRanges(vimState.editor).length === 0) {\n        StatusBar.displayError(\n          vimState,\n          VimError.fromCode(ErrorCode.PatternNotFound, searchState.searchString)\n        );\n        return;\n      }\n\n      const count = vimState.recordedState.count || 1;\n      let searchPos = vimState.cursorStopPosition;\n      let nextMatch: { pos: Position; index: number } | undefined;\n      for (let i = 0; i < count; i++) {\n        // Move cursor to next match\n        nextMatch = searchState.getNextSearchMatchPosition(vimState.editor, searchPos);\n        if (nextMatch === undefined) {\n          break;\n        }\n        searchPos = nextMatch.pos;\n      }\n      if (nextMatch === undefined) {\n        StatusBar.displayError(\n          vimState,\n          VimError.fromCode(\n            searchState.searchDirection === SearchDirection.Backward\n              ? ErrorCode.SearchHitTop\n              : ErrorCode.SearchHitBottom,\n            searchState.searchString\n          )\n        );\n        return;\n      }\n\n      vimState.cursorStopPosition = nextMatch.pos;\n\n      reportSearch(nextMatch.index, searchState.getMatchRanges(vimState.editor).length, vimState);\n\n      return;\n    } else if (key === '<up>' || key === '<C-p>') {\n      globalState.searchStateIndex -= 1;\n\n      // Clamp the history index to stay within bounds of search history length\n      globalState.searchStateIndex = Math.max(globalState.searchStateIndex, 0);\n\n      if (prevSearchList[globalState.searchStateIndex] !== undefined) {\n        searchState.searchString = prevSearchList[globalState.searchStateIndex].searchString;\n        vimState.statusBarCursorCharacterPos = searchState.searchString.length;\n      }\n    } else if (key === '<down>' || key === '<C-n>') {\n      globalState.searchStateIndex += 1;\n\n      // If past the first history item, allow user to enter their own search string (not using history)\n      if (globalState.searchStateIndex > globalState.searchStatePrevious.length - 1) {\n        searchState.searchString = '';\n        globalState.searchStateIndex = globalState.searchStatePrevious.length;\n        return;\n      }\n\n      if (prevSearchList[globalState.searchStateIndex] !== undefined) {\n        searchState.searchString = prevSearchList[globalState.searchStateIndex].searchString;\n      }\n      vimState.statusBarCursorCharacterPos = searchState.searchString.length;\n    } else {\n      const modifiedString = searchState.searchString.split('');\n      modifiedString.splice(vimState.statusBarCursorCharacterPos, 0, key);\n      searchState.searchString = modifiedString.join('');\n      vimState.statusBarCursorCharacterPos += key.length;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandEscInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n  override runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n\n    await vimState.setCurrentMode(Mode.Normal);\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\nclass CommandEscInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n  override runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const searchState = globalState.searchState;\n    if (searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    vimState.cursorStopPosition = searchState.cursorStartPosition;\n\n    const prevSearchList = globalState.searchStatePrevious;\n    globalState.searchState = prevSearchList\n      ? prevSearchList[prevSearchList.length - 1]\n      : undefined;\n\n    if (vimState.firstVisibleLineBeforeSearch !== undefined) {\n      const offset =\n        vimState.editor.visibleRanges[0].start.line - vimState.firstVisibleLineBeforeSearch;\n      scrollView(vimState, offset);\n    }\n\n    await vimState.setCurrentMode(searchState.previousMode);\n    vimState.statusBarCursorCharacterPos = 0;\n    if (searchState.searchString.length > 0) {\n      globalState.addSearchStateToHistory(searchState);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandInsertRegisterContentInCommandLine extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = ['<C-r>', '<character>'];\n  override isCompleteAction = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (!Register.isValidRegister(this.keysPressed[1])) {\n      return;\n    }\n\n    vimState.recordedState.registerName = this.keysPressed[1];\n    const register = await Register.get(vimState.recordedState.registerName, this.multicursorIndex);\n    if (register === undefined) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.NothingInRegister, vimState.recordedState.registerName)\n      );\n      return;\n    }\n\n    let text: string;\n    if (register.text instanceof Array) {\n      text = register.text.join('\\n');\n    } else if (register.text instanceof RecordedState) {\n      let keyStrokes: string[] = [];\n\n      for (const action of register.text.actionsRun) {\n        keyStrokes = keyStrokes.concat(action.keysPressed);\n      }\n\n      text = keyStrokes.join('\\n');\n    } else {\n      text = register.text;\n    }\n\n    if (register.registerMode === RegisterMode.LineWise) {\n      text += '\\n';\n    }\n\n    vimState.currentCommandlineText += text;\n    vimState.statusBarCursorCharacterPos += text.length;\n  }\n}\n\n@RegisterAction\nclass CommandInsertRegisterContentInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = ['<C-r>', '<character>'];\n  override isCompleteAction = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    if (!Register.isValidRegister(this.keysPressed[1])) {\n      return;\n    }\n\n    const register = await Register.get(this.keysPressed[1], this.multicursorIndex);\n    if (register === undefined) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.NothingInRegister, this.keysPressed[1])\n      );\n      return;\n    }\n\n    let text: string;\n    if (register.text instanceof Array) {\n      text = register.text.join('\\n');\n    } else if (register.text instanceof RecordedState) {\n      let keyStrokes: string[] = [];\n\n      for (const action of register.text.actionsRun) {\n        keyStrokes = keyStrokes.concat(action.keysPressed);\n      }\n\n      text = keyStrokes.join('\\n');\n    } else {\n      text = register.text;\n    }\n\n    if (register.registerMode === RegisterMode.LineWise) {\n      text += '\\n';\n    }\n\n    globalState.searchState.searchString += text;\n    vimState.statusBarCursorCharacterPos += text.length;\n  }\n}\n\n@RegisterAction\nclass CommandInsertWord extends BaseCommand {\n  modes = [Mode.CommandlineInProgress, Mode.SearchInProgressMode];\n  keys = ['<C-r>', '<C-w>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const word = TextEditor.getWord(vimState.document, position.getLeftIfEOL());\n\n    if (word !== undefined) {\n      if (vimState.currentMode === Mode.SearchInProgressMode) {\n        globalState.searchState.searchString += word;\n      } else {\n        vimState.currentCommandlineText += word;\n      }\n\n      vimState.statusBarCursorCharacterPos += word.length;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandNavigateInCommandlineOrSearchMode extends BaseCommand {\n  modes = [Mode.CommandlineInProgress, Mode.SearchInProgressMode];\n  keys = [['<left>'], ['<right>']];\n  override runsOnceForEveryCursor() {\n    return this.keysPressed[0] === '\\n';\n  }\n\n  private getTrimmedStatusBarText() {\n    // first regex removes the : / and | from the string\n    // second regex removes a single space from the end of the string\n    const trimmedStatusBarText = StatusBar.getText()\n      .replace(/^(?:\\/|\\:)(.*)(?:\\|)(.*)/, '$1$2')\n      .replace(/(.*) $/, '$1');\n    return trimmedStatusBarText;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    const statusBarText = this.getTrimmedStatusBarText();\n    if (key === '<right>') {\n      vimState.statusBarCursorCharacterPos = Math.min(\n        vimState.statusBarCursorCharacterPos + 1,\n        statusBarText.length\n      );\n    } else if (key === '<left>') {\n      vimState.statusBarCursorCharacterPos = Math.max(vimState.statusBarCursorCharacterPos - 1, 0);\n    }\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\nclass CommandPasteInCommandline extends BaseCommand {\n  modes = [Mode.CommandlineInProgress];\n  keys = [['<C-v>'], ['<D-v>']];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    const pos = vimState.statusBarCursorCharacterPos;\n    const cmdText = vimState.currentCommandlineText;\n    const textFromClipboard = await Clipboard.Paste();\n\n    vimState.currentCommandlineText = cmdText\n      .substring(0, pos)\n      .concat(textFromClipboard)\n      .concat(cmdText.slice(pos));\n    vimState.statusBarCursorCharacterPos += textFromClipboard.length;\n\n    commandLine.lastKeyPressed = key;\n  }\n}\n\n@RegisterAction\nclass CommandPasteInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = [['<C-v>'], ['<D-v>']];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n    const searchString = globalState.searchState.searchString;\n    const pos = vimState.statusBarCursorCharacterPos;\n    const textFromClipboard = await Clipboard.Paste();\n\n    globalState.searchState.searchString = searchString\n      .substring(0, pos)\n      .concat(textFromClipboard)\n      .concat(searchString.slice(pos));\n    vimState.statusBarCursorCharacterPos += textFromClipboard.length;\n  }\n}\n\n@RegisterAction\nclass CommandCtrlLInSearchMode extends BaseCommand {\n  modes = [Mode.SearchInProgressMode];\n  keys = ['<C-l>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.searchState === undefined) {\n      // TODO: log warning, at least\n      return;\n    }\n\n    const nextMatch = globalState.searchState.getNextSearchMatchRange(vimState.editor, position);\n    if (nextMatch) {\n      const line = vimState.document.lineAt(nextMatch.end).text;\n      if (nextMatch.end.character < line.length) {\n        globalState.searchState.searchString += line[nextMatch.end.character];\n        vimState.statusBarCursorCharacterPos++;\n      }\n    }\n  }\n}\n","// prettier-ignore\nexport const DefaultDigraphs = {\n  \"SH\": [\"^A\", 1],\n  \"SX\": [\"^B\", 2],\n  \"EX\": [\"^C\", 3],\n  \"ET\": [\"^D\", 4],\n  \"EQ\": [\"^E\", 5],\n  \"AK\": [\"^F\", 6],\n  \"BL\": [\"^G\", 7],\n  \"BS\": [\"^H\", 8],\n  \"HT\": [\"^I\", 9],\n  \"LF\": [\"^@\", 10],\n  \"NU\": [\"^@\", 10],\n  \"VT\": [\"^K\", 11],\n  \"FF\": [\"^L\", 12],\n  \"CR\": [\"^M\", 13],\n  \"SO\": [\"^N\", 14],\n  \"SI\": [\"^O\", 15],\n  \"DL\": [\"^P\", 16],\n  \"D1\": [\"^Q\", 17],\n  \"D2\": [\"^R\", 18],\n  \"D3\": [\"^S\", 19],\n  \"D4\": [\"^T\", 20],\n  \"NK\": [\"^U\", 21],\n  \"SY\": [\"^V\", 22],\n  \"EB\": [\"^W\", 23],\n  \"CN\": [\"^X\", 24],\n  \"EM\": [\"^Y\", 25],\n  \"SB\": [\"^Z\", 26],\n  \"EC\": [\"^[\", 27],\n  \"FS\": [\"^\\\\\", 28],\n  \"GS\": [\"^]\", 29],\n  \"RS\": [\"^^\", 30],\n  \"US\": [\"^_\", 31],\n  \"SP\": [\" \", 32],\n  \"Nb\": [\"#\", 35],\n  \"DO\": [\"$\", 36],\n  \"At\": [\"@\", 64],\n  \"<(\": [\"[\", 91],\n  \"//\": [\"\\\\\", 92],\n  \")>\": [\"]\", 93],\n  \"'>\": [\"^\", 94],\n  \"'!\": [\"`\", 96],\n  \"(!\": [\"{\", 123],\n  \"!!\": [\"|\", 124],\n  \"!)\": [\"}\", 125],\n  \"'?\": [\"~\", 126],\n  \"DT\": [\"^?\", 127],\n  \"PA\": [\"<80>\", 128],\n  \"HO\": [\"<81>\", 129],\n  \"BH\": [\"<82>\", 130],\n  \"NH\": [\"<83>\", 131],\n  \"IN\": [\"<84>\", 132],\n  \"NL\": [\"<85>\", 133],\n  \"SA\": [\"<86>\", 134],\n  \"ES\": [\"<87>\", 135],\n  \"HS\": [\"<88>\", 136],\n  \"HJ\": [\"<89>\", 137],\n  \"VS\": [\"<8a>\", 138],\n  \"PD\": [\"<8b>\", 139],\n  \"PU\": [\"<8c>\", 140],\n  \"RI\": [\"<8d>\", 141],\n  \"S2\": [\"<8e>\", 142],\n  \"S3\": [\"<8f>\", 143],\n  \"DC\": [\"<90>\", 144],\n  \"P1\": [\"<91>\", 145],\n  \"P2\": [\"<92>\", 146],\n  \"TS\": [\"<93>\", 147],\n  \"CC\": [\"<94>\", 148],\n  \"MW\": [\"<95>\", 149],\n  \"SG\": [\"<96>\", 150],\n  \"EG\": [\"<97>\", 151],\n  \"SS\": [\"<98>\", 152],\n  \"GC\": [\"<99>\", 153],\n  \"SC\": [\"<9a>\", 154],\n  \"CI\": [\"<9b>\", 155],\n  \"ST\": [\"<9c>\", 156],\n  \"OC\": [\"<9d>\", 157],\n  \"PM\": [\"<9e>\", 158],\n  \"AC\": [\"<9f>\", 159],\n  \"NS\": [\" \", 160],\n  \"~!\": [\"¡\", 161],\n  \"!I\": [\"¡\", 161],\n  \"Ct\": [\"¢\", 162],\n  \"c|\": [\"¢\", 162],\n  \"Pd\": [\"£\", 163],\n  \"$$\": [\"£\", 163],\n  \"Cu\": [\"¤\", 164],\n  \"ox\": [\"¤\", 164],\n  \"Ye\": [\"¥\", 165],\n  \"Y-\": [\"¥\", 165],\n  \"BB\": [\"¦\", 166],\n  \"||\": [\"¦\", 166],\n  \"SE\": [\"§\", 167],\n  \"':\": [\"¨\", 168],\n  \"Co\": [\"©\", 169],\n  \"cO\": [\"©\", 169],\n  \"-a\": [\"ª\", 170],\n  \"<<\": [\"«\", 171],\n  \"NO\": [\"¬\", 172],\n  \"-,\": [\"¬\", 172],\n  \"--\": [\"­\", 173],\n  \"Rg\": [\"®\", 174],\n  \"'m\": [\"¯\", 175],\n  \"-=\": [\"¯\", 175],\n  \"DG\": [\"°\", 176],\n  \"~o\": [\"°\", 176],\n  \"+-\": [\"±\", 177],\n  \"2S\": [\"²\", 178],\n  \"22\": [\"²\", 178],\n  \"3S\": [\"³\", 179],\n  \"33\": [\"³\", 179],\n  \"''\": [\"´\", 180],\n  \"My\": [\"µ\", 181],\n  \"PI\": [\"¶\", 182],\n  \"pp\": [\"¶\", 182],\n  \".M\": [\"·\", 183],\n  \"~.\": [\"·\", 183],\n  \"',\": [\"¸\", 184],\n  \"1S\": [\"¹\", 185],\n  \"11\": [\"¹\", 185],\n  \"-o\": [\"º\", 186],\n  \">>\": [\"»\", 187],\n  \"14\": [\"¼\", 188],\n  \"12\": [\"½\", 189],\n  \"34\": [\"¾\", 190],\n  \"?I\": [\"¿\", 191],\n  \"~?\": [\"¿\", 191],\n  \"A!\": [\"À\", 192],\n  \"A`\": [\"À\", 192],\n  \"A'\": [\"Á\", 193],\n  \"A>\": [\"Â\", 194],\n  \"A^\": [\"Â\", 194],\n  \"A?\": [\"Ã\", 195],\n  \"A~\": [\"Ã\", 195],\n  \"A:\": [\"Ä\", 196],\n  \"A\\\"\": [\"Ä\", 196],\n  \"AA\": [\"Å\", 197],\n  \"A@\": [\"Å\", 197],\n  \"AE\": [\"Æ\", 198],\n  \"C,\": [\"Ç\", 199],\n  \"E!\": [\"È\", 200],\n  \"E`\": [\"È\", 200],\n  \"E'\": [\"É\", 201],\n  \"E>\": [\"Ê\", 202],\n  \"E^\": [\"Ê\", 202],\n  \"E:\": [\"Ë\", 203],\n  \"E\\\"\": [\"Ë\", 203],\n  \"I!\": [\"Ì\", 204],\n  \"I`\": [\"Ì\", 204],\n  \"I'\": [\"Í\", 205],\n  \"I>\": [\"Î\", 206],\n  \"I^\": [\"Î\", 206],\n  \"I:\": [\"Ï\", 207],\n  \"I\\\"\": [\"Ï\", 207],\n  \"D-\": [\"Ð\", 208],\n  \"N?\": [\"Ñ\", 209],\n  \"N~\": [\"Ñ\", 209],\n  \"O!\": [\"Ò\", 210],\n  \"O`\": [\"Ò\", 210],\n  \"O'\": [\"Ó\", 211],\n  \"O>\": [\"Ô\", 212],\n  \"O^\": [\"Ô\", 212],\n  \"O?\": [\"Õ\", 213],\n  \"O~\": [\"Õ\", 213],\n  \"O:\": [\"Ö\", 214],\n  \"*X\": [\"×\", 215],\n  \"/\\\\\": [\"×\", 215],\n  \"O/\": [\"Ø\", 216],\n  \"U!\": [\"Ù\", 217],\n  \"U`\": [\"Ù\", 217],\n  \"U'\": [\"Ú\", 218],\n  \"U>\": [\"Û\", 219],\n  \"U^\": [\"Û\", 219],\n  \"U:\": [\"Ü\", 220],\n  \"Y'\": [\"Ý\", 221],\n  \"TH\": [\"Þ\", 222],\n  \"Ip\": [\"Þ\", 222],\n  \"ss\": [\"ß\", 223],\n  \"a!\": [\"à\", 224],\n  \"a`\": [\"à\", 224],\n  \"a'\": [\"á\", 225],\n  \"a>\": [\"â\", 226],\n  \"a^\": [\"â\", 226],\n  \"a?\": [\"ã\", 227],\n  \"a~\": [\"ã\", 227],\n  \"a:\": [\"ä\", 228],\n  \"a\\\"\": [\"ä\", 228],\n  \"aa\": [\"å\", 229],\n  \"a@\": [\"å\", 229],\n  \"ae\": [\"æ\", 230],\n  \"c,\": [\"ç\", 231],\n  \"e!\": [\"è\", 232],\n  \"e`\": [\"è\", 232],\n  \"e'\": [\"é\", 233],\n  \"e>\": [\"ê\", 234],\n  \"e^\": [\"ê\", 234],\n  \"e:\": [\"ë\", 235],\n  \"e\\\"\": [\"ë\", 235],\n  \"i!\": [\"ì\", 236],\n  \"i`\": [\"ì\", 236],\n  \"i'\": [\"í\", 237],\n  \"i>\": [\"î\", 238],\n  \"i^\": [\"î\", 238],\n  \"i:\": [\"ï\", 239],\n  \"d-\": [\"ð\", 240],\n  \"n?\": [\"ñ\", 241],\n  \"n~\": [\"ñ\", 241],\n  \"o!\": [\"ò\", 242],\n  \"o`\": [\"ò\", 242],\n  \"o'\": [\"ó\", 243],\n  \"o>\": [\"ô\", 244],\n  \"o^\": [\"ô\", 244],\n  \"o?\": [\"õ\", 245],\n  \"o~\": [\"õ\", 245],\n  \"o:\": [\"ö\", 246],\n  \"-:\": [\"÷\", 247],\n  \"o/\": [\"ø\", 248],\n  \"u!\": [\"ù\", 249],\n  \"u`\": [\"ù\", 249],\n  \"u'\": [\"ú\", 250],\n  \"u>\": [\"û\", 251],\n  \"u^\": [\"û\", 251],\n  \"u:\": [\"ü\", 252],\n  \"y'\": [\"ý\", 253],\n  \"th\": [\"þ\", 254],\n  \"y:\": [\"ÿ\", 255],\n  \"y\\\"\": [\"ÿ\", 255],\n  \"A-\": [\"Ā\", 256],\n  \"a-\": [\"ā\", 257],\n  \"A(\": [\"Ă\", 258],\n  \"a(\": [\"ă\", 259],\n  \"A;\": [\"Ą\", 260],\n  \"a;\": [\"ą\", 261],\n  \"C'\": [\"Ć\", 262],\n  \"c'\": [\"ć\", 263],\n  \"C>\": [\"Ĉ\", 264],\n  \"c>\": [\"ĉ\", 265],\n  \"C.\": [\"Ċ\", 266],\n  \"c.\": [\"ċ\", 267],\n  \"C<\": [\"Č\", 268],\n  \"c<\": [\"č\", 269],\n  \"D<\": [\"Ď\", 270],\n  \"d<\": [\"ď\", 271],\n  \"D/\": [\"Đ\", 272],\n  \"d/\": [\"đ\", 273],\n  \"E-\": [\"Ē\", 274],\n  \"e-\": [\"ē\", 275],\n  \"E(\": [\"Ĕ\", 276],\n  \"e(\": [\"ĕ\", 277],\n  \"E.\": [\"Ė\", 278],\n  \"e.\": [\"ė\", 279],\n  \"E;\": [\"Ę\", 280],\n  \"e;\": [\"ę\", 281],\n  \"E<\": [\"Ě\", 282],\n  \"e<\": [\"ě\", 283],\n  \"G>\": [\"Ĝ\", 284],\n  \"g>\": [\"ĝ\", 285],\n  \"G(\": [\"Ğ\", 286],\n  \"g(\": [\"ğ\", 287],\n  \"G.\": [\"Ġ\", 288],\n  \"g.\": [\"ġ\", 289],\n  \"G,\": [\"Ģ\", 290],\n  \"g,\": [\"ģ\", 291],\n  \"H>\": [\"Ĥ\", 292],\n  \"h>\": [\"ĥ\", 293],\n  \"H/\": [\"Ħ\", 294],\n  \"h/\": [\"ħ\", 295],\n  \"I?\": [\"Ĩ\", 296],\n  \"i?\": [\"ĩ\", 297],\n  \"I-\": [\"Ī\", 298],\n  \"i-\": [\"ī\", 299],\n  \"I(\": [\"Ĭ\", 300],\n  \"i(\": [\"ĭ\", 301],\n  \"I;\": [\"Į\", 302],\n  \"i;\": [\"į\", 303],\n  \"I.\": [\"İ\", 304],\n  \"i.\": [\"ı\", 305],\n  \"IJ\": [\"Ĳ\", 306],\n  \"ij\": [\"ĳ\", 307],\n  \"J>\": [\"Ĵ\", 308],\n  \"j>\": [\"ĵ\", 309],\n  \"K,\": [\"Ķ\", 310],\n  \"k,\": [\"ķ\", 311],\n  \"kk\": [\"ĸ\", 312],\n  \"L'\": [\"Ĺ\", 313],\n  \"l'\": [\"ĺ\", 314],\n  \"L,\": [\"Ļ\", 315],\n  \"l,\": [\"ļ\", 316],\n  \"L<\": [\"Ľ\", 317],\n  \"l<\": [\"ľ\", 318],\n  \"L.\": [\"Ŀ\", 319],\n  \"l.\": [\"ŀ\", 320],\n  \"L/\": [\"Ł\", 321],\n  \"l/\": [\"ł\", 322],\n  \"N'\": [\"Ń\", 323],\n  \"n'\": [\"ń\", 324],\n  \"N,\": [\"Ņ\", 325],\n  \"n,\": [\"ņ\", 326],\n  \"N<\": [\"Ň\", 327],\n  \"n<\": [\"ň\", 328],\n  \"'n\": [\"ŉ\", 329],\n  \"NG\": [\"Ŋ\", 330],\n  \"ng\": [\"ŋ\", 331],\n  \"O-\": [\"Ō\", 332],\n  \"o-\": [\"ō\", 333],\n  \"O(\": [\"Ŏ\", 334],\n  \"o(\": [\"ŏ\", 335],\n  \"O\\\"\": [\"Ő\", 336],\n  \"o\\\"\": [\"ő\", 337],\n  \"OE\": [\"Œ\", 338],\n  \"oe\": [\"œ\", 339],\n  \"R'\": [\"Ŕ\", 340],\n  \"r'\": [\"ŕ\", 341],\n  \"R,\": [\"Ŗ\", 342],\n  \"r,\": [\"ŗ\", 343],\n  \"R<\": [\"Ř\", 344],\n  \"r<\": [\"ř\", 345],\n  \"S'\": [\"Ś\", 346],\n  \"s'\": [\"ś\", 347],\n  \"S>\": [\"Ŝ\", 348],\n  \"s>\": [\"ŝ\", 349],\n  \"S,\": [\"Ş\", 350],\n  \"s,\": [\"ş\", 351],\n  \"S<\": [\"Š\", 352],\n  \"s<\": [\"š\", 353],\n  \"T,\": [\"Ţ\", 354],\n  \"t,\": [\"ţ\", 355],\n  \"T<\": [\"Ť\", 356],\n  \"t<\": [\"ť\", 357],\n  \"T/\": [\"Ŧ\", 358],\n  \"t/\": [\"ŧ\", 359],\n  \"U?\": [\"Ũ\", 360],\n  \"u?\": [\"ũ\", 361],\n  \"U-\": [\"Ū\", 362],\n  \"u-\": [\"ū\", 363],\n  \"U(\": [\"Ŭ\", 364],\n  \"u(\": [\"ŭ\", 365],\n  \"U0\": [\"Ů\", 366],\n  \"u0\": [\"ů\", 367],\n  \"U\\\"\": [\"Ű\", 368],\n  \"u\\\"\": [\"ű\", 369],\n  \"U;\": [\"Ų\", 370],\n  \"u;\": [\"ų\", 371],\n  \"W>\": [\"Ŵ\", 372],\n  \"w>\": [\"ŵ\", 373],\n  \"Y>\": [\"Ŷ\", 374],\n  \"y>\": [\"ŷ\", 375],\n  \"Y:\": [\"Ÿ\", 376],\n  \"Z'\": [\"Ź\", 377],\n  \"z'\": [\"ź\", 378],\n  \"Z.\": [\"Ż\", 379],\n  \"z.\": [\"ż\", 380],\n  \"Z<\": [\"Ž\", 381],\n  \"z<\": [\"ž\", 382],\n  \"fs\": [\"ſ\", 383],\n  \"O9\": [\"Ơ\", 416],\n  \"o9\": [\"ơ\", 417],\n  \"OI\": [\"Ƣ\", 418],\n  \"oi\": [\"ƣ\", 419],\n  \"yr\": [\"Ʀ\", 422],\n  \"U9\": [\"Ư\", 431],\n  \"u9\": [\"ư\", 432],\n  \"Z/\": [\"Ƶ\", 437],\n  \"z/\": [\"ƶ\", 438],\n  \"ED\": [\"Ʒ\", 439],\n  \"A<\": [\"Ǎ\", 461],\n  \"a<\": [\"ǎ\", 462],\n  \"I<\": [\"Ǐ\", 463],\n  \"i<\": [\"ǐ\", 464],\n  \"O<\": [\"Ǒ\", 465],\n  \"o<\": [\"ǒ\", 466],\n  \"U<\": [\"Ǔ\", 467],\n  \"u<\": [\"ǔ\", 468],\n  \"A1\": [\"Ǟ\", 478],\n  \"a1\": [\"ǟ\", 479],\n  \"A7\": [\"Ǡ\", 480],\n  \"a7\": [\"ǡ\", 481],\n  \"A3\": [\"Ǣ\", 482],\n  \"a3\": [\"ǣ\", 483],\n  \"G/\": [\"Ǥ\", 484],\n  \"g/\": [\"ǥ\", 485],\n  \"G<\": [\"Ǧ\", 486],\n  \"g<\": [\"ǧ\", 487],\n  \"K<\": [\"Ǩ\", 488],\n  \"k<\": [\"ǩ\", 489],\n  \"O;\": [\"Ǫ\", 490],\n  \"o;\": [\"ǫ\", 491],\n  \"O1\": [\"Ǭ\", 492],\n  \"o1\": [\"ǭ\", 493],\n  \"EZ\": [\"Ǯ\", 494],\n  \"ez\": [\"ǯ\", 495],\n  \"j<\": [\"ǰ\", 496],\n  \"G'\": [\"Ǵ\", 500],\n  \"g'\": [\"ǵ\", 501],\n  \";S\": [\"ʿ\", 703],\n  \"'<\": [\"ˇ\", 711],\n  \"'(\": [\"˘\", 728],\n  \"'.\": [\"˙\", 729],\n  \"'0\": [\"˚\", 730],\n  \"';\": [\"˛\", 731],\n  \"'\\\"\": [\"˝\", 733],\n  \"A%\": [\"Ά\", 902],\n  \"E%\": [\"Έ\", 904],\n  \"Y%\": [\"Ή\", 905],\n  \"I%\": [\"Ί\", 906],\n  \"O%\": [\"Ό\", 908],\n  \"U%\": [\"Ύ\", 910],\n  \"W%\": [\"Ώ\", 911],\n  \"i3\": [\"ΐ\", 912],\n  \"A*\": [\"Α\", 913],\n  \"B*\": [\"Β\", 914],\n  \"G*\": [\"Γ\", 915],\n  \"D*\": [\"Δ\", 916],\n  \"E*\": [\"Ε\", 917],\n  \"Z*\": [\"Ζ\", 918],\n  \"Y*\": [\"Η\", 919],\n  \"H*\": [\"Θ\", 920],\n  \"I*\": [\"Ι\", 921],\n  \"K*\": [\"Κ\", 922],\n  \"L*\": [\"Λ\", 923],\n  \"M*\": [\"Μ\", 924],\n  \"N*\": [\"Ν\", 925],\n  \"C*\": [\"Ξ\", 926],\n  \"O*\": [\"Ο\", 927],\n  \"P*\": [\"Π\", 928],\n  \"R*\": [\"Ρ\", 929],\n  \"S*\": [\"Σ\", 931],\n  \"T*\": [\"Τ\", 932],\n  \"U*\": [\"Υ\", 933],\n  \"F*\": [\"Φ\", 934],\n  \"X*\": [\"Χ\", 935],\n  \"Q*\": [\"Ψ\", 936],\n  \"W*\": [\"Ω\", 937],\n  \"J*\": [\"Ϊ\", 938],\n  \"V*\": [\"Ϋ\", 939],\n  \"a%\": [\"ά\", 940],\n  \"e%\": [\"έ\", 941],\n  \"y%\": [\"ή\", 942],\n  \"i%\": [\"ί\", 943],\n  \"u3\": [\"ΰ\", 944],\n  \"a*\": [\"α\", 945],\n  \"b*\": [\"β\", 946],\n  \"g*\": [\"γ\", 947],\n  \"d*\": [\"δ\", 948],\n  \"e*\": [\"ε\", 949],\n  \"z*\": [\"ζ\", 950],\n  \"y*\": [\"η\", 951],\n  \"h*\": [\"θ\", 952],\n  \"i*\": [\"ι\", 953],\n  \"k*\": [\"κ\", 954],\n  \"l*\": [\"λ\", 955],\n  \"m*\": [\"μ\", 956],\n  \"n*\": [\"ν\", 957],\n  \"c*\": [\"ξ\", 958],\n  \"o*\": [\"ο\", 959],\n  \"p*\": [\"π\", 960],\n  \"r*\": [\"ρ\", 961],\n  \"*s\": [\"ς\", 962],\n  \"s*\": [\"σ\", 963],\n  \"t*\": [\"τ\", 964],\n  \"u*\": [\"υ\", 965],\n  \"f*\": [\"φ\", 966],\n  \"x*\": [\"χ\", 967],\n  \"q*\": [\"ψ\", 968],\n  \"w*\": [\"ω\", 969],\n  \"j*\": [\"ϊ\", 970],\n  \"v*\": [\"ϋ\", 971],\n  \"o%\": [\"ό\", 972],\n  \"u%\": [\"ύ\", 973],\n  \"w%\": [\"ώ\", 974],\n  \"'G\": [\"Ϙ\", 984],\n  \",G\": [\"ϙ\", 985],\n  \"T3\": [\"Ϛ\", 986],\n  \"t3\": [\"ϛ\", 987],\n  \"M3\": [\"Ϝ\", 988],\n  \"m3\": [\"ϝ\", 989],\n  \"K3\": [\"Ϟ\", 990],\n  \"k3\": [\"ϟ\", 991],\n  \"P3\": [\"Ϡ\", 992],\n  \"p3\": [\"ϡ\", 993],\n  \"'%\": [\"ϴ\", 1012],\n  \"j3\": [\"ϵ\", 1013],\n  \"IO\": [\"Ё\", 1025],\n  \"D%\": [\"Ђ\", 1026],\n  \"G%\": [\"Ѓ\", 1027],\n  \"IE\": [\"Є\", 1028],\n  \"DS\": [\"Ѕ\", 1029],\n  \"II\": [\"І\", 1030],\n  \"YI\": [\"Ї\", 1031],\n  \"J%\": [\"Ј\", 1032],\n  \"LJ\": [\"Љ\", 1033],\n  \"NJ\": [\"Њ\", 1034],\n  \"Ts\": [\"Ћ\", 1035],\n  \"KJ\": [\"Ќ\", 1036],\n  \"V%\": [\"Ў\", 1038],\n  \"DZ\": [\"Џ\", 1039],\n  \"A=\": [\"А\", 1040],\n  \"B=\": [\"Б\", 1041],\n  \"V=\": [\"В\", 1042],\n  \"G=\": [\"Г\", 1043],\n  \"D=\": [\"Д\", 1044],\n  \"E=\": [\"Е\", 1045],\n  \"Z%\": [\"Ж\", 1046],\n  \"Z=\": [\"З\", 1047],\n  \"I=\": [\"И\", 1048],\n  \"J=\": [\"Й\", 1049],\n  \"K=\": [\"К\", 1050],\n  \"L=\": [\"Л\", 1051],\n  \"M=\": [\"М\", 1052],\n  \"N=\": [\"Н\", 1053],\n  \"O=\": [\"О\", 1054],\n  \"P=\": [\"П\", 1055],\n  \"R=\": [\"Р\", 1056],\n  \"S=\": [\"С\", 1057],\n  \"T=\": [\"Т\", 1058],\n  \"U=\": [\"У\", 1059],\n  \"F=\": [\"Ф\", 1060],\n  \"H=\": [\"Х\", 1061],\n  \"C=\": [\"Ц\", 1062],\n  \"C%\": [\"Ч\", 1063],\n  \"S%\": [\"Ш\", 1064],\n  \"Sc\": [\"Щ\", 1065],\n  \"=\\\"\": [\"Ъ\", 1066],\n  \"Y=\": [\"Ы\", 1067],\n  \"%\\\"\": [\"Ь\", 1068],\n  \"JE\": [\"Э\", 1069],\n  \"JU\": [\"Ю\", 1070],\n  \"JA\": [\"Я\", 1071],\n  \"a=\": [\"а\", 1072],\n  \"b=\": [\"б\", 1073],\n  \"v=\": [\"в\", 1074],\n  \"g=\": [\"г\", 1075],\n  \"d=\": [\"д\", 1076],\n  \"e=\": [\"е\", 1077],\n  \"z%\": [\"ж\", 1078],\n  \"z=\": [\"з\", 1079],\n  \"i=\": [\"и\", 1080],\n  \"j=\": [\"й\", 1081],\n  \"k=\": [\"к\", 1082],\n  \"l=\": [\"л\", 1083],\n  \"m=\": [\"м\", 1084],\n  \"n=\": [\"н\", 1085],\n  \"o=\": [\"о\", 1086],\n  \"p=\": [\"п\", 1087],\n  \"r=\": [\"р\", 1088],\n  \"s=\": [\"с\", 1089],\n  \"t=\": [\"т\", 1090],\n  \"u=\": [\"у\", 1091],\n  \"f=\": [\"ф\", 1092],\n  \"h=\": [\"х\", 1093],\n  \"c=\": [\"ц\", 1094],\n  \"c%\": [\"ч\", 1095],\n  \"s%\": [\"ш\", 1096],\n  \"sc\": [\"щ\", 1097],\n  \"='\": [\"ъ\", 1098],\n  \"y=\": [\"ы\", 1099],\n  \"%'\": [\"ь\", 1100],\n  \"je\": [\"э\", 1101],\n  \"ju\": [\"ю\", 1102],\n  \"ja\": [\"я\", 1103],\n  \"io\": [\"ё\", 1105],\n  \"d%\": [\"ђ\", 1106],\n  \"g%\": [\"ѓ\", 1107],\n  \"ie\": [\"є\", 1108],\n  \"ds\": [\"ѕ\", 1109],\n  \"ii\": [\"і\", 1110],\n  \"yi\": [\"ї\", 1111],\n  \"j%\": [\"ј\", 1112],\n  \"lj\": [\"љ\", 1113],\n  \"nj\": [\"њ\", 1114],\n  \"ts\": [\"ћ\", 1115],\n  \"kj\": [\"ќ\", 1116],\n  \"v%\": [\"ў\", 1118],\n  \"dz\": [\"џ\", 1119],\n  \"Y3\": [\"Ѣ\", 1122],\n  \"y3\": [\"ѣ\", 1123],\n  \"O3\": [\"Ѫ\", 1130],\n  \"o3\": [\"ѫ\", 1131],\n  \"F3\": [\"Ѳ\", 1138],\n  \"f3\": [\"ѳ\", 1139],\n  \"V3\": [\"Ѵ\", 1140],\n  \"v3\": [\"ѵ\", 1141],\n  \"C3\": [\"Ҁ\", 1152],\n  \"c3\": [\"ҁ\", 1153],\n  \"G3\": [\"Ґ\", 1168],\n  \"g3\": [\"ґ\", 1169],\n  \"A+\": [\"א\", 1488],\n  \"B+\": [\"ב\", 1489],\n  \"G+\": [\"ג\", 1490],\n  \"D+\": [\"ד\", 1491],\n  \"H+\": [\"ה\", 1492],\n  \"W+\": [\"ו\", 1493],\n  \"Z+\": [\"ז\", 1494],\n  \"X+\": [\"ח\", 1495],\n  \"Tj\": [\"ט\", 1496],\n  \"J+\": [\"י\", 1497],\n  \"K%\": [\"ך\", 1498],\n  \"K+\": [\"כ\", 1499],\n  \"L+\": [\"ל\", 1500],\n  \"M%\": [\"ם\", 1501],\n  \"M+\": [\"מ\", 1502],\n  \"N%\": [\"ן\", 1503],\n  \"N+\": [\"נ\", 1504],\n  \"S+\": [\"ס\", 1505],\n  \"E+\": [\"ע\", 1506],\n  \"P%\": [\"ף\", 1507],\n  \"P+\": [\"פ\", 1508],\n  \"Zj\": [\"ץ\", 1509],\n  \"ZJ\": [\"צ\", 1510],\n  \"Q+\": [\"ק\", 1511],\n  \"R+\": [\"ר\", 1512],\n  \"Sh\": [\"ש\", 1513],\n  \"T+\": [\"ת\", 1514],\n  \",+\": [\"،\", 1548],\n  \";+\": [\"؛\", 1563],\n  \"?+\": [\"؟\", 1567],\n  \"H'\": [\"ء\", 1569],\n  \"aM\": [\"آ\", 1570],\n  \"aH\": [\"أ\", 1571],\n  \"wH\": [\"ؤ\", 1572],\n  \"ah\": [\"إ\", 1573],\n  \"yH\": [\"ئ\", 1574],\n  \"a+\": [\"ا\", 1575],\n  \"b+\": [\"ب\", 1576],\n  \"tm\": [\"ة\", 1577],\n  \"t+\": [\"ت\", 1578],\n  \"tk\": [\"ث\", 1579],\n  \"g+\": [\"ج\", 1580],\n  \"hk\": [\"ح\", 1581],\n  \"x+\": [\"خ\", 1582],\n  \"d+\": [\"د\", 1583],\n  \"dk\": [\"ذ\", 1584],\n  \"r+\": [\"ر\", 1585],\n  \"z+\": [\"ز\", 1586],\n  \"s+\": [\"س\", 1587],\n  \"sn\": [\"ش\", 1588],\n  \"c+\": [\"ص\", 1589],\n  \"dd\": [\"ض\", 1590],\n  \"tj\": [\"ط\", 1591],\n  \"zH\": [\"ظ\", 1592],\n  \"e+\": [\"ع\", 1593],\n  \"i+\": [\"غ\", 1594],\n  \"++\": [\"ـ\", 1600],\n  \"f+\": [\"ف\", 1601],\n  \"q+\": [\"ق\", 1602],\n  \"k+\": [\"ك\", 1603],\n  \"l+\": [\"ل\", 1604],\n  \"m+\": [\"م\", 1605],\n  \"n+\": [\"ن\", 1606],\n  \"h+\": [\"ه\", 1607],\n  \"w+\": [\"و\", 1608],\n  \"j+\": [\"ى\", 1609],\n  \"y+\": [\"ي\", 1610],\n  \":+\": [\"ً\", 1611],\n  \"\\\"+\": [\"ٌ\", 1612],\n  \"=+\": [\"ٍ\", 1613],\n  \"/+\": [\"َ\", 1614],\n  \"'+\": [\"ُ\", 1615],\n  \"1+\": [\"ِ\", 1616],\n  \"3+\": [\"ّ\", 1617],\n  \"0+\": [\"ْ\", 1618],\n  \"aS\": [\"ٰ\", 1648],\n  \"p+\": [\"پ\", 1662],\n  \"v+\": [\"ڤ\", 1700],\n  \"gf\": [\"گ\", 1711],\n  \"0a\": [\"۰\", 1776],\n  \"1a\": [\"۱\", 1777],\n  \"2a\": [\"۲\", 1778],\n  \"3a\": [\"۳\", 1779],\n  \"4a\": [\"۴\", 1780],\n  \"5a\": [\"۵\", 1781],\n  \"6a\": [\"۶\", 1782],\n  \"7a\": [\"۷\", 1783],\n  \"8a\": [\"۸\", 1784],\n  \"9a\": [\"۹\", 1785],\n  \"B.\": [\"Ḃ\", 7682],\n  \"b.\": [\"ḃ\", 7683],\n  \"B_\": [\"Ḇ\", 7686],\n  \"b_\": [\"ḇ\", 7687],\n  \"D.\": [\"Ḋ\", 7690],\n  \"d.\": [\"ḋ\", 7691],\n  \"D_\": [\"Ḏ\", 7694],\n  \"d_\": [\"ḏ\", 7695],\n  \"D,\": [\"Ḑ\", 7696],\n  \"d,\": [\"ḑ\", 7697],\n  \"F.\": [\"Ḟ\", 7710],\n  \"f.\": [\"ḟ\", 7711],\n  \"G-\": [\"Ḡ\", 7712],\n  \"g-\": [\"ḡ\", 7713],\n  \"H.\": [\"Ḣ\", 7714],\n  \"h.\": [\"ḣ\", 7715],\n  \"H:\": [\"Ḧ\", 7718],\n  \"h:\": [\"ḧ\", 7719],\n  \"H,\": [\"Ḩ\", 7720],\n  \"h,\": [\"ḩ\", 7721],\n  \"K'\": [\"Ḱ\", 7728],\n  \"k'\": [\"ḱ\", 7729],\n  \"K_\": [\"Ḵ\", 7732],\n  \"k_\": [\"ḵ\", 7733],\n  \"L_\": [\"Ḻ\", 7738],\n  \"l_\": [\"ḻ\", 7739],\n  \"M'\": [\"Ḿ\", 7742],\n  \"m'\": [\"ḿ\", 7743],\n  \"M.\": [\"Ṁ\", 7744],\n  \"m.\": [\"ṁ\", 7745],\n  \"N.\": [\"Ṅ\", 7748],\n  \"n.\": [\"ṅ\", 7749],\n  \"N_\": [\"Ṉ\", 7752],\n  \"n_\": [\"ṉ\", 7753],\n  \"P'\": [\"Ṕ\", 7764],\n  \"p'\": [\"ṕ\", 7765],\n  \"P.\": [\"Ṗ\", 7766],\n  \"p.\": [\"ṗ\", 7767],\n  \"R.\": [\"Ṙ\", 7768],\n  \"r.\": [\"ṙ\", 7769],\n  \"R_\": [\"Ṟ\", 7774],\n  \"r_\": [\"ṟ\", 7775],\n  \"S.\": [\"Ṡ\", 7776],\n  \"s.\": [\"ṡ\", 7777],\n  \"T.\": [\"Ṫ\", 7786],\n  \"t.\": [\"ṫ\", 7787],\n  \"T_\": [\"Ṯ\", 7790],\n  \"t_\": [\"ṯ\", 7791],\n  \"V?\": [\"Ṽ\", 7804],\n  \"v?\": [\"ṽ\", 7805],\n  \"W!\": [\"Ẁ\", 7808],\n  \"w!\": [\"ẁ\", 7809],\n  \"W'\": [\"Ẃ\", 7810],\n  \"w'\": [\"ẃ\", 7811],\n  \"W:\": [\"Ẅ\", 7812],\n  \"w:\": [\"ẅ\", 7813],\n  \"W.\": [\"Ẇ\", 7814],\n  \"w.\": [\"ẇ\", 7815],\n  \"X.\": [\"Ẋ\", 7818],\n  \"x.\": [\"ẋ\", 7819],\n  \"X:\": [\"Ẍ\", 7820],\n  \"x:\": [\"ẍ\", 7821],\n  \"Y.\": [\"Ẏ\", 7822],\n  \"y.\": [\"ẏ\", 7823],\n  \"Z>\": [\"Ẑ\", 7824],\n  \"z>\": [\"ẑ\", 7825],\n  \"Z_\": [\"Ẕ\", 7828],\n  \"z_\": [\"ẕ\", 7829],\n  \"h_\": [\"ẖ\", 7830],\n  \"t:\": [\"ẗ\", 7831],\n  \"w0\": [\"ẘ\", 7832],\n  \"y0\": [\"ẙ\", 7833],\n  \"A2\": [\"Ả\", 7842],\n  \"a2\": [\"ả\", 7843],\n  \"E2\": [\"Ẻ\", 7866],\n  \"e2\": [\"ẻ\", 7867],\n  \"E?\": [\"Ẽ\", 7868],\n  \"e?\": [\"ẽ\", 7869],\n  \"I2\": [\"Ỉ\", 7880],\n  \"i2\": [\"ỉ\", 7881],\n  \"O2\": [\"Ỏ\", 7886],\n  \"o2\": [\"ỏ\", 7887],\n  \"U2\": [\"Ủ\", 7910],\n  \"u2\": [\"ủ\", 7911],\n  \"Y!\": [\"Ỳ\", 7922],\n  \"y!\": [\"ỳ\", 7923],\n  \"Y2\": [\"Ỷ\", 7926],\n  \"y2\": [\"ỷ\", 7927],\n  \"Y?\": [\"Ỹ\", 7928],\n  \"y?\": [\"ỹ\", 7929],\n  \";'\": [\"ἀ\", 7936],\n  \",'\": [\"ἁ\", 7937],\n  \";!\": [\"ἂ\", 7938],\n  \",!\": [\"ἃ\", 7939],\n  \"?;\": [\"ἄ\", 7940],\n  \"?,\": [\"ἅ\", 7941],\n  \"!:\": [\"ἆ\", 7942],\n  \"?:\": [\"ἇ\", 7943],\n  \"1N\": [\" \", 8194],\n  \"1M\": [\" \", 8195],\n  \"3M\": [\" \", 8196],\n  \"4M\": [\" \", 8197],\n  \"6M\": [\" \", 8198],\n  \"1T\": [\" \", 8201],\n  \"1H\": [\" \", 8202],\n  \"-1\": [\"‐\", 8208],\n  \"-N\": [\"–\", 8211],\n  \"-M\": [\"—\", 8212],\n  \"-3\": [\"―\", 8213],\n  \"!2\": [\"‖\", 8214],\n  \"=2\": [\"‗\", 8215],\n  \"'6\": [\"‘\", 8216],\n  \"'9\": [\"’\", 8217],\n  \".9\": [\"‚\", 8218],\n  \"9'\": [\"‛\", 8219],\n  \"\\\"6\": [\"“\", 8220],\n  \"\\\"9\": [\"”\", 8221],\n  \":9\": [\"„\", 8222],\n  \"9\\\"\": [\"‟\", 8223],\n  \"/-\": [\"†\", 8224],\n  \"/=\": [\"‡\", 8225],\n  \"..\": [\"‥\", 8229],\n  \",.\": [\"…\", 8230],\n  \"%0\": [\"‰\", 8240],\n  \"1'\": [\"′\", 8242],\n  \"2'\": [\"″\", 8243],\n  \"3'\": [\"‴\", 8244],\n  \"1\\\"\": [\"‵\", 8245],\n  \"2\\\"\": [\"‶\", 8246],\n  \"3\\\"\": [\"‷\", 8247],\n  \"Ca\": [\"‸\", 8248],\n  \"<1\": [\"‹\", 8249],\n  \">1\": [\"›\", 8250],\n  \":X\": [\"※\", 8251],\n  \"'-\": [\"‾\", 8254],\n  \"/f\": [\"⁄\", 8260],\n  \"0S\": [\"⁰\", 8304],\n  \"4S\": [\"⁴\", 8308],\n  \"5S\": [\"⁵\", 8309],\n  \"6S\": [\"⁶\", 8310],\n  \"7S\": [\"⁷\", 8311],\n  \"8S\": [\"⁸\", 8312],\n  \"9S\": [\"⁹\", 8313],\n  \"+S\": [\"⁺\", 8314],\n  \"-S\": [\"⁻\", 8315],\n  \"=S\": [\"⁼\", 8316],\n  \"(S\": [\"⁽\", 8317],\n  \")S\": [\"⁾\", 8318],\n  \"nS\": [\"ⁿ\", 8319],\n  \"0s\": [\"₀\", 8320],\n  \"1s\": [\"₁\", 8321],\n  \"2s\": [\"₂\", 8322],\n  \"3s\": [\"₃\", 8323],\n  \"4s\": [\"₄\", 8324],\n  \"5s\": [\"₅\", 8325],\n  \"6s\": [\"₆\", 8326],\n  \"7s\": [\"₇\", 8327],\n  \"8s\": [\"₈\", 8328],\n  \"9s\": [\"₉\", 8329],\n  \"+s\": [\"₊\", 8330],\n  \"-s\": [\"₋\", 8331],\n  \"=s\": [\"₌\", 8332],\n  \"(s\": [\"₍\", 8333],\n  \")s\": [\"₎\", 8334],\n  \"Li\": [\"₤\", 8356],\n  \"Pt\": [\"₧\", 8359],\n  \"W=\": [\"₩\", 8361],\n  \"=e\": [\"€\", 8364],\n  \"Eu\": [\"€\", 8364],\n  \"=R\": [\"₽\", 8381],\n  \"=P\": [\"₽\", 8381],\n  \"oC\": [\"℃\", 8451],\n  \"co\": [\"℅\", 8453],\n  \"oF\": [\"℉\", 8457],\n  \"N0\": [\"№\", 8470],\n  \"PO\": [\"℗\", 8471],\n  \"Rx\": [\"℞\", 8478],\n  \"SM\": [\"℠\", 8480],\n  \"TM\": [\"™\", 8482],\n  \"Om\": [\"Ω\", 8486],\n  \"AO\": [\"Å\", 8491],\n  \"13\": [\"⅓\", 8531],\n  \"23\": [\"⅔\", 8532],\n  \"15\": [\"⅕\", 8533],\n  \"25\": [\"⅖\", 8534],\n  \"35\": [\"⅗\", 8535],\n  \"45\": [\"⅘\", 8536],\n  \"16\": [\"⅙\", 8537],\n  \"56\": [\"⅚\", 8538],\n  \"18\": [\"⅛\", 8539],\n  \"38\": [\"⅜\", 8540],\n  \"58\": [\"⅝\", 8541],\n  \"78\": [\"⅞\", 8542],\n  \"1R\": [\"Ⅰ\", 8544],\n  \"2R\": [\"Ⅱ\", 8545],\n  \"3R\": [\"Ⅲ\", 8546],\n  \"4R\": [\"Ⅳ\", 8547],\n  \"5R\": [\"Ⅴ\", 8548],\n  \"6R\": [\"Ⅵ\", 8549],\n  \"7R\": [\"Ⅶ\", 8550],\n  \"8R\": [\"Ⅷ\", 8551],\n  \"9R\": [\"Ⅸ\", 8552],\n  \"aR\": [\"Ⅹ\", 8553],\n  \"bR\": [\"Ⅺ\", 8554],\n  \"cR\": [\"Ⅻ\", 8555],\n  \"1r\": [\"ⅰ\", 8560],\n  \"2r\": [\"ⅱ\", 8561],\n  \"3r\": [\"ⅲ\", 8562],\n  \"4r\": [\"ⅳ\", 8563],\n  \"5r\": [\"ⅴ\", 8564],\n  \"6r\": [\"ⅵ\", 8565],\n  \"7r\": [\"ⅶ\", 8566],\n  \"8r\": [\"ⅷ\", 8567],\n  \"9r\": [\"ⅸ\", 8568],\n  \"ar\": [\"ⅹ\", 8569],\n  \"br\": [\"ⅺ\", 8570],\n  \"cr\": [\"ⅻ\", 8571],\n  \"<-\": [\"←\", 8592],\n  \"-!\": [\"↑\", 8593],\n  \"->\": [\"→\", 8594],\n  \"-v\": [\"↓\", 8595],\n  \"<>\": [\"↔\", 8596],\n  \"UD\": [\"↕\", 8597],\n  \"<=\": [\"⇐\", 8656],\n  \"=>\": [\"⇒\", 8658],\n  \"==\": [\"⇔\", 8660],\n  \"FA\": [\"∀\", 8704],\n  \"dP\": [\"∂\", 8706],\n  \"TE\": [\"∃\", 8707],\n  \"/0\": [\"∅\", 8709],\n  \"DE\": [\"∆\", 8710],\n  \"NB\": [\"∇\", 8711],\n  \"(-\": [\"∈\", 8712],\n  \"-)\": [\"∋\", 8715],\n  \"*P\": [\"∏\", 8719],\n  \"+Z\": [\"∑\", 8721],\n  \"-2\": [\"−\", 8722],\n  \"-+\": [\"∓\", 8723],\n  \"*-\": [\"∗\", 8727],\n  \"Ob\": [\"∘\", 8728],\n  \"Sb\": [\"∙\", 8729],\n  \"RT\": [\"√\", 8730],\n  \"0(\": [\"∝\", 8733],\n  \"00\": [\"∞\", 8734],\n  \"-L\": [\"∟\", 8735],\n  \"-V\": [\"∠\", 8736],\n  \"PP\": [\"∥\", 8741],\n  \"AN\": [\"∧\", 8743],\n  \"OR\": [\"∨\", 8744],\n  \"(U\": [\"∩\", 8745],\n  \")U\": [\"∪\", 8746],\n  \"In\": [\"∫\", 8747],\n  \"DI\": [\"∬\", 8748],\n  \"Io\": [\"∮\", 8750],\n  \".:\": [\"∴\", 8756],\n  \":.\": [\"∵\", 8757],\n  \":R\": [\"∶\", 8758],\n  \"::\": [\"∷\", 8759],\n  \"?1\": [\"∼\", 8764],\n  \"CG\": [\"∾\", 8766],\n  \"?-\": [\"≃\", 8771],\n  \"?=\": [\"≅\", 8773],\n  \"?2\": [\"≈\", 8776],\n  \"=?\": [\"≌\", 8780],\n  \"HI\": [\"≓\", 8787],\n  \"!=\": [\"≠\", 8800],\n  \"=3\": [\"≡\", 8801],\n  \"=<\": [\"≤\", 8804],\n  \">=\": [\"≥\", 8805],\n  \"<*\": [\"≪\", 8810],\n  \"*>\": [\"≫\", 8811],\n  \"!<\": [\"≮\", 8814],\n  \"!>\": [\"≯\", 8815],\n  \"(C\": [\"⊂\", 8834],\n  \")C\": [\"⊃\", 8835],\n  \"(_\": [\"⊆\", 8838],\n  \")_\": [\"⊇\", 8839],\n  \"0.\": [\"⊙\", 8857],\n  \"02\": [\"⊚\", 8858],\n  \"-T\": [\"⊥\", 8869],\n  \".P\": [\"⋅\", 8901],\n  \":3\": [\"⋮\", 8942],\n  \".3\": [\"⋯\", 8943],\n  \"Eh\": [\"⌂\", 8962],\n  \"<7\": [\"⌈\", 8968],\n  \">7\": [\"⌉\", 8969],\n  \"7<\": [\"⌊\", 8970],\n  \"7>\": [\"⌋\", 8971],\n  \"NI\": [\"⌐\", 8976],\n  \"(A\": [\"⌒\", 8978],\n  \"TR\": [\"⌕\", 8981],\n  \"Iu\": [\"⌠\", 8992],\n  \"Il\": [\"⌡\", 8993],\n  \"</\": [\"〈\", 9001],\n  \"/>\": [\"〉\", 9002],\n  \"Vs\": [\"␣\", 9251],\n  \"1h\": [\"⑀\", 9280],\n  \"3h\": [\"⑁\", 9281],\n  \"2h\": [\"⑂\", 9282],\n  \"4h\": [\"⑃\", 9283],\n  \"1j\": [\"⑆\", 9286],\n  \"2j\": [\"⑇\", 9287],\n  \"3j\": [\"⑈\", 9288],\n  \"4j\": [\"⑉\", 9289],\n  \"1.\": [\"⒈\", 9352],\n  \"2.\": [\"⒉\", 9353],\n  \"3.\": [\"⒊\", 9354],\n  \"4.\": [\"⒋\", 9355],\n  \"5.\": [\"⒌\", 9356],\n  \"6.\": [\"⒍\", 9357],\n  \"7.\": [\"⒎\", 9358],\n  \"8.\": [\"⒏\", 9359],\n  \"9.\": [\"⒐\", 9360],\n  \"hh\": [\"─\", 9472],\n  \"HH\": [\"━\", 9473],\n  \"vv\": [\"│\", 9474],\n  \"VV\": [\"┃\", 9475],\n  \"3-\": [\"┄\", 9476],\n  \"3_\": [\"┅\", 9477],\n  \"3!\": [\"┆\", 9478],\n  \"3/\": [\"┇\", 9479],\n  \"4-\": [\"┈\", 9480],\n  \"4_\": [\"┉\", 9481],\n  \"4!\": [\"┊\", 9482],\n  \"4/\": [\"┋\", 9483],\n  \"dr\": [\"┌\", 9484],\n  \"dR\": [\"┍\", 9485],\n  \"Dr\": [\"┎\", 9486],\n  \"DR\": [\"┏\", 9487],\n  \"dl\": [\"┐\", 9488],\n  \"dL\": [\"┑\", 9489],\n  \"Dl\": [\"┒\", 9490],\n  \"LD\": [\"┓\", 9491],\n  \"ur\": [\"└\", 9492],\n  \"uR\": [\"┕\", 9493],\n  \"Ur\": [\"┖\", 9494],\n  \"UR\": [\"┗\", 9495],\n  \"ul\": [\"┘\", 9496],\n  \"uL\": [\"┙\", 9497],\n  \"Ul\": [\"┚\", 9498],\n  \"UL\": [\"┛\", 9499],\n  \"vr\": [\"├\", 9500],\n  \"vR\": [\"┝\", 9501],\n  \"Vr\": [\"┠\", 9504],\n  \"VR\": [\"┣\", 9507],\n  \"vl\": [\"┤\", 9508],\n  \"vL\": [\"┥\", 9509],\n  \"Vl\": [\"┨\", 9512],\n  \"VL\": [\"┫\", 9515],\n  \"dh\": [\"┬\", 9516],\n  \"dH\": [\"┯\", 9519],\n  \"Dh\": [\"┰\", 9520],\n  \"DH\": [\"┳\", 9523],\n  \"uh\": [\"┴\", 9524],\n  \"uH\": [\"┷\", 9527],\n  \"Uh\": [\"┸\", 9528],\n  \"UH\": [\"┻\", 9531],\n  \"vh\": [\"┼\", 9532],\n  \"vH\": [\"┿\", 9535],\n  \"Vh\": [\"╂\", 9538],\n  \"VH\": [\"╋\", 9547],\n  \"FD\": [\"╱\", 9585],\n  \"BD\": [\"╲\", 9586],\n  \"TB\": [\"▀\", 9600],\n  \"LB\": [\"▄\", 9604],\n  \"FB\": [\"█\", 9608],\n  \"lB\": [\"▌\", 9612],\n  \"RB\": [\"▐\", 9616],\n  \".S\": [\"░\", 9617],\n  \":S\": [\"▒\", 9618],\n  \"?S\": [\"▓\", 9619],\n  \"fS\": [\"■\", 9632],\n  \"OS\": [\"□\", 9633],\n  \"RO\": [\"▢\", 9634],\n  \"Rr\": [\"▣\", 9635],\n  \"RF\": [\"▤\", 9636],\n  \"RY\": [\"▥\", 9637],\n  \"RH\": [\"▦\", 9638],\n  \"RZ\": [\"▧\", 9639],\n  \"RK\": [\"▨\", 9640],\n  \"RX\": [\"▩\", 9641],\n  \"sB\": [\"▪\", 9642],\n  \"SR\": [\"▬\", 9644],\n  \"Or\": [\"▭\", 9645],\n  \"UT\": [\"▲\", 9650],\n  \"uT\": [\"△\", 9651],\n  \"PR\": [\"▶\", 9654],\n  \"Tr\": [\"▷\", 9655],\n  \"Dt\": [\"▼\", 9660],\n  \"dT\": [\"▽\", 9661],\n  \"PL\": [\"◀\", 9664],\n  \"Tl\": [\"◁\", 9665],\n  \"Db\": [\"◆\", 9670],\n  \"Dw\": [\"◇\", 9671],\n  \"LZ\": [\"◊\", 9674],\n  \"0m\": [\"○\", 9675],\n  \"0o\": [\"◎\", 9678],\n  \"0M\": [\"●\", 9679],\n  \"0L\": [\"◐\", 9680],\n  \"0R\": [\"◑\", 9681],\n  \"Sn\": [\"◘\", 9688],\n  \"Ic\": [\"◙\", 9689],\n  \"Fd\": [\"◢\", 9698],\n  \"Bd\": [\"◣\", 9699],\n  \"*2\": [\"★\", 9733],\n  \"*1\": [\"☆\", 9734],\n  \"<H\": [\"☜\", 9756],\n  \">H\": [\"☞\", 9758],\n  \"0u\": [\"☺\", 9786],\n  \"0U\": [\"☻\", 9787],\n  \"SU\": [\"☼\", 9788],\n  \"Fm\": [\"♀\", 9792],\n  \"Ml\": [\"♂\", 9794],\n  \"cS\": [\"♠\", 9824],\n  \"cH\": [\"♡\", 9825],\n  \"cD\": [\"♢\", 9826],\n  \"cC\": [\"♣\", 9827],\n  \"Md\": [\"♩\", 9833],\n  \"M8\": [\"♪\", 9834],\n  \"M2\": [\"♫\", 9835],\n  \"Mb\": [\"♭\", 9837],\n  \"Mx\": [\"♮\", 9838],\n  \"MX\": [\"♯\", 9839],\n  \"OK\": [\"✓\", 10003],\n  \"XX\": [\"✗\", 10007],\n  \"-X\": [\"✠\", 10016],\n  \"IS\": [\"　\", 12288],\n  \",_\": [\"、\", 12289],\n  \"._\": [\"。\", 12290],\n  \"+\\\"\": [\"〃\", 12291],\n  \"+_\": [\"〄\", 12292],\n  \"*_\": [\"々\", 12293],\n  \";_\": [\"〆\", 12294],\n  \"0_\": [\"〇\", 12295],\n  \"<+\": [\"《\", 12298],\n  \">+\": [\"》\", 12299],\n  \"<'\": [\"「\", 12300],\n  \">'\": [\"」\", 12301],\n  \"<\\\"\": [\"『\", 12302],\n  \">\\\"\": [\"』\", 12303],\n  \"(\\\"\": [\"【\", 12304],\n  \")\\\"\": [\"】\", 12305],\n  \"=T\": [\"〒\", 12306],\n  \"=_\": [\"〓\", 12307],\n  \"('\": [\"〔\", 12308],\n  \")'\": [\"〕\", 12309],\n  \"(I\": [\"〖\", 12310],\n  \")I\": [\"〗\", 12311],\n  \"-?\": [\"〜\", 12316],\n  \"A5\": [\"ぁ\", 12353],\n  \"a5\": [\"あ\", 12354],\n  \"I5\": [\"ぃ\", 12355],\n  \"i5\": [\"い\", 12356],\n  \"U5\": [\"ぅ\", 12357],\n  \"u5\": [\"う\", 12358],\n  \"E5\": [\"ぇ\", 12359],\n  \"e5\": [\"え\", 12360],\n  \"O5\": [\"ぉ\", 12361],\n  \"o5\": [\"お\", 12362],\n  \"ka\": [\"か\", 12363],\n  \"ga\": [\"が\", 12364],\n  \"ki\": [\"き\", 12365],\n  \"gi\": [\"ぎ\", 12366],\n  \"ku\": [\"く\", 12367],\n  \"gu\": [\"ぐ\", 12368],\n  \"ke\": [\"け\", 12369],\n  \"ge\": [\"げ\", 12370],\n  \"ko\": [\"こ\", 12371],\n  \"go\": [\"ご\", 12372],\n  \"sa\": [\"さ\", 12373],\n  \"za\": [\"ざ\", 12374],\n  \"si\": [\"し\", 12375],\n  \"zi\": [\"じ\", 12376],\n  \"su\": [\"す\", 12377],\n  \"zu\": [\"ず\", 12378],\n  \"se\": [\"せ\", 12379],\n  \"ze\": [\"ぜ\", 12380],\n  \"so\": [\"そ\", 12381],\n  \"zo\": [\"ぞ\", 12382],\n  \"ta\": [\"た\", 12383],\n  \"da\": [\"だ\", 12384],\n  \"ti\": [\"ち\", 12385],\n  \"di\": [\"ぢ\", 12386],\n  \"tU\": [\"っ\", 12387],\n  \"tu\": [\"つ\", 12388],\n  \"du\": [\"づ\", 12389],\n  \"te\": [\"て\", 12390],\n  \"de\": [\"で\", 12391],\n  \"to\": [\"と\", 12392],\n  \"do\": [\"ど\", 12393],\n  \"na\": [\"な\", 12394],\n  \"ni\": [\"に\", 12395],\n  \"nu\": [\"ぬ\", 12396],\n  \"ne\": [\"ね\", 12397],\n  \"no\": [\"の\", 12398],\n  \"ha\": [\"は\", 12399],\n  \"ba\": [\"ば\", 12400],\n  \"pa\": [\"ぱ\", 12401],\n  \"hi\": [\"ひ\", 12402],\n  \"bi\": [\"び\", 12403],\n  \"pi\": [\"ぴ\", 12404],\n  \"hu\": [\"ふ\", 12405],\n  \"bu\": [\"ぶ\", 12406],\n  \"pu\": [\"ぷ\", 12407],\n  \"he\": [\"へ\", 12408],\n  \"be\": [\"べ\", 12409],\n  \"pe\": [\"ぺ\", 12410],\n  \"ho\": [\"ほ\", 12411],\n  \"bo\": [\"ぼ\", 12412],\n  \"po\": [\"ぽ\", 12413],\n  \"ma\": [\"ま\", 12414],\n  \"mi\": [\"み\", 12415],\n  \"mu\": [\"む\", 12416],\n  \"me\": [\"め\", 12417],\n  \"mo\": [\"も\", 12418],\n  \"yA\": [\"ゃ\", 12419],\n  \"ya\": [\"や\", 12420],\n  \"yU\": [\"ゅ\", 12421],\n  \"yu\": [\"ゆ\", 12422],\n  \"yO\": [\"ょ\", 12423],\n  \"yo\": [\"よ\", 12424],\n  \"ra\": [\"ら\", 12425],\n  \"ri\": [\"り\", 12426],\n  \"ru\": [\"る\", 12427],\n  \"re\": [\"れ\", 12428],\n  \"ro\": [\"ろ\", 12429],\n  \"wA\": [\"ゎ\", 12430],\n  \"wa\": [\"わ\", 12431],\n  \"wi\": [\"ゐ\", 12432],\n  \"we\": [\"ゑ\", 12433],\n  \"wo\": [\"を\", 12434],\n  \"n5\": [\"ん\", 12435],\n  \"vu\": [\"ゔ\", 12436],\n  \"\\\"5\": [\"゛\", 12443],\n  \"05\": [\"゜\", 12444],\n  \"*5\": [\"ゝ\", 12445],\n  \"+5\": [\"ゞ\", 12446],\n  \"a6\": [\"ァ\", 12449],\n  \"A6\": [\"ア\", 12450],\n  \"i6\": [\"ィ\", 12451],\n  \"I6\": [\"イ\", 12452],\n  \"u6\": [\"ゥ\", 12453],\n  \"U6\": [\"ウ\", 12454],\n  \"e6\": [\"ェ\", 12455],\n  \"E6\": [\"エ\", 12456],\n  \"o6\": [\"ォ\", 12457],\n  \"O6\": [\"オ\", 12458],\n  \"Ka\": [\"カ\", 12459],\n  \"Ga\": [\"ガ\", 12460],\n  \"Ki\": [\"キ\", 12461],\n  \"Gi\": [\"ギ\", 12462],\n  \"Ku\": [\"ク\", 12463],\n  \"Gu\": [\"グ\", 12464],\n  \"Ke\": [\"ケ\", 12465],\n  \"Ge\": [\"ゲ\", 12466],\n  \"Ko\": [\"コ\", 12467],\n  \"Go\": [\"ゴ\", 12468],\n  \"Sa\": [\"サ\", 12469],\n  \"Za\": [\"ザ\", 12470],\n  \"Si\": [\"シ\", 12471],\n  \"Zi\": [\"ジ\", 12472],\n  \"Su\": [\"ス\", 12473],\n  \"Zu\": [\"ズ\", 12474],\n  \"Se\": [\"セ\", 12475],\n  \"Ze\": [\"ゼ\", 12476],\n  \"So\": [\"ソ\", 12477],\n  \"Zo\": [\"ゾ\", 12478],\n  \"Ta\": [\"タ\", 12479],\n  \"Da\": [\"ダ\", 12480],\n  \"Ti\": [\"チ\", 12481],\n  \"Di\": [\"ヂ\", 12482],\n  \"TU\": [\"ッ\", 12483],\n  \"Tu\": [\"ツ\", 12484],\n  \"Du\": [\"ヅ\", 12485],\n  \"Te\": [\"テ\", 12486],\n  \"De\": [\"デ\", 12487],\n  \"To\": [\"ト\", 12488],\n  \"Do\": [\"ド\", 12489],\n  \"Na\": [\"ナ\", 12490],\n  \"Ni\": [\"ニ\", 12491],\n  \"Nu\": [\"ヌ\", 12492],\n  \"Ne\": [\"ネ\", 12493],\n  \"No\": [\"ノ\", 12494],\n  \"Ha\": [\"ハ\", 12495],\n  \"Ba\": [\"バ\", 12496],\n  \"Pa\": [\"パ\", 12497],\n  \"Hi\": [\"ヒ\", 12498],\n  \"Bi\": [\"ビ\", 12499],\n  \"Pi\": [\"ピ\", 12500],\n  \"Hu\": [\"フ\", 12501],\n  \"Bu\": [\"ブ\", 12502],\n  \"Pu\": [\"プ\", 12503],\n  \"He\": [\"ヘ\", 12504],\n  \"Be\": [\"ベ\", 12505],\n  \"Pe\": [\"ペ\", 12506],\n  \"Ho\": [\"ホ\", 12507],\n  \"Bo\": [\"ボ\", 12508],\n  \"Po\": [\"ポ\", 12509],\n  \"Ma\": [\"マ\", 12510],\n  \"Mi\": [\"ミ\", 12511],\n  \"Mu\": [\"ム\", 12512],\n  \"Me\": [\"メ\", 12513],\n  \"Mo\": [\"モ\", 12514],\n  \"YA\": [\"ャ\", 12515],\n  \"Ya\": [\"ヤ\", 12516],\n  \"YU\": [\"ュ\", 12517],\n  \"Yu\": [\"ユ\", 12518],\n  \"YO\": [\"ョ\", 12519],\n  \"Yo\": [\"ヨ\", 12520],\n  \"Ra\": [\"ラ\", 12521],\n  \"Ri\": [\"リ\", 12522],\n  \"Ru\": [\"ル\", 12523],\n  \"Re\": [\"レ\", 12524],\n  \"Ro\": [\"ロ\", 12525],\n  \"WA\": [\"ヮ\", 12526],\n  \"Wa\": [\"ワ\", 12527],\n  \"Wi\": [\"ヰ\", 12528],\n  \"We\": [\"ヱ\", 12529],\n  \"Wo\": [\"ヲ\", 12530],\n  \"N6\": [\"ン\", 12531],\n  \"Vu\": [\"ヴ\", 12532],\n  \"KA\": [\"ヵ\", 12533],\n  \"KE\": [\"ヶ\", 12534],\n  \"Va\": [\"ヷ\", 12535],\n  \"Vi\": [\"ヸ\", 12536],\n  \"Ve\": [\"ヹ\", 12537],\n  \"Vo\": [\"ヺ\", 12538],\n  \".6\": [\"・\", 12539],\n  \"-6\": [\"ー\", 12540],\n  \"*6\": [\"ヽ\", 12541],\n  \"+6\": [\"ヾ\", 12542],\n  \"b4\": [\"ㄅ\", 12549],\n  \"p4\": [\"ㄆ\", 12550],\n  \"m4\": [\"ㄇ\", 12551],\n  \"f4\": [\"ㄈ\", 12552],\n  \"d4\": [\"ㄉ\", 12553],\n  \"t4\": [\"ㄊ\", 12554],\n  \"n4\": [\"ㄋ\", 12555],\n  \"l4\": [\"ㄌ\", 12556],\n  \"g4\": [\"ㄍ\", 12557],\n  \"k4\": [\"ㄎ\", 12558],\n  \"h4\": [\"ㄏ\", 12559],\n  \"j4\": [\"ㄐ\", 12560],\n  \"q4\": [\"ㄑ\", 12561],\n  \"x4\": [\"ㄒ\", 12562],\n  \"zh\": [\"ㄓ\", 12563],\n  \"ch\": [\"ㄔ\", 12564],\n  \"sh\": [\"ㄕ\", 12565],\n  \"r4\": [\"ㄖ\", 12566],\n  \"z4\": [\"ㄗ\", 12567],\n  \"c4\": [\"ㄘ\", 12568],\n  \"s4\": [\"ㄙ\", 12569],\n  \"a4\": [\"ㄚ\", 12570],\n  \"o4\": [\"ㄛ\", 12571],\n  \"e4\": [\"ㄜ\", 12572],\n  \"ai\": [\"ㄞ\", 12574],\n  \"ei\": [\"ㄟ\", 12575],\n  \"au\": [\"ㄠ\", 12576],\n  \"ou\": [\"ㄡ\", 12577],\n  \"an\": [\"ㄢ\", 12578],\n  \"en\": [\"ㄣ\", 12579],\n  \"aN\": [\"ㄤ\", 12580],\n  \"eN\": [\"ㄥ\", 12581],\n  \"er\": [\"ㄦ\", 12582],\n  \"i4\": [\"ㄧ\", 12583],\n  \"u4\": [\"ㄨ\", 12584],\n  \"iu\": [\"ㄩ\", 12585],\n  \"v4\": [\"ㄪ\", 12586],\n  \"nG\": [\"ㄫ\", 12587],\n  \"gn\": [\"ㄬ\", 12588],\n  \"1c\": [\"㈠\", 12832],\n  \"2c\": [\"㈡\", 12833],\n  \"3c\": [\"㈢\", 12834],\n  \"4c\": [\"㈣\", 12835],\n  \"5c\": [\"㈤\", 12836],\n  \"6c\": [\"㈥\", 12837],\n  \"7c\": [\"㈦\", 12838],\n  \"8c\": [\"㈧\", 12839],\n  \"9c\": [\"㈨\", 12840],\n  \"ff\": [\"ﬀ\", 64256],\n  \"fi\": [\"ﬁ\", 64257],\n  \"fl\": [\"ﬂ\", 64258],\n  \"ft\": [\"ﬅ\", 64261],\n  \"st\": [\"ﬆ\", 64262],\n  \"W`\": [\"Ẁ\", 7808],\n  \"w`\": [\"ẁ\", 7809],\n  \"Y`\": [\"Ỳ\", 7922],\n  \"y`\": [\"ỳ\", 7923],\n};\n","import * as vscode from 'vscode';\n\nimport { lineCompletionProvider } from '../../completion/lineCompletionProvider';\nimport { RecordedState } from '../../state/recordedState';\nimport { VimState } from '../../state/vimState';\nimport { PositionDiff } from './../../common/motion/position';\nimport { configuration } from './../../configuration/configuration';\nimport { Mode } from './../../mode/mode';\nimport { Register, RegisterMode } from './../../register/register';\nimport { TextEditor } from './../../textEditor';\nimport { RegisterAction, BaseCommand } from './../base';\nimport { ArrowsInInsertMode } from './../motion';\nimport {\n  CommandInsertAfterCursor,\n  CommandInsertAtCursor,\n  CommandInsertAtFirstCharacter,\n  CommandInsertAtLineEnd,\n  DocumentContentChangeAction,\n  CommandReplaceAtCursorFromNormalMode,\n  CommandInsertAtLineBegin,\n  CommandInsertAtLastChange,\n  CommandInsertNewLineAbove,\n  CommandInsertNewLineBefore,\n} from './actions';\nimport { DefaultDigraphs } from './digraphs';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\nimport { Position } from 'vscode';\n\n@RegisterAction\nexport class CommandEscInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vscode.commands.executeCommand('closeParameterHints');\n\n    vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getLeft()));\n    if (vimState.returnToInsertAfterCommand && position.character !== 0) {\n      vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getRight()));\n    }\n\n    // only remove leading spaces inserted by vscode.\n    // vscode only inserts them when user enter a new line,\n    // ie, o/O in Normal mode or \\n in Insert mode.\n    const lastActionBeforeEsc =\n      vimState.recordedState.actionsRun[vimState.recordedState.actionsRun.length - 2];\n    if (\n      vimState.document.languageId !== 'plaintext' &&\n      (lastActionBeforeEsc instanceof CommandInsertNewLineBefore ||\n        lastActionBeforeEsc instanceof CommandInsertNewLineAbove ||\n        (lastActionBeforeEsc instanceof DocumentContentChangeAction &&\n          lastActionBeforeEsc.keysPressed[lastActionBeforeEsc.keysPressed.length - 1] === '\\n'))\n    ) {\n      for (const cursor of vimState.cursors) {\n        if (/^\\s+$/.test(vimState.document.lineAt(cursor.stop).text)) {\n          vimState.recordedState.transformer.delete(\n            new vscode.Range(cursor.stop.getLineBegin(), cursor.stop.getLineEnd())\n          );\n        }\n      }\n    }\n    await vimState.setCurrentMode(Mode.Normal);\n\n    // If we wanted to repeat this insert (only for i and a), now is the time to do it. Insert\n    // count amount of these strings before returning back to normal mode\n    const shouldRepeatInsert =\n      vimState.recordedState.count > 1 &&\n      vimState.recordedState.actionsRun.find(\n        (a) =>\n          a instanceof CommandInsertAtCursor ||\n          a instanceof CommandInsertAfterCursor ||\n          a instanceof CommandInsertAtLineBegin ||\n          a instanceof CommandInsertAtLineEnd ||\n          a instanceof CommandInsertAtFirstCharacter ||\n          a instanceof CommandInsertAtLastChange\n      ) !== undefined;\n\n    // If this is the type to repeat insert, do this now\n    if (shouldRepeatInsert) {\n      const changeAction = vimState.recordedState.actionsRun\n        .slice()\n        .reverse()\n        .find((a) => a instanceof DocumentContentChangeAction);\n      if (changeAction instanceof DocumentContentChangeAction) {\n        // Add count amount of inserts in the case of 4i=<esc>\n        // TODO: A few actions such as <C-t> should be repeated, but are not\n        for (let i = 0; i < vimState.recordedState.count - 1; i++) {\n          // If this is the last transform, move cursor back one character\n          const positionDiff =\n            i === vimState.recordedState.count - 2\n              ? PositionDiff.offset({ character: -1 })\n              : PositionDiff.identity();\n\n          // Add a transform containing the change\n          vimState.recordedState.transformer.addTransformation(\n            changeAction.getTransformation(positionDiff)\n          );\n        }\n      }\n    }\n\n    if (vimState.historyTracker.currentContentChanges.length > 0) {\n      vimState.historyTracker.lastContentChanges = vimState.historyTracker.currentContentChanges;\n      vimState.historyTracker.currentContentChanges = [];\n    }\n\n    if (vimState.isFakeMultiCursor) {\n      vimState.cursors = [vimState.cursors[0]];\n      vimState.isFakeMultiCursor = false;\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandInsertPreviousText extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-a>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = await Register.get('.');\n    if (\n      register === undefined ||\n      !(register.text instanceof RecordedState) ||\n      !register.text.actionsRun\n    ) {\n      throw VimError.fromCode(ErrorCode.NoInsertedTextYet);\n    }\n\n    const recordedState = register.text.clone();\n\n    // The first action is entering Insert Mode, which is not necessary in this case\n    recordedState.actionsRun.shift();\n\n    // The last action is leaving Insert Mode, which is not necessary in this case\n    recordedState.actionsRun.pop();\n\n    if (recordedState.actionsRun?.[0] instanceof ArrowsInInsertMode) {\n      // Note, arrow keys are the only Insert action command that can't be repeated here as far as @rebornix knows.\n      recordedState.actionsRun.shift();\n    }\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replayRecordedState',\n      recordedState,\n    });\n  }\n}\n\n@RegisterAction\nclass CommandInsertPreviousTextAndQuit extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-shift+2>']; // <C-@>\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new CommandInsertPreviousText().exec(position, vimState);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass IncreaseIndent extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-t>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const originalText = vimState.document.lineAt(position).text;\n    const indentationWidth = TextEditor.getIndentationLevel(originalText);\n    const tabSize = configuration.tabstop || Number(vimState.editor.options.tabSize);\n    const newIndentationWidth = (Math.floor(indentationWidth / tabSize) + 1) * tabSize;\n\n    vimState.recordedState.transformer.replace(\n      new vscode.Range(position.getLineBegin(), position.with({ character: indentationWidth })),\n      TextEditor.setIndentationLevel(originalText, newIndentationWidth).match(/^(\\s*)/)![1]\n    );\n  }\n}\n\n@RegisterAction\nclass DecreaseIndent extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-d>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const originalText = vimState.document.lineAt(position).text;\n    const indentationWidth = TextEditor.getIndentationLevel(originalText);\n    const tabSize = configuration.tabstop || Number(vimState.editor.options.tabSize);\n    const newIndentationWidth = (Math.floor(indentationWidth / tabSize) - 1) * tabSize;\n\n    vimState.recordedState.transformer.replace(\n      new vscode.Range(position.getLineBegin(), position.with({ character: indentationWidth })),\n      TextEditor.setIndentationLevel(originalText, newIndentationWidth).match(/^(\\s*)/)![1]\n    );\n  }\n}\n\n// Upon thinking about it some more, I'm not really sure how to fix this\n// elegantly. Tab is just used for so many things in the VSCode editor, and all\n// of them happen to be overloaded. Sometimes tab does a tab, sometimes it does\n// an emmet completion, sometimes a snippet completion, etc.\n// @RegisterAction\n// export class CommandInsertTabInInsertMode extends BaseCommand {\n//   modes = [ModeName.Insert];\n//   keys = [\"<tab>\"];\n//   runsOnceForEveryCursor() { return false; }\n\n//   public async exec(position: Position, vimState: VimState): Promise<void> {\n//     vimState.recordedState.transformer.addTransformation({\n//       type: \"tab\"\n//     });\n//   }\n// }\n\n@RegisterAction\nexport class CommandBackspaceInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<BS>'], ['<C-h>']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.transformer.addTransformation({\n      type: 'deleteLeft',\n    });\n  }\n}\n\n@RegisterAction\nclass CommandDeleteInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<Del>'];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.transformer.addTransformation({\n      type: 'deleteRight',\n    });\n  }\n}\n\n@RegisterAction\nexport class CommandInsertInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<character>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const char = this.keysPressed[this.keysPressed.length - 1];\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertTextVSCode',\n      text: char,\n      isMultiCursor: vimState.isMultiCursor,\n    });\n  }\n\n  public override toString(): string {\n    return this.keysPressed[this.keysPressed.length - 1];\n  }\n}\n\n@RegisterAction\nclass CommandInsertDigraph extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-k>', '<any>', '<any>'];\n  override isCompleteAction = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const digraph = this.keysPressed.slice(1, 3).join('');\n    const reverseDigraph = digraph.split('').reverse().join('');\n    let charCodes = (DefaultDigraphs[digraph] ||\n      DefaultDigraphs[reverseDigraph] ||\n      configuration.digraphs[digraph] ||\n      configuration.digraphs[reverseDigraph])[1];\n    if (!(charCodes instanceof Array)) {\n      charCodes = [charCodes];\n    }\n    const char = String.fromCharCode(...charCodes);\n    vimState.recordedState.transformer.insert(position, char);\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (!super.doesActionApply(vimState, keysPressed)) {\n      return false;\n    }\n    const chars = keysPressed.slice(1, 3).join('');\n    const reverseChars = chars.split('').reverse().join('');\n    return (\n      chars in configuration.digraphs ||\n      reverseChars in configuration.digraphs ||\n      chars in DefaultDigraphs ||\n      reverseChars in DefaultDigraphs\n    );\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (!super.couldActionApply(vimState, keysPressed)) {\n      return false;\n    }\n    const chars = keysPressed.slice(1, keysPressed.length).join('');\n    const reverseChars = chars.split('').reverse().join('');\n    if (chars.length > 0) {\n      const predicate = (digraph: string) => {\n        const digraphChars = digraph.substring(0, chars.length);\n        return chars === digraphChars || reverseChars === digraphChars;\n      };\n      const match =\n        Object.keys(configuration.digraphs).find(predicate) ||\n        Object.keys(DefaultDigraphs).find(predicate);\n      return match !== undefined;\n    }\n    return true;\n  }\n}\n\n@RegisterAction\nclass CommandInsertRegisterContent extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-r>', '<character>'];\n  override isCompleteAction = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (!Register.isValidRegister(this.keysPressed[1])) {\n      return;\n    }\n\n    const register = await Register.get(this.keysPressed[1], this.multicursorIndex);\n    if (register === undefined) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.NothingInRegister, this.keysPressed[1])\n      );\n      return;\n    }\n\n    if (register.text instanceof RecordedState) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register: vimState.recordedState.registerName,\n        replay: 'keystrokes',\n      });\n\n      return;\n    }\n\n    let text = register.text;\n    if (register.registerMode === RegisterMode.LineWise && !vimState.isMultiCursor) {\n      text += '\\n';\n    }\n\n    vimState.recordedState.transformer.insert(position, text);\n  }\n}\n\n@RegisterAction\nclass CommandOneNormalCommandInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-o>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.returnToInsertAfterCommand = true;\n    vimState.actionCount = 0;\n    await new CommandEscInsertMode().exec(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CommandCtrlW extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-w>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.isAtDocumentBegin()) {\n      return;\n    }\n\n    let wordBegin: Position;\n    if (position.isInLeadingWhitespace(vimState.document)) {\n      wordBegin = position.getLineBegin();\n    } else if (position.isLineBeginning()) {\n      wordBegin = position.getUp().getLineEnd();\n    } else {\n      wordBegin = position.prevWordStart(vimState.document);\n    }\n\n    vimState.recordedState.transformer.delete(new vscode.Range(wordBegin, position));\n\n    vimState.cursorStopPosition = wordBegin;\n  }\n}\n\n@RegisterAction\nexport class InsertCharAbove extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-y>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.line === 0) {\n      return;\n    }\n\n    const charPos = position.getUp();\n    if (charPos.isLineEnd()) {\n      return;\n    }\n\n    const char = vimState.document.getText(new vscode.Range(charPos, charPos.getRight()));\n\n    vimState.recordedState.transformer.insert(position, char);\n  }\n}\n\n@RegisterAction\nexport class InsertCharBelow extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-e>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.line >= vimState.document.lineCount - 1) {\n      return;\n    }\n\n    const charPos = position.getDown();\n    if (charPos.isLineEnd()) {\n      return;\n    }\n\n    const char = vimState.document.getText(new vscode.Range(charPos, charPos.getRight()));\n\n    vimState.recordedState.transformer.insert(position, char);\n  }\n}\n\n@RegisterAction\nclass CommandCtrlUInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-u>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    let start: Position;\n    if (position.character === 0) {\n      start = position.getLeftThroughLineBreaks(true);\n    } else if (position.isInLeadingWhitespace(vimState.document)) {\n      start = position.getLineBegin();\n    } else {\n      start = position.getLineBeginRespectingIndent(vimState.document);\n    }\n\n    vimState.recordedState.transformer.delete(new vscode.Range(start, position));\n\n    vimState.cursorStopPosition = start;\n    vimState.cursorStartPosition = start;\n  }\n}\n\n@RegisterAction\nclass CommandNavigateAutocompleteDown extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<C-n>'], ['<C-j>']];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('selectNextSuggestion');\n  }\n}\n\n@RegisterAction\nclass CommandNavigateAutocompleteUp extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-p>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('selectPrevSuggestion');\n  }\n}\n\n@RegisterAction\nclass CommandCtrlVInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-v>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const clipboard = await Register.get('*', this.multicursorIndex);\n    const text = clipboard?.text instanceof RecordedState ? undefined : clipboard?.text;\n\n    if (text) {\n      vimState.recordedState.transformer.insert(vimState.cursorStopPosition, text);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandShowLineAutocomplete extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-x>', '<C-l>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await lineCompletionProvider.showLineCompletionsQuickPick(position, vimState);\n  }\n}\n\n@RegisterAction\nclass NewLineInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<C-j>'], ['<C-m>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertText',\n      text: '\\n',\n      position,\n      diff: PositionDiff.offset({ character: -1 }),\n    });\n  }\n}\n\n@RegisterAction\nclass CommandReplaceAtCursorFromInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<Insert>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new CommandReplaceAtCursorFromNormalMode().exec(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CreateUndoPoint extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-g>', 'u'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.historyTracker.addChange(true);\n    vimState.historyTracker.finishCurrentStep();\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position, TextDocument } from 'vscode';\nimport { laterOf, PositionDiff, sorted } from '../../common/motion/position';\nimport { configuration } from '../../configuration/configuration';\nimport { isVisualMode, Mode } from '../../mode/mode';\nimport { Register, RegisterMode, IRegisterContent } from '../../register/register';\nimport { RecordedState } from '../../state/recordedState';\nimport { VimState } from '../../state/vimState';\nimport { TextEditor } from '../../textEditor';\nimport { reportLinesChanged } from '../../util/statusBarTextUtils';\nimport { BaseCommand, RegisterAction } from '../base';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\nimport { Cursor } from '../../common/motion/cursor';\nimport { Transformation } from '../../transformations/transformations';\n\nfunction firstNonBlankChar(text: string): number {\n  return text.match(/\\S/)?.index ?? 0;\n}\n\nabstract class BasePutCommand extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  override canBeRepeatedWithDot = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = await Register.get(vimState.recordedState.registerName, this.multicursorIndex);\n    if (register === undefined) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.NothingInRegister, vimState.recordedState.registerName)\n      );\n      return;\n    }\n\n    const count = vimState.recordedState.count || 1;\n\n    const mode =\n      vimState.currentMode === Mode.CommandlineInProgress ? Mode.Normal : vimState.currentMode;\n    const registerMode = this.getRegisterMode(register);\n\n    const replaceRange = this.getReplaceRange(mode, vimState.cursors[0], registerMode);\n\n    let text = this.getRegisterText(mode, register, count);\n    if (this.shouldAdjustIndent(mode, registerMode)) {\n      let lineToMatch: number | undefined;\n      if (mode === Mode.VisualLine) {\n        const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n        if (end.line < vimState.document.lineCount - 1) {\n          lineToMatch = end.line + 1;\n        } else if (start.line > 0) {\n          lineToMatch = start.line - 1;\n        }\n      } else {\n        lineToMatch = position.line;\n      }\n      text = this.adjustIndent(\n        lineToMatch !== undefined ? vimState.document.lineAt(lineToMatch).text : '',\n        text\n      );\n    }\n\n    const newCursorPosition = this.getCursorPosition(\n      vimState.document,\n      mode,\n      replaceRange,\n      registerMode,\n      count,\n      text\n    );\n    for (let i = 0; i < vimState.editor.selections.length; i++) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'moveCursor',\n        diff: PositionDiff.exactPosition(newCursorPosition),\n        cursorIndex: i,\n      });\n    }\n\n    if (registerMode === RegisterMode.LineWise) {\n      text = this.adjustLinewiseRegisterText(mode, text);\n    }\n\n    for (const transformation of this.getTransformations(\n      vimState.document,\n      mode,\n      replaceRange,\n      registerMode,\n      text\n    )) {\n      vimState.recordedState.transformer.addTransformation(transformation);\n    }\n\n    if (isVisualMode(mode)) {\n      // After using \"p\" or \"P\" in Visual mode the text that was put will be selected (from Vim's \":help gv\").\n      vimState.lastVisualSelection = {\n        mode,\n        start: replaceRange.start,\n        end: replaceRange.start.advancePositionByText(text),\n      };\n\n      vimState.recordedState.registerName = configuration.useSystemClipboard ? '*' : '\"';\n      Register.put(vimState, vimState.document.getText(replaceRange), this.multicursorIndex, true);\n    }\n\n    // Report lines changed\n    let numNewlinesAfterPut = text.split('\\n').length;\n    if (registerMode === RegisterMode.LineWise) {\n      numNewlinesAfterPut--;\n    }\n    reportLinesChanged(numNewlinesAfterPut, vimState);\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n\n  private getRegisterText(mode: Mode, register: IRegisterContent, count: number): string {\n    if (register.text instanceof RecordedState) {\n      return register.text.actionsRun\n        .map((action) => action.keysPressed.join(''))\n        .join('')\n        .repeat(count);\n    }\n\n    if (register.registerMode === RegisterMode.CharacterWise) {\n      return mode === Mode.VisualLine\n        ? Array(count).fill(register.text).join('\\n')\n        : register.text.repeat(count);\n    } else if (register.registerMode === RegisterMode.LineWise || mode === Mode.VisualLine) {\n      return Array(count).fill(register.text).join('\\n');\n    } else if (register.registerMode === RegisterMode.BlockWise) {\n      return register.text\n        .split('\\n')\n        .map((line) => line.repeat(count))\n        .join('\\n');\n    } else {\n      throw new Error(`Unexpected RegisterMode ${register.registerMode}`);\n    }\n  }\n\n  private adjustIndent(lineToMatch: string, text: string): string {\n    const lines = text.split('\\n');\n\n    // Adjust indent to current line\n    const indentationWidth = TextEditor.getIndentationLevel(lineToMatch);\n    const firstLineIdentationWidth = TextEditor.getIndentationLevel(lines[0]);\n\n    return lines\n      .map((line) => {\n        const currentIdentationWidth = TextEditor.getIndentationLevel(line);\n        const newIndentationWidth =\n          currentIdentationWidth - firstLineIdentationWidth + indentationWidth;\n\n        return TextEditor.setIndentationLevel(line, newIndentationWidth);\n      })\n      .join('\\n');\n  }\n\n  private getTransformations(\n    document: TextDocument,\n    mode: Mode,\n    replaceRange: vscode.Range,\n    registerMode: RegisterMode,\n    text: string\n  ): Transformation[] {\n    // Pasting block-wise content is very different, except in VisualLine mode, where it works exactly like line-wise\n    if (registerMode === RegisterMode.BlockWise && mode !== Mode.VisualLine) {\n      const transformations: Transformation[] = [];\n      const lines = text.split('\\n');\n      const lineCount = Math.max(lines.length, replaceRange.end.line - replaceRange.start.line + 1);\n\n      // Only relevant for Visual mode\n      // If we replace 2 newlines, subsequent transformations need to take that into account (otherwise we get overlaps)\n      let deletedNewlines = 0;\n\n      for (let idx = 0; idx < lineCount; idx++) {\n        const lineText = lines[idx] ?? '';\n\n        let range: vscode.Range;\n        if (mode === Mode.VisualBlock) {\n          if (replaceRange.start.line + idx > replaceRange.end.line) {\n            const pos = replaceRange.start.with({ line: replaceRange.start.line + idx });\n            range = new vscode.Range(pos, pos);\n          } else {\n            range = new vscode.Range(\n              replaceRange.start.with({ line: replaceRange.start.line + idx }),\n              replaceRange.end.with({ line: replaceRange.start.line + idx })\n            );\n          }\n        } else {\n          if (idx > 0) {\n            const pos = replaceRange.start.with({\n              line: replaceRange.start.line + idx + deletedNewlines,\n            });\n            range = new vscode.Range(pos, pos);\n          } else {\n            range = new vscode.Range(replaceRange.start, replaceRange.end);\n            deletedNewlines = document.getText(range).split('\\n').length - 1;\n          }\n        }\n\n        const lineNumber = replaceRange.start.line + idx;\n        if (lineNumber > document.lineCount - 1) {\n          transformations.push({\n            type: 'replaceText',\n            range,\n            text: '\\n' + ' '.repeat(replaceRange.start.character) + lineText,\n          });\n        } else {\n          const spaces = Math.max(\n            replaceRange.start.character - document.lineAt(lineNumber).text.length,\n            0\n          );\n          transformations.push({\n            type: 'replaceText',\n            range,\n            text: ' '.repeat(spaces) + lineText,\n          });\n        }\n      }\n      return transformations;\n    }\n\n    if (mode === Mode.Normal || mode === Mode.Visual || mode === Mode.VisualLine) {\n      return [\n        {\n          type: 'replaceText',\n          range: replaceRange,\n          text,\n        },\n      ];\n    } else if (mode === Mode.VisualBlock) {\n      const transformations: Transformation[] = [];\n      if (registerMode === RegisterMode.CharacterWise) {\n        for (let line = replaceRange.start.line; line <= replaceRange.end.line; line++) {\n          const range = new vscode.Range(\n            new Position(line, replaceRange.start.character),\n            new Position(line, replaceRange.end.character)\n          );\n          const lineText = !text.includes('\\n') || line === replaceRange.start.line ? text : '';\n          transformations.push({\n            type: 'replaceText',\n            range,\n            text: lineText,\n          });\n        }\n      } else if (registerMode === RegisterMode.LineWise) {\n        // Weird case: first delete the block...\n        for (let line = replaceRange.start.line; line <= replaceRange.end.line; line++) {\n          const range = new vscode.Range(\n            new Position(line, replaceRange.start.character),\n            new Position(line, replaceRange.end.character)\n          );\n          transformations.push({\n            type: 'replaceText',\n            range,\n            text: '',\n          });\n        }\n\n        // ...then paste the lines before/after the block\n        const insertPos = this.putBefore()\n          ? new Position(replaceRange.start.line, 0)\n          : new Position(replaceRange.end.line, 0).getLineEnd();\n        transformations.push({\n          type: 'replaceText',\n          range: new vscode.Range(insertPos, insertPos),\n          text,\n        });\n      } else {\n        throw new Error(`Unexpected RegisterMode ${registerMode}`);\n      }\n      return transformations;\n    } else {\n      throw new Error(`Unexpected Mode ${mode}`);\n    }\n  }\n\n  protected abstract putBefore(): boolean;\n\n  protected abstract getRegisterMode(register: IRegisterContent): RegisterMode;\n\n  protected abstract getReplaceRange(\n    mode: Mode,\n    cursor: Cursor,\n    registerMode: RegisterMode\n  ): vscode.Range;\n\n  protected abstract adjustLinewiseRegisterText(mode: Mode, text: string): string;\n\n  protected abstract shouldAdjustIndent(mode: Mode, registerMode: RegisterMode): boolean;\n\n  protected abstract getCursorPosition(\n    document: TextDocument,\n    mode: Mode,\n    replaceRange: vscode.Range,\n    registerMode: RegisterMode,\n    count: number,\n    text: string\n  ): Position;\n}\n\n@RegisterAction\nclass PutCommand extends BasePutCommand {\n  keys: string[] | string[][] = ['p'];\n\n  protected putBefore(): boolean {\n    return false;\n  }\n\n  protected getRegisterMode(register: IRegisterContent): RegisterMode {\n    return register.registerMode;\n  }\n\n  protected getReplaceRange(mode: Mode, cursor: Cursor, registerMode: RegisterMode): vscode.Range {\n    if (mode === Mode.Normal) {\n      let pos: Position;\n      if (registerMode === RegisterMode.CharacterWise || registerMode === RegisterMode.BlockWise) {\n        pos = cursor.stop.getRight();\n      } else if (registerMode === RegisterMode.LineWise) {\n        pos = cursor.stop.getLineEnd();\n      } else {\n        throw new Error(`Unexpected RegisterMode ${registerMode}`);\n      }\n      return new vscode.Range(pos, pos);\n    } else if (mode === Mode.Visual) {\n      const [start, end] = sorted(cursor.start, cursor.stop);\n      return new vscode.Range(start, end.getRight());\n    } else if (mode === Mode.VisualLine) {\n      const [start, end] = sorted(cursor.start, cursor.stop);\n      return new vscode.Range(start.getLineBegin(), end.getLineEnd());\n    } else {\n      const [start, end] = sorted(cursor.start, cursor.stop);\n      return new vscode.Range(start, end.getRight());\n    }\n  }\n\n  protected adjustLinewiseRegisterText(mode: Mode, text: string): string {\n    if (mode === Mode.Normal || mode === Mode.VisualBlock) {\n      return '\\n' + text;\n    } else if (mode === Mode.Visual) {\n      return '\\n' + text + '\\n';\n    } else {\n      return text;\n    }\n  }\n\n  protected shouldAdjustIndent(mode: Mode, registerMode: RegisterMode): boolean {\n    return false;\n  }\n\n  protected getCursorPosition(\n    document: TextDocument,\n    mode: Mode,\n    replaceRange: vscode.Range,\n    registerMode: RegisterMode,\n    count: number,\n    text: string\n  ): Position {\n    const rangeStart = replaceRange.start;\n    if (mode === Mode.Normal || mode === Mode.Visual) {\n      if (registerMode === RegisterMode.CharacterWise) {\n        return text.includes('\\n') ? rangeStart : rangeStart.advancePositionByText(text).getLeft();\n      } else if (registerMode === RegisterMode.LineWise) {\n        return new Position(rangeStart.line + 1, firstNonBlankChar(text));\n      } else if (registerMode === RegisterMode.BlockWise) {\n        return rangeStart;\n      } else {\n        throw new Error(`Unexpected RegisterMode ${registerMode}`);\n      }\n    } else if (mode === Mode.VisualLine) {\n      return rangeStart.with({ character: firstNonBlankChar(text) });\n    } else if (mode === Mode.VisualBlock) {\n      if (registerMode === RegisterMode.LineWise) {\n        return new Position(replaceRange.end.line + 1, firstNonBlankChar(text));\n      } else if (registerMode === RegisterMode.BlockWise) {\n        return rangeStart;\n      } else {\n        return rangeStart.with({ character: rangeStart.character + text.length - 1 });\n      }\n    } else {\n      throw new Error(`Unexpected Mode ${mode}`);\n    }\n  }\n}\n\n@RegisterAction\nclass PutBeforeCommand extends PutCommand {\n  override keys: string[] | string[][] = ['P'];\n\n  protected override putBefore(): boolean {\n    return true;\n  }\n\n  protected override adjustLinewiseRegisterText(mode: Mode, text: string): string {\n    if (mode === Mode.Normal || mode === Mode.VisualBlock) {\n      return text + '\\n';\n    }\n\n    return super.adjustLinewiseRegisterText(mode, text);\n  }\n\n  protected override getReplaceRange(\n    mode: Mode,\n    cursor: Cursor,\n    registerMode: RegisterMode\n  ): vscode.Range {\n    if (mode === Mode.Normal) {\n      if (registerMode === RegisterMode.CharacterWise || registerMode === RegisterMode.BlockWise) {\n        const pos = cursor.stop;\n        return new vscode.Range(pos, pos);\n      } else if (registerMode === RegisterMode.LineWise) {\n        const pos = cursor.stop.getLineBegin();\n        return new vscode.Range(pos, pos);\n      }\n    }\n\n    return super.getReplaceRange(mode, cursor, registerMode);\n  }\n\n  protected override getCursorPosition(\n    document: TextDocument,\n    mode: Mode,\n    replaceRange: vscode.Range,\n    registerMode: RegisterMode,\n    count: number,\n    text: string\n  ): Position {\n    const rangeStart = replaceRange.start;\n    if (mode === Mode.Normal || mode === Mode.VisualBlock) {\n      if (registerMode === RegisterMode.LineWise) {\n        return rangeStart.with({ character: firstNonBlankChar(text) });\n      }\n    }\n\n    return super.getCursorPosition(document, mode, replaceRange, registerMode, count, text);\n  }\n}\n\nfunction PlaceCursorAfterText<TBase extends new (...args: any[]) => PutCommand>(Base: TBase) {\n  return class CursorAfterText extends Base {\n    protected override getCursorPosition(\n      document: TextDocument,\n      mode: Mode,\n      replaceRange: vscode.Range,\n      registerMode: RegisterMode,\n      count: number,\n      text: string\n    ): Position {\n      const rangeStart = replaceRange.start;\n      if (mode === Mode.Normal || mode === Mode.Visual) {\n        if (registerMode === RegisterMode.CharacterWise) {\n          if (text.includes('\\n')) {\n            // Weird case: if there's a newline, the cursor goes to the same place, regardless of [count]\n            // HACK: We're undoing the repeat() here - definitely a bit janky\n            text = text.slice(0, text.length / count);\n          }\n          return rangeStart.advancePositionByText(text);\n        } else if (registerMode === RegisterMode.LineWise) {\n          let line = rangeStart.line + text.split('\\n').length;\n          if (\n            mode === Mode.Visual ||\n            (!this.putBefore() && rangeStart.line < document.lineCount - 1)\n          ) {\n            line++;\n          }\n          return new Position(line, 0);\n        } else if (registerMode === RegisterMode.BlockWise) {\n          const lines = text.split('\\n');\n          return new Position(\n            rangeStart.line + lines.length - 1,\n            rangeStart.character +\n              lines[0].length +\n              (this.putBefore() && mode === Mode.Normal ? 1 : 0)\n          );\n        }\n      } else if (mode === Mode.VisualLine) {\n        return new Position(rangeStart.line + text.split('\\n').length, 0);\n      } else if (mode === Mode.VisualBlock) {\n        const lines = text.split('\\n');\n        if (registerMode === RegisterMode.LineWise) {\n          if (this.putBefore()) {\n            return new Position(rangeStart.line + lines.length, 0);\n          } else {\n            return new Position(replaceRange.end.line + lines.length + 1, 0);\n          }\n        } else if (registerMode === RegisterMode.BlockWise) {\n          return new Position(\n            replaceRange.start.line + lines.length - 1,\n            replaceRange.start.character + lines[lines.length - 1].length\n          );\n        } else {\n          return rangeStart.with({ character: rangeStart.character + text.length });\n        }\n      }\n\n      return super.getCursorPosition(document, mode, replaceRange, registerMode, count, text);\n    }\n  };\n}\n\n@RegisterAction\n@PlaceCursorAfterText\nclass GPutCommand extends PutCommand {\n  override keys = ['g', 'p'];\n}\n\n@RegisterAction\n@PlaceCursorAfterText\nclass GPutBeforeCommand extends PutBeforeCommand {\n  override keys = ['g', 'P'];\n}\n\nfunction AdjustIndent<TBase extends new (...args: any[]) => PutCommand>(Base: TBase) {\n  return class AdjustedIndent extends Base {\n    protected override shouldAdjustIndent(mode: Mode, registerMode: RegisterMode): boolean {\n      return (\n        (mode === Mode.Normal || mode === Mode.VisualLine) && registerMode === RegisterMode.LineWise\n      );\n    }\n  };\n}\n\n@RegisterAction\n@AdjustIndent\nclass PutWithIndentCommand extends PutCommand {\n  override keys = [']', 'p'];\n}\n\n@RegisterAction\n@AdjustIndent\nclass PutBeforeWithIndentCommand extends PutBeforeCommand {\n  override keys = [\n    ['[', 'P'],\n    [']', 'P'],\n    ['[', 'p'],\n  ];\n}\n\nfunction ExCommand<TBase extends new (...args: any[]) => PutCommand>(Base: TBase) {\n  return class Ex extends Base {\n    private insertLine?: number;\n\n    public setInsertionLine(insertLine: number) {\n      this.insertLine = insertLine;\n    }\n\n    protected override getRegisterMode(register: IRegisterContent): RegisterMode {\n      return RegisterMode.LineWise;\n    }\n\n    protected override getReplaceRange(\n      mode: Mode,\n      cursor: Cursor,\n      registerMode: RegisterMode\n    ): vscode.Range {\n      const line = this.insertLine ?? laterOf(cursor.start, cursor.stop).line;\n      const pos = this.putBefore() ? new Position(line, 0) : new Position(line, 0).getLineEnd();\n      return new vscode.Range(pos, pos);\n    }\n\n    protected override getCursorPosition(\n      document: TextDocument,\n      mode: Mode,\n      replaceRange: vscode.Range,\n      registerMode: RegisterMode,\n      count: number,\n      text: string\n    ): Position {\n      const lines = text.split('\\n');\n      return new Position(\n        replaceRange.start.line + lines.length - (this.putBefore() ? 1 : 0),\n        firstNonBlankChar(lines[lines.length - 1])\n      );\n    }\n  };\n}\n\nexport const PutFromCmdLine = ExCommand(PutCommand);\nexport const PutBeforeFromCmdLine = ExCommand(PutBeforeCommand);\n","import { Position, Range } from 'vscode';\nimport { PositionDiff } from '../../common/motion/position';\nimport { Mode } from '../../mode/mode';\nimport { ReplaceState } from '../../state/replaceState';\nimport { VimState } from '../../state/vimState';\nimport { RegisterAction, BaseCommand } from '../base';\n\n@RegisterAction\nclass ExitReplaceMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const replaceState = vimState.replaceState!;\n\n    // `3Rabc` results in 'abc' replacing the next characters 2 more times\n    if (replaceState.timesToRepeat > 1) {\n      const newText = replaceState.newChars.join('').repeat(replaceState.timesToRepeat - 1);\n      vimState.recordedState.transformer.replace(\n        new Range(position, position.getRight(newText.length)),\n        newText\n      );\n    } else {\n      vimState.cursorStopPosition = vimState.cursorStopPosition.getLeft();\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ReplaceModeToInsertMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = ['<Insert>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n}\n\n@RegisterAction\nclass BackspaceInReplaceMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = [['<BS>'], ['<S-BS>'], ['<C-BS>'], ['<C-h>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const replaceState = vimState.replaceState!;\n    if (position.isBeforeOrEqual(replaceState.replaceCursorStartPosition)) {\n      // If you backspace before the beginning of where you started to replace, just move the cursor back.\n      const newPosition = position.getLeftThroughLineBreaks();\n\n      if (newPosition.line < replaceState.replaceCursorStartPosition.line) {\n        vimState.replaceState = new ReplaceState(vimState, newPosition);\n      } else {\n        replaceState.replaceCursorStartPosition = newPosition;\n      }\n\n      vimState.cursorStopPosition = newPosition;\n      vimState.cursorStartPosition = newPosition;\n    } else if (\n      position.line > replaceState.replaceCursorStartPosition.line ||\n      position.character > replaceState.originalChars.length\n    ) {\n      // We've gone beyond the originally existing text; just backspace.\n      // TODO: should this use a 'deleteLeft' transformation?\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new Range(position.getLeftThroughLineBreaks(), position),\n      });\n      replaceState.newChars.pop();\n    } else {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: replaceState.originalChars[position.character - 1],\n        range: new Range(position.getLeft(), position),\n        diff: PositionDiff.offset({ character: -1 }),\n      });\n      replaceState.newChars.pop();\n    }\n  }\n}\n\n@RegisterAction\nclass ReplaceInReplaceMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = ['<character>'];\n  override canBeRepeatedWithDot = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const char = this.keysPressed[0];\n    const replaceState = vimState.replaceState!;\n    const isNewLineOrTab = char === '\\n' || char === '<tab>';\n\n    if (!position.isLineEnd() && !isNewLineOrTab) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: char,\n        range: new Range(position, position.getRight()),\n        diff: PositionDiff.offset({ character: 1 }),\n      });\n    } else if (char === '<tab>') {\n      vimState.recordedState.transformer.delete(new Range(position, position.getRight()));\n      vimState.recordedState.transformer.addTransformation({\n        type: 'tab',\n        cursorIndex: this.multicursorIndex,\n      });\n    } else {\n      vimState.recordedState.transformer.insert(position, char);\n    }\n\n    replaceState.newChars.push(char);\n  }\n}\n\n@RegisterAction\nclass CreateUndoPoint extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = ['<C-g>', 'u'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.historyTracker.addChange(true);\n    vimState.historyTracker.finishCurrentStep();\n  }\n}\n","import * as _ from 'lodash';\nimport { Position, Selection } from 'vscode';\nimport { sorted } from '../../common/motion/position';\nimport { configuration } from '../../configuration/configuration';\nimport { VimError, ErrorCode } from '../../error';\nimport { Mode } from '../../mode/mode';\nimport { Register } from '../../register/register';\nimport { globalState } from '../../state/globalState';\nimport { SearchDirection, SearchState } from '../../state/searchState';\nimport { VimState } from '../../state/vimState';\nimport { StatusBar } from '../../statusBar';\nimport { TextEditor } from '../../textEditor';\nimport { TextObject } from '../../textobject/textobject';\nimport { reportSearch } from '../../util/statusBarTextUtils';\nimport { RegisterAction, BaseCommand } from '../base';\nimport { failedMovement, IMovement } from '../baseMotion';\n\n/**\n * Search for the word under the cursor; used by [g]* and [g]#\n */\nasync function searchCurrentWord(\n  position: Position,\n  vimState: VimState,\n  direction: SearchDirection,\n  isExact: boolean\n): Promise<void> {\n  let currentWord = TextEditor.getWord(vimState.document, position);\n\n  if (currentWord) {\n    if (/\\W/.test(currentWord[0]) || /\\W/.test(currentWord[currentWord.length - 1])) {\n      // TODO: this kind of sucks. JS regex does not consider the boundary between a special\n      // character and whitespace to be a \"word boundary\", so we can't easily do an exact search.\n      isExact = false;\n    }\n\n    if (isExact) {\n      currentWord = _.escapeRegExp(currentWord);\n    }\n    // If the search is going left then use `getWordLeft()` on position to start\n    // at the beginning of the word. This ensures that any matches happen\n    // outside of the currently selected word.\n    const searchStartCursorPosition =\n      direction === SearchDirection.Backward\n        ? vimState.cursorStopPosition.prevWordStart(vimState.document, { inclusive: true })\n        : vimState.cursorStopPosition;\n\n    await createSearchStateAndMoveToMatch({\n      needle: currentWord,\n      vimState,\n      direction,\n      isExact,\n      searchStartCursorPosition,\n    });\n  } else {\n    StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NoStringUnderCursor));\n  }\n}\n\n/**\n * Search for the word under the cursor; used by [g]* and [g]# in visual mode when `visualstar` is enabled\n */\nasync function searchCurrentSelection(vimState: VimState, direction: SearchDirection) {\n  const currentSelection = vimState.document.getText(vimState.editor.selection);\n\n  // Go back to Normal mode, otherwise the selection grows to the next match.\n  await vimState.setCurrentMode(Mode.Normal);\n\n  const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n\n  // Ensure that any matches happen outside of the currently selected word.\n  const searchStartCursorPosition =\n    direction === SearchDirection.Backward ? start.getLeft() : end.getRight();\n\n  await createSearchStateAndMoveToMatch({\n    needle: currentSelection,\n    vimState,\n    direction,\n    isExact: false,\n    searchStartCursorPosition,\n  });\n}\n\n/**\n * Used by [g]* and [g]#\n */\nasync function createSearchStateAndMoveToMatch(args: {\n  needle?: string | undefined;\n  vimState: VimState;\n  direction: SearchDirection;\n  isExact: boolean;\n  searchStartCursorPosition: Position;\n}): Promise<void> {\n  const { needle, vimState, isExact } = args;\n\n  if (needle === undefined || needle.length === 0) {\n    return;\n  }\n\n  const searchString = isExact ? `\\\\b${needle}\\\\b` : needle;\n\n  // Start a search for the given term.\n  globalState.searchState = new SearchState(\n    args.direction,\n    vimState.cursorStopPosition,\n    searchString,\n    { isRegex: isExact, ignoreSmartcase: true },\n    vimState.currentMode\n  );\n  Register.setReadonlyRegister('/', globalState.searchState.searchString);\n  globalState.addSearchStateToHistory(globalState.searchState);\n\n  // Turn one of the highlighting flags back on (turned off with :nohl)\n  globalState.hl = true;\n\n  const nextMatch = globalState.searchState.getNextSearchMatchPosition(\n    vimState.editor,\n    args.searchStartCursorPosition\n  );\n  if (nextMatch) {\n    vimState.cursorStopPosition = nextMatch.pos;\n\n    reportSearch(\n      nextMatch.index,\n      globalState.searchState.getMatchRanges(vimState.editor).length,\n      vimState\n    );\n  } else {\n    StatusBar.displayError(\n      vimState,\n      VimError.fromCode(\n        args.direction === SearchDirection.Forward\n          ? ErrorCode.SearchHitBottom\n          : ErrorCode.SearchHitTop,\n        globalState.searchState.searchString\n      )\n    );\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordExactForward extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['*'];\n  override isMotion = true;\n  override runsOnceForEachCountPrefix = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await searchCurrentWord(position, vimState, SearchDirection.Forward, true);\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordForward extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['g', '*'];\n  override isMotion = true;\n  override runsOnceForEachCountPrefix = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await searchCurrentWord(position, vimState, SearchDirection.Forward, false);\n  }\n}\n\n@RegisterAction\nclass CommandSearchVisualForward extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['*'];\n  override isMotion = true;\n  override runsOnceForEachCountPrefix = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (configuration.visualstar) {\n      await searchCurrentSelection(vimState, SearchDirection.Forward);\n    } else {\n      await searchCurrentWord(position, vimState, SearchDirection.Forward, true);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordExactBackward extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['#'];\n  override isMotion = true;\n  override runsOnceForEachCountPrefix = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await searchCurrentWord(position, vimState, SearchDirection.Backward, true);\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordBackward extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['g', '#'];\n  override isMotion = true;\n  override runsOnceForEachCountPrefix = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await searchCurrentWord(position, vimState, SearchDirection.Backward, false);\n  }\n}\n\n@RegisterAction\nclass CommandSearchVisualBackward extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['#'];\n  override isMotion = true;\n  override runsOnceForEachCountPrefix = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (configuration.visualstar) {\n      await searchCurrentSelection(vimState, SearchDirection.Backward);\n    } else {\n      await searchCurrentWord(position, vimState, SearchDirection.Backward, true);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandSearchForwards extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['/'];\n  override isMotion = true;\n  override isJump = true;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    globalState.searchState = new SearchState(\n      SearchDirection.Forward,\n      vimState.cursorStopPosition,\n      '',\n      { isRegex: true },\n      vimState.currentMode\n    );\n    await vimState.setCurrentMode(Mode.SearchInProgressMode);\n\n    // Reset search history index\n    globalState.searchStateIndex = globalState.searchStatePrevious.length;\n  }\n}\n\n@RegisterAction\nclass CommandSearchBackwards extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['?'];\n  override isMotion = true;\n  override isJump = true;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    globalState.searchState = new SearchState(\n      SearchDirection.Backward,\n      vimState.cursorStopPosition,\n      '',\n      { isRegex: true },\n      vimState.currentMode\n    );\n    await vimState.setCurrentMode(Mode.SearchInProgressMode);\n\n    // Reset search history index\n    globalState.searchStateIndex = globalState.searchStatePrevious.length;\n  }\n}\n\nabstract class SearchObject extends TextObject {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  protected abstract readonly direction: SearchDirection;\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const searchState = globalState.searchState;\n    if (!searchState || searchState.searchString === '') {\n      return failedMovement(vimState);\n    }\n\n    const newSearchState = new SearchState(\n      this.direction,\n      vimState.cursorStopPosition,\n      searchState.searchString,\n      { isRegex: true },\n      vimState.currentMode\n    );\n\n    let result:\n      | {\n          start: Position;\n          end: Position;\n          index: number;\n        }\n      | undefined;\n\n    // At first, try to search for current word, and stop searching if matched.\n    // Try to search for the next word if not matched or\n    // if the cursor is at the end of a match string in visual-mode.\n    result = newSearchState.getSearchMatchRangeOf(vimState.editor, vimState.cursorStopPosition);\n    if (\n      result &&\n      vimState.currentMode === Mode.Visual &&\n      vimState.cursorStopPosition.isEqual(result.end.getLeftThroughLineBreaks())\n    ) {\n      result = undefined;\n    }\n\n    if (result === undefined) {\n      // Try to search for the next word\n      result = newSearchState.getNextSearchMatchRange(vimState.editor, vimState.cursorStopPosition);\n      if (result === undefined) {\n        return failedMovement(vimState);\n      }\n    }\n\n    reportSearch(result.index, searchState.getMatchRanges(vimState.editor).length, vimState);\n\n    let [start, stop] = [\n      vimState.currentMode === Mode.Normal ? result.start : vimState.cursorStopPosition,\n      result.end.getLeftThroughLineBreaks(),\n    ];\n\n    if (vimState.recordedState.operator) {\n      stop = stop.getLeft();\n    }\n\n    // Move the cursor, this is a bit hacky...\n    vimState.cursorStartPosition = start;\n    vimState.cursorStopPosition = stop;\n    vimState.editor.selection = new Selection(start, stop);\n\n    await vimState.setCurrentMode(Mode.Visual);\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nclass SearchObjectForward extends SearchObject {\n  keys = ['g', 'n'];\n  direction = SearchDirection.Forward;\n}\n\n@RegisterAction\nclass SearchObjectBackward extends SearchObject {\n  keys = ['g', 'N'];\n  direction = SearchDirection.Backward;\n}\n","import './base';\nimport './operator';\nimport './motion';\nimport '../textobject/textobject';\n\n// commands\nimport './commands/insert';\nimport './commands/replace';\nimport './commands/actions';\nimport './commands/commandLine';\nimport './commands/search';\nimport './commands/put';\nimport './commands/digraphs';\n","import { RegisterAction } from '../../base';\nimport { VimState } from '../../../state/vimState';\nimport { BaseMovement, failedMovement, IMovement } from '../../baseMotion';\nimport { Position, TextDocument } from 'vscode';\n\ntype Type = 'function' | 'class';\ntype Edge = 'start' | 'end';\ntype Direction = 'next' | 'prev';\n\ninterface LineInfo {\n  line: number;\n  indentation: number;\n  text: string;\n}\n\ninterface StructureElement {\n  type: Type;\n  start: Position;\n  end: Position;\n}\n\n// Older browsers don't support lookbehind - in this case, use an inferior regex rather than crashing\nlet supportsLookbehind = true;\ntry {\n  // tslint:disable-next-line\n  new RegExp('(?<=x)');\n} catch {\n  supportsLookbehind = false;\n}\n\n/*\n * Utility class used to parse the lines in the document and\n * determine class and function boundaries\n *\n * The class keeps track of two positions: the ORIGINAL and the CURRENT\n * using their relative locations to make decisions.\n */\nexport class PythonDocument {\n  _document: TextDocument;\n  structure: StructureElement[];\n\n  static readonly reOnlyWhitespace = /\\S/;\n  static readonly reLastNonWhiteSpaceCharacter = supportsLookbehind\n    ? new RegExp('(?<=\\\\S)\\\\s*$')\n    : /(\\S)\\s*$/;\n  static readonly reDefOrClass = /^\\s*(def|class) /;\n\n  constructor(document: TextDocument) {\n    this._document = document;\n    const parsed = PythonDocument._parseLines(document);\n    this.structure = PythonDocument._parseStructure(parsed);\n  }\n\n  /*\n   * Generator of the lines of text in the document\n   */\n  static *lines(document: TextDocument): Generator<string> {\n    for (let index = 0; index < document.lineCount; index++) {\n      yield document.lineAt(index).text;\n    }\n  }\n\n  /*\n   * Calculate the indentation of a line of text.\n   * Lines consisting entirely of whitespace of \"starting\" with a comment are defined\n   * to have an indentation of \"undefined\".\n   */\n  static _indentation(line: string): number | undefined {\n    const index: number = line.search(PythonDocument.reOnlyWhitespace);\n\n    // Return undefined if line is empty, just whitespace, or starts with a comment\n    if (index === -1 || line[index] === '#') {\n      return undefined;\n    }\n\n    return index;\n  }\n\n  /*\n   * Parse a line of text to extract LineInfo\n   * Return undefined if the line is empty or starts with a comment\n   */\n  static _parseLine(index: number, text: string): LineInfo | undefined {\n    const indentation = this._indentation(text);\n\n    // Since indentation === 0 is a valid result we need to check for undefined explicitly\n    return indentation !== undefined ? { line: index, indentation, text } : undefined;\n  }\n\n  static _parseLines(document: TextDocument): LineInfo[] {\n    const lines = [...this.lines(document)]; // convert generator to Array\n    const infos = lines.map((text, index) => this._parseLine(index, text));\n\n    return infos.filter((x) => x) as LineInfo[]; // filter out empty/comment lines (undefined info)\n  }\n\n  static _parseStructure(lines: LineInfo[]): StructureElement[] {\n    const last = lines.length;\n    const structure: StructureElement[] = [];\n\n    for (let index = 0; index < last; index++) {\n      const info = lines[index];\n      const text = info.text;\n      const match = text.match(PythonDocument.reDefOrClass);\n\n      if (match) {\n        const type = match[1] === 'def' ? 'function' : 'class';\n\n        // Find the end of the current function/class\n        let idx = index + 1;\n\n        for (; idx < last; idx++) {\n          if (lines[idx].indentation <= info.indentation) {\n            break;\n          }\n        }\n\n        // Since we stop when we find the first line with a less indentation\n        // we pull back one line to get to the end of the function/class\n        idx--;\n\n        const endLine = lines[idx];\n\n        structure.push({\n          type,\n          start: new Position(info.line, info.indentation),\n          // Calculate position of last non-white character)\n          end: new Position(\n            endLine.line,\n            endLine.text.search(PythonDocument.reLastNonWhiteSpaceCharacter) - 1\n          ),\n        });\n      }\n    }\n\n    return structure;\n  }\n\n  /*\n   * Find the position of the specified:\n   *    type: function or class\n   *    direction: next or prev\n   *    edge: start or end\n   *\n   * With this information one can determine all of the required motions\n   */\n  find(type: Type, direction: Direction, edge: Edge, position: Position): Position | undefined {\n    // Choose the ordering method name based on direction\n    const isDirection = direction === 'next' ? 'isAfter' : 'isBefore';\n\n    // Filter function for all elements whose \"edge\" is in the correct \"direction\"\n    // relative to the cursor's position\n    const dir = (element: StructureElement) => element[edge][isDirection](position);\n\n    // Filter out elements from structure based on type and direction\n    const elements = this.structure.filter((elem) => elem.type === type).filter(dir);\n\n    if (edge === 'end') {\n      // When moving to an 'end' the elements should be started by the end position\n      elements.sort((a, b) => a.end.line - b.end.line);\n    }\n\n    // Return the first match if any exist\n    if (elements.length) {\n      // If direction === 'next' return the first element\n      // otherwise return the last element\n      const index = direction === 'next' ? 0 : elements.length - 1;\n      const element = elements[index];\n      const pos = element[edge];\n\n      // execAction MUST return a fully realized Position object created using new\n      return pos;\n    }\n\n    return undefined;\n  }\n\n  // Use PythonDocument instance to move to specified class boundary\n  static moveClassBoundary(\n    document: TextDocument,\n    position: Position,\n    vimState: VimState,\n    forward: boolean,\n    start: boolean\n  ): Position | IMovement {\n    const direction = forward ? 'next' : 'prev';\n    const edge = start ? 'start' : 'end';\n\n    return (\n      new PythonDocument(document).find('class', direction, edge, position) ??\n      failedMovement(vimState)\n    );\n  }\n}\n\n// Uses the specified findFunction to execute the motion coupled to the shortcut (keys)\nabstract class BasePythonMovement extends BaseMovement {\n  abstract type: Type;\n  abstract direction: Direction;\n  abstract edge: Edge;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.document.languageId === 'python'\n    );\n  }\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const document = vimState.document;\n    return (\n      new PythonDocument(document).find(this.type, this.direction, this.edge, position) ??\n      failedMovement(vimState)\n    );\n  }\n}\n\n@RegisterAction\nclass MovePythonNextFunctionStart extends BasePythonMovement {\n  keys = [']', 'm'];\n  type: Type = 'function';\n  direction: Direction = 'next';\n  edge: Edge = 'start';\n}\n\n@RegisterAction\nclass MovePythonPrevFunctionStart extends BasePythonMovement {\n  keys = ['[', 'm'];\n  type: Type = 'function';\n  direction: Direction = 'prev';\n  edge: Edge = 'start';\n}\n\n@RegisterAction\nclass MovePythonNextFunctionEnd extends BasePythonMovement {\n  keys = [']', 'M'];\n  type: Type = 'function';\n  direction: Direction = 'next';\n  edge: Edge = 'end';\n}\n\n@RegisterAction\nclass MovePythonPrevFunctionEnd extends BasePythonMovement {\n  keys = ['[', 'M'];\n  type: Type = 'function';\n  direction: Direction = 'prev';\n  edge: Edge = 'end';\n}\n","import * as vscode from 'vscode';\n\nimport { ChangeOperator, DeleteOperator, YankOperator } from './operator';\nimport { CursorMoveByUnit, CursorMovePosition, TextEditor } from './../textEditor';\nimport { isVisualMode, Mode } from './../mode/mode';\nimport { PairMatcher } from './../common/matching/matcher';\nimport { QuoteMatcher } from './../common/matching/quoteMatcher';\nimport { RegisterAction } from './base';\nimport { RegisterMode } from './../register/register';\nimport { ReplaceState } from './../state/replaceState';\nimport { TagMatcher } from './../common/matching/tagMatcher';\nimport { VimState } from './../state/vimState';\nimport { configuration } from './../configuration/configuration';\nimport { shouldWrapKey } from './wrapping';\nimport { VimError, ErrorCode } from '../error';\nimport { BaseMovement, SelectionType, IMovement, isIMovement, failedMovement } from './baseMotion';\nimport { globalState } from '../state/globalState';\nimport { reportSearch } from '../util/statusBarTextUtils';\nimport { SneakForward, SneakBackward } from './plugins/sneak';\nimport { Notation } from '../configuration/notation';\nimport { SearchDirection } from '../state/searchState';\nimport { StatusBar } from '../statusBar';\nimport { clamp } from '../util/util';\nimport { getCurrentParagraphBeginning, getCurrentParagraphEnd } from '../textobject/paragraph';\nimport { PythonDocument } from './languages/python/motion';\nimport { Position } from 'vscode';\nimport { sorted } from '../common/motion/position';\nimport { WordType } from '../textobject/word';\nimport { CommandInsertAtCursor } from './commands/actions';\n\n/**\n * A movement is something like 'h', 'k', 'w', 'b', 'gg', etc.\n */\n\nexport abstract class ExpandingSelection extends BaseMovement {\n  protected override selectionType = SelectionType.Expanding;\n\n  protected override adjustPosition(position: Position, result: IMovement, lastIteration: boolean) {\n    if (!lastIteration) {\n      position = result.stop;\n    }\n    return position;\n  }\n}\n\nabstract class MoveByScreenLine extends BaseMovement {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  abstract movementType: CursorMovePosition;\n  by?: CursorMoveByUnit;\n  value: number = 1;\n\n  public override async execAction(position: Position, vimState: VimState) {\n    return this.execActionWithCount(position, vimState, 1);\n  }\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    const multicursorIndex = this.multicursorIndex ?? 0;\n\n    if (multicursorIndex === 0) {\n      if (vimState.currentMode === Mode.Visual) {\n        // If we change the `vimState.editor.selections` directly with the forEach\n        // for some reason vscode doesn't update them. But doing it this way does\n        // update vscode's selections.\n        const selections = vimState.editor.selections;\n        selections.forEach((s, i) => {\n          if (s.active.isAfter(s.anchor)) {\n            // The selection is on the right side of the cursor, while our representation\n            // considers the cursor to be the left edge, so we need to move the selection\n            // to the right place before executing the 'cursorMove' command.\n            const active = s.active.getLeftThroughLineBreaks();\n            vimState.editor.selections[i] = new vscode.Selection(s.anchor, active);\n          }\n        });\n        vimState.editor.selections = selections;\n      }\n\n      // When we have multicursors and run a 'cursorMove' command, vscode applies that command\n      // to all cursors at the same time. So we should only run it once.\n      await vscode.commands.executeCommand('cursorMove', {\n        to: this.movementType,\n        select: vimState.currentMode !== Mode.Normal,\n        by: this.by,\n        value: this.value * count,\n      });\n    }\n\n    /**\n     * HACK:\n     * The `cursorMove` command is handling the selection for us.\n     * So we are not following our design principal (do no real movement inside an action) here\n     */\n    if (!vimState.editor.selections[multicursorIndex]) {\n      // VS Code selections no longer have the same amount of cursors as we do. This means that\n      // two or more selections combined into one. In this case we return these cursors as they\n      // were with the removed flag so that they can be removed.\n      // TODO: does this work in VisualBlock (where cursors are not 1 to 1 with selections)?\n      return {\n        start: vimState.cursorStartPosition,\n        stop: vimState.cursorStopPosition,\n        removed: true,\n      };\n    }\n\n    if (vimState.currentMode === Mode.Normal) {\n      return vimState.editor.selections[multicursorIndex].active;\n    } else {\n      let start = vimState.editor.selections[multicursorIndex].anchor;\n      const stop = vimState.editor.selections[multicursorIndex].active;\n\n      // If we are moving up we need to keep getting the left of anchor/start because vscode is\n      // to the right of the character in order to include it but our positions are always on the\n      // left side of the character.\n      // Also when we switch from being before anchor to being after anchor we need to move\n      // the anchor/start to the left as well in order to include the character.\n      if (\n        (start.isAfter(stop) &&\n          vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) ||\n        (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition) &&\n          start.isBeforeOrEqual(stop))\n      ) {\n        start = start.getLeft();\n      }\n\n      return { start, stop };\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<IMovement> {\n    const multicursorIndex = this.multicursorIndex ?? 0;\n    if (multicursorIndex === 0) {\n      // When we have multicursors and run a 'cursorMove' command, vscode applies that command\n      // to all cursors at the same time. So we should only run it once.\n      await vscode.commands.executeCommand('cursorMove', {\n        to: this.movementType,\n        select: true,\n        by: this.by,\n        value: this.value,\n      });\n    }\n\n    if (!vimState.editor.selections[multicursorIndex]) {\n      // Vscode selections no longer have the same amount of cursors as we do. This means that\n      // two or more selections combined into one. In this case we return these cursors as they\n      // were with the removed flag so that they can be removed.\n      return {\n        start: vimState.cursorStartPosition,\n        stop: vimState.cursorStopPosition,\n        removed: true,\n      };\n    }\n\n    return {\n      start: vimState.editor.selections[multicursorIndex].start,\n      stop: vimState.editor.selections[multicursorIndex].end,\n    };\n  }\n}\n\nclass MoveUpByScreenLine extends MoveByScreenLine {\n  keys = [];\n  movementType: CursorMovePosition = 'up';\n  override by: CursorMoveByUnit = 'wrappedLine';\n  override value = 1;\n}\n\nclass MoveDownByScreenLine extends MoveByScreenLine {\n  keys = [];\n  movementType: CursorMovePosition = 'down';\n  override by: CursorMoveByUnit = 'wrappedLine';\n  override value = 1;\n}\n\nabstract class MoveByScreenLineMaintainDesiredColumn extends MoveByScreenLine {\n  override preservesDesiredColumn = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const prevDesiredColumn = vimState.desiredColumn;\n    const prevLine = vimState.editor.selection.active.line;\n\n    if (vimState.currentMode !== Mode.Normal) {\n      /**\n       * As VIM and VSCode handle the end of selection index a little\n       * differently we need to sometimes move the cursor at the end\n       * of the selection back by a character.\n       */\n      const start = vimState.editor.selection.start;\n      if (\n        (this.movementType === 'down' && position.line > start.line) ||\n        (this.movementType === 'up' && position.line < prevLine)\n      ) {\n        await vscode.commands.executeCommand('cursorMove', {\n          to: 'left',\n          select: true,\n          by: 'character',\n          value: 1,\n        });\n      }\n    }\n\n    await vscode.commands.executeCommand('cursorMove', {\n      to: this.movementType,\n      select: vimState.currentMode !== Mode.Normal,\n      by: this.by,\n      value: this.value,\n    });\n\n    if (vimState.currentMode === Mode.Normal) {\n      let returnedPos = vimState.editor.selection.active;\n      if (prevLine !== returnedPos.line) {\n        returnedPos = returnedPos.withColumn(prevDesiredColumn);\n      }\n      return returnedPos;\n    } else {\n      /**\n       * cursorMove command is handling the selection for us.\n       * So we are not following our design principal (do no real movement inside an action) here.\n       */\n      let start = vimState.editor.selection.start;\n      let stop = vimState.editor.selection.end;\n      const curPos = vimState.editor.selection.active;\n\n      // We want to swap the cursor start stop positions based on which direction we are moving, up or down\n      if (start.isEqual(curPos) && !start.isEqual(stop)) {\n        [start, stop] = [stop, start];\n        if (prevLine !== start.line) {\n          start = start.getLeft();\n        }\n      }\n\n      if (position.line !== stop.line) {\n        stop = stop.withColumn(prevDesiredColumn);\n      }\n\n      return { start, stop };\n    }\n  }\n}\n\nclass MoveDownFoldFix extends MoveByScreenLineMaintainDesiredColumn {\n  keys = [];\n  movementType: CursorMovePosition = 'down';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (position.line >= vimState.document.lineCount - 1) {\n      return position;\n    }\n    let t: Position | IMovement = position;\n    let prevLine: number = position.line;\n    let prevChar: number = position.character;\n    const prevDesiredColumn = vimState.desiredColumn;\n    const moveDownByScreenLine = new MoveDownByScreenLine();\n    do {\n      t = await moveDownByScreenLine.execAction(t, vimState);\n      t = t instanceof Position ? t : t.stop;\n      const lineChanged = prevLine !== t.line;\n      // wrappedLine movement goes to eol character only when at the last line\n      // thus a column change on wrappedLine movement represents a visual last line\n      const colChanged = prevChar !== t.character;\n      if (lineChanged || !colChanged) {\n        break;\n      }\n      prevChar = t.character;\n      prevLine = t.line;\n    } while (t.line === position.line);\n    // fix column change at last line caused by wrappedLine movement\n    // causes cursor lag and flicker if a large repeat prefix is given to movement\n    if (t.character !== prevDesiredColumn) {\n      t = new Position(t.line, prevDesiredColumn);\n    }\n    return t;\n  }\n}\n\n@RegisterAction\nclass MoveDown extends BaseMovement {\n  keys = [['j'], ['<down>'], ['<C-j>'], ['<C-n>']];\n  override preservesDesiredColumn = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (\n      vimState.currentMode === Mode.Insert &&\n      this.keysPressed[0] === '<down>' &&\n      vimState.editor.document.uri.scheme === 'vscode-interactive-input' &&\n      position.line === vimState.document.lineCount - 1 &&\n      vimState.editor.selection.isEmpty\n    ) {\n      // navigate history in interactive window\n      await vscode.commands.executeCommand('interactive.history.next');\n      return vimState.editor.selection.active;\n    }\n\n    if (configuration.foldfix && vimState.currentMode !== Mode.VisualBlock) {\n      return new MoveDownFoldFix().execAction(position, vimState);\n    }\n\n    if (position.line < vimState.document.lineCount - 1) {\n      return position.with({ character: vimState.desiredColumn }).getDown();\n    } else {\n      return position;\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getDown();\n  }\n}\n\n@RegisterAction\nclass MoveUp extends BaseMovement {\n  keys = [['k'], ['<up>'], ['<C-p>']];\n  override preservesDesiredColumn = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (\n      vimState.currentMode === Mode.Insert &&\n      this.keysPressed[0] === '<up>' &&\n      vimState.editor.document.uri.scheme === 'vscode-interactive-input' &&\n      position.line === 0 &&\n      vimState.editor.selection.isEmpty\n    ) {\n      // navigate history in interactive window\n      await vscode.commands.executeCommand('interactive.history.previous');\n      return vimState.editor.selection.active;\n    }\n\n    if (configuration.foldfix && vimState.currentMode !== Mode.VisualBlock) {\n      return new MoveUpFoldFix().execAction(position, vimState);\n    }\n\n    if (position.line > 0) {\n      return position.with({ character: vimState.desiredColumn }).getUp();\n    } else {\n      return position;\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getUp();\n  }\n}\n\n@RegisterAction\nclass MoveUpFoldFix extends MoveByScreenLineMaintainDesiredColumn {\n  keys = [];\n  movementType: CursorMovePosition = 'up';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (position.line === 0) {\n      return position;\n    }\n    let t: Position | IMovement;\n    const prevDesiredColumn = vimState.desiredColumn;\n    const moveUpByScreenLine = new MoveUpByScreenLine();\n    do {\n      t = await moveUpByScreenLine.execAction(position, vimState);\n      t = t instanceof Position ? t : t.stop;\n    } while (t.line === position.line);\n    // fix column change at last line caused by wrappedLine movement\n    // causes cursor lag and flicker if a large repeat prefix is given to movement\n    if (t.character !== prevDesiredColumn) {\n      t = new Position(t.line, prevDesiredColumn);\n    }\n    return t;\n  }\n}\n\n@RegisterAction\nexport class ArrowsInInsertMode extends BaseMovement {\n  override modes = [Mode.Insert];\n  keys = [['<up>'], ['<down>'], ['<left>'], ['<right>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    // Moving with the arrow keys in Insert mode \"resets\" our insertion for the purpose of repeating with dot or `<C-a>`.\n    // No matter how we got into Insert mode, repeating will now be done as if we started with `i`.\n    // Note that this does not affect macros, which re-construct a list of actions based on keypresses.\n    // TODO: ACTUALLY, we should reset this only after something is typed (`Axyz<Left><Esc>.` does repeat the insertion)\n    // TODO: This also should mark an \"insertion end\" for the purpose of `<C-a>` (try `ixyz<Right><C-a>`)\n    vimState.recordedState.actionsRun = [new CommandInsertAtCursor()];\n\n    // Force an undo point to be created\n    vimState.historyTracker.addChange(true);\n    vimState.historyTracker.finishCurrentStep();\n\n    let newPosition: Position;\n    switch (this.keysPressed[0]) {\n      case '<up>':\n        newPosition = (await new MoveUp(this.keysPressed).execAction(\n          position,\n          vimState\n        )) as Position;\n        break;\n      case '<down>':\n        newPosition = (await new MoveDown(this.keysPressed).execAction(\n          position,\n          vimState\n        )) as Position;\n        break;\n      case '<left>':\n        newPosition = await new MoveLeft(this.keysPressed).execAction(position, vimState);\n        break;\n      case '<right>':\n        newPosition = await new MoveRight(this.keysPressed).execAction(position, vimState);\n        break;\n      default:\n        throw new Error(`Unexpected 'arrow' key: ${this.keys[0]}`);\n    }\n    // TODO: Is resetting ReplaceState necessary?\n    vimState.replaceState = new ReplaceState(vimState, newPosition);\n    return newPosition;\n  }\n}\n\n@RegisterAction\nclass ArrowsInReplaceMode extends BaseMovement {\n  override modes = [Mode.Replace];\n  keys = [['<up>'], ['<down>'], ['<left>'], ['<right>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    // Force an undo point to be created\n    vimState.historyTracker.addChange(true);\n    vimState.historyTracker.finishCurrentStep();\n\n    let newPosition: Position = position;\n    switch (this.keysPressed[0]) {\n      case '<up>':\n        newPosition = (await new MoveUp().execAction(position, vimState)) as Position;\n        break;\n      case '<down>':\n        newPosition = (await new MoveDown().execAction(position, vimState)) as Position;\n        break;\n      case '<left>':\n        newPosition = await new MoveLeft(this.keysPressed).execAction(position, vimState);\n        break;\n      case '<right>':\n        newPosition = await new MoveRight(this.keysPressed).execAction(position, vimState);\n        break;\n      default:\n        throw new Error(`Unexpected 'arrow' key: ${this.keys[0]}`);\n    }\n    vimState.replaceState = new ReplaceState(vimState, newPosition);\n    return newPosition;\n  }\n}\n\n@RegisterAction\nclass CommandNextSearchMatch extends BaseMovement {\n  keys = ['n'];\n  override isJump = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const searchState = globalState.searchState;\n\n    if (!searchState || searchState.searchString === '') {\n      return position;\n    }\n\n    // Turn one of the highlighting flags back on (turned off with :nohl)\n    globalState.hl = true;\n\n    if (searchState.getMatchRanges(vimState.editor).length === 0) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.PatternNotFound, searchState.searchString)\n      );\n      return failedMovement(vimState);\n    }\n\n    // we have to handle a special case here: searching for $ or \\n,\n    // which we approximate by positionIsEOL. In that case (but only when searching forward)\n    // we need to \"offset\" by getRight for searching the next match, otherwise we get stuck.\n    const searchForward = searchState.searchDirection === SearchDirection.Forward;\n    const positionIsEOL = position.getRight().isEqual(position.getLineEnd());\n    const nextMatch =\n      positionIsEOL && searchForward\n        ? searchState.getNextSearchMatchPosition(vimState.editor, position.getRight())\n        : searchState.getNextSearchMatchPosition(vimState.editor, position);\n\n    if (!nextMatch) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(\n          searchState.searchDirection === SearchDirection.Forward\n            ? ErrorCode.SearchHitBottom\n            : ErrorCode.SearchHitTop,\n          searchState.searchString\n        )\n      );\n      return failedMovement(vimState);\n    }\n\n    reportSearch(nextMatch.index, searchState.getMatchRanges(vimState.editor).length, vimState);\n\n    return nextMatch.pos;\n  }\n}\n\n@RegisterAction\nclass CommandPreviousSearchMatch extends BaseMovement {\n  keys = ['N'];\n  override isJump = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const searchState = globalState.searchState;\n\n    if (!searchState || searchState.searchString === '') {\n      return position;\n    }\n\n    // Turn one of the highlighting flags back on (turned off with :nohl)\n    globalState.hl = true;\n\n    if (searchState.getMatchRanges(vimState.editor).length === 0) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.PatternNotFound, searchState.searchString)\n      );\n      return failedMovement(vimState);\n    }\n\n    const searchForward = searchState.searchDirection === SearchDirection.Forward;\n    const positionIsEOL = position.getRight().isEqual(position.getLineEnd());\n\n    // see implementation of n, above.\n    const prevMatch =\n      positionIsEOL && !searchForward\n        ? searchState.getNextSearchMatchPosition(\n            vimState.editor,\n            position.getRight(),\n            SearchDirection.Backward\n          )\n        : searchState.getNextSearchMatchPosition(\n            vimState.editor,\n            position,\n            SearchDirection.Backward\n          );\n\n    if (!prevMatch) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(\n          searchState.searchDirection === SearchDirection.Forward\n            ? ErrorCode.SearchHitTop\n            : ErrorCode.SearchHitBottom,\n          searchState.searchString\n        )\n      );\n      return failedMovement(vimState);\n    }\n\n    reportSearch(prevMatch.index, searchState.getMatchRanges(vimState.editor).length, vimState);\n\n    return prevMatch.pos;\n  }\n}\n\n@RegisterAction\nclass MarkMovementBOL extends BaseMovement {\n  keys = [\"'\", '<character>'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const markName = this.keysPressed[1];\n    const mark = vimState.historyTracker.getMark(markName);\n\n    if (mark === undefined) {\n      throw VimError.fromCode(ErrorCode.MarkNotSet);\n    }\n\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    if (mark.isUppercaseMark && mark.document !== undefined) {\n      if (vimState.recordedState.operator && mark.document !== vimState.document) {\n        // Operators don't work across files\n        throw VimError.fromCode(ErrorCode.MarkNotSet);\n      }\n      await ensureEditorIsActive(mark.document);\n    }\n\n    return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, mark.position.line);\n  }\n}\n\n@RegisterAction\nclass MarkMovement extends BaseMovement {\n  keys = ['`', '<character>'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const markName = this.keysPressed[1];\n    const mark = vimState.historyTracker.getMark(markName);\n\n    if (mark === undefined) {\n      throw VimError.fromCode(ErrorCode.MarkNotSet);\n    }\n\n    if (mark.isUppercaseMark && mark.document !== undefined) {\n      if (vimState.recordedState.operator && mark.document !== vimState.document) {\n        // Operators don't work across files\n        throw VimError.fromCode(ErrorCode.MarkNotSet);\n      }\n      await ensureEditorIsActive(mark.document);\n    }\n\n    return mark.position;\n  }\n}\n\n@RegisterAction\nclass NextMark extends BaseMovement {\n  keys = [']', '`'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const positions = vimState.historyTracker\n      .getLocalMarks()\n      .filter((mark) => mark.position.isAfter(position))\n      .map((mark) => mark.position)\n      .sort((x, y) => x.compareTo(y));\n    return positions.length === 0 ? position : positions[0];\n  }\n}\n\n@RegisterAction\nclass PrevMark extends BaseMovement {\n  keys = ['[', '`'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const positions = vimState.historyTracker\n      .getLocalMarks()\n      .filter((mark) => mark.position.isBefore(position))\n      .map((mark) => mark.position)\n      .sort((x, y) => y.compareTo(x));\n    return positions.length === 0 ? position : positions[0];\n  }\n}\n\n@RegisterAction\nclass NextMarkLinewise extends BaseMovement {\n  keys = [']', \"'\"];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    const lines = vimState.historyTracker\n      .getLocalMarks()\n      .filter((mark) => mark.position.line > position.line)\n      .map((mark) => mark.position.line);\n    const line = lines.length === 0 ? position.line : Math.min(...lines);\n    return new Position(line, 0).getLineBeginRespectingIndent(vimState.document);\n  }\n}\n\n@RegisterAction\nclass PrevMarkLinewise extends BaseMovement {\n  keys = ['[', \"'\"];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    const lines = vimState.historyTracker\n      .getLocalMarks()\n      .filter((mark) => mark.position.line < position.line)\n      .map((mark) => mark.position.line);\n    const line = lines.length === 0 ? position.line : Math.max(...lines);\n    return new Position(line, 0).getLineBeginRespectingIndent(vimState.document);\n  }\n}\n\nasync function ensureEditorIsActive(document: vscode.TextDocument) {\n  if (document !== vscode.window.activeTextEditor?.document) {\n    await vscode.window.showTextDocument(document);\n  }\n}\n\n@RegisterAction\nclass MoveLeft extends BaseMovement {\n  keys = [['h'], ['<left>'], ['<BS>'], ['<C-BS>'], ['<S-BS>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return shouldWrapKey(vimState.currentMode, this.keysPressed[0])\n      ? position.getLeftThroughLineBreaks(\n          [Mode.Insert, Mode.Replace].includes(vimState.currentMode)\n        )\n      : position.getLeft();\n  }\n}\n\n@RegisterAction\nclass MoveRight extends BaseMovement {\n  keys = [['l'], ['<right>'], [' ']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return shouldWrapKey(vimState.currentMode, this.keysPressed[0])\n      ? position.getRightThroughLineBreaks(\n          [Mode.Insert, Mode.Replace].includes(vimState.currentMode)\n        )\n      : position.getRight();\n  }\n}\n\n@RegisterAction\nclass MoveDownNonBlank extends BaseMovement {\n  keys = [['+'], ['\\n'], ['<C-m>']];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      position.getDown(Math.max(count, 1)).line\n    );\n  }\n}\n\n@RegisterAction\nclass MoveUpNonBlank extends BaseMovement {\n  keys = ['-'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      position.getUp(Math.max(count, 1)).line\n    );\n  }\n}\n\n@RegisterAction\nclass MoveDownUnderscore extends BaseMovement {\n  keys = ['_'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    const pos = position.getDown(Math.max(count - 1, 0));\n    return vimState.recordedState.operator\n      ? pos\n      : TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, pos.line);\n  }\n}\n\n@RegisterAction\nclass MoveToColumn extends BaseMovement {\n  keys = ['|'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    return new Position(position.line, Math.max(0, count - 1));\n  }\n}\n\n/**\n * Returns the Postion of the next instance of `char` on the line\n * @param char character to look for\n * @param count number of times to look\n * @param direction direction to look in\n */\nfunction findHelper(\n  vimState: VimState,\n  start: Position,\n  char: string,\n  count: number,\n  direction: 'forward' | 'backward'\n): Position | undefined {\n  const line = vimState.document.lineAt(start);\n\n  let index = start.character;\n  while (count > 0 && index >= 0) {\n    if (direction === 'forward') {\n      index = line.text.indexOf(char, index + 1);\n    } else {\n      index = line.text.lastIndexOf(char, index - 1);\n    }\n    count--;\n  }\n\n  if (index >= 0) {\n    return new Position(start.line, index);\n  }\n\n  return undefined;\n}\n\n@RegisterAction\nclass MoveFindForward extends BaseMovement {\n  keys = ['f', '<character>'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    if (configuration.sneakReplacesF) {\n      const pos = await new SneakForward(\n        this.keysPressed.concat('\\n'),\n        this.isRepeat\n      ).execActionWithCount(position, vimState, count);\n      if (vimState.recordedState.operator && !isIMovement(pos)) {\n        return pos.getRight();\n      }\n\n      return pos;\n    }\n\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    let result = findHelper(vimState, position, toFind, count, 'forward');\n\n    vimState.lastSemicolonRepeatableMovement = new MoveFindForward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveFindBackward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (vimState.recordedState.operator) {\n      result = result.getRight();\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveFindBackward extends BaseMovement {\n  keys = ['F', '<character>'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    if (configuration.sneakReplacesF) {\n      return new SneakBackward(this.keysPressed.concat('\\n'), this.isRepeat).execActionWithCount(\n        position,\n        vimState,\n        count\n      );\n    }\n\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    const result = findHelper(vimState, position, toFind, count, 'backward');\n\n    vimState.lastSemicolonRepeatableMovement = new MoveFindBackward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveFindForward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    return result;\n  }\n}\n\nfunction tilHelper(\n  vimState: VimState,\n  start: Position,\n  char: string,\n  count: number,\n  direction: 'forward' | 'backward'\n) {\n  const result = findHelper(vimState, start, char, count, direction);\n  return direction === 'forward' ? result?.getLeft() : result?.getRight();\n}\n\n@RegisterAction\nclass MoveTilForward extends BaseMovement {\n  keys = ['t', '<character>'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    let result = tilHelper(vimState, position, toFind, count, 'forward');\n\n    // For t<character> vim executes ; as 2; and , as 2,\n    if (result && this.isRepeat && position.isEqual(result) && count === 1) {\n      result = tilHelper(vimState, position, toFind, 2, 'forward');\n    }\n\n    vimState.lastSemicolonRepeatableMovement = new MoveTilForward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveTilBackward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (vimState.recordedState.operator) {\n      result = result.getRight();\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveTilBackward extends BaseMovement {\n  keys = ['T', '<character>'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    let result = tilHelper(vimState, position, toFind, count, 'backward');\n\n    // For T<character> vim executes ; as 2; and , as 2,\n    if (result && this.isRepeat && position.isEqual(result) && count === 1) {\n      result = tilHelper(vimState, position, toFind, 2, 'backward');\n    }\n\n    vimState.lastSemicolonRepeatableMovement = new MoveTilBackward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveTilForward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveRepeat extends BaseMovement {\n  keys = [';'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    const movement = vimState.lastSemicolonRepeatableMovement;\n    if (movement) {\n      return movement.execActionWithCount(position, vimState, count);\n    }\n    return position;\n  }\n}\n\n@RegisterAction\nclass MoveRepeatReversed extends BaseMovement {\n  keys = [','];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    const semiColonMovement = vimState.lastSemicolonRepeatableMovement;\n    const commaMovement = vimState.lastCommaRepeatableMovement;\n    if (commaMovement) {\n      const result = commaMovement.execActionWithCount(position, vimState, count);\n\n      // Make sure these don't change. Otherwise, comma's direction flips back\n      // and forth when done repeatedly. This is a bit hacky, so feel free to refactor.\n      vimState.lastSemicolonRepeatableMovement = semiColonMovement;\n      vimState.lastCommaRepeatableMovement = commaMovement;\n\n      return result;\n    }\n    return position;\n  }\n}\n\n@RegisterAction\nclass MoveLineEnd extends BaseMovement {\n  keys = [['$'], ['<End>'], ['<D-right>']];\n  override setsDesiredColumnToEOL = true;\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    return position.getDown(Math.max(count - 1, 0)).getLineEnd();\n  }\n}\n\n@RegisterAction\nclass MoveLineBegin extends BaseMovement {\n  keys = [['0'], ['<Home>'], ['<D-left>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getLineBegin();\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && vimState.recordedState.count === 0;\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.couldActionApply(vimState, keysPressed) && vimState.recordedState.count === 0;\n  }\n}\n\n@RegisterAction\nclass MoveScreenLineBegin extends MoveByScreenLine {\n  keys = ['g', '0'];\n  movementType: CursorMovePosition = 'wrappedLineStart';\n}\n\n@RegisterAction\nclass MoveScreenNonBlank extends MoveByScreenLine {\n  keys = ['g', '^'];\n  movementType: CursorMovePosition = 'wrappedLineFirstNonWhitespaceCharacter';\n}\n\n@RegisterAction\nclass MoveScreenLineEnd extends MoveByScreenLine {\n  keys = ['g', '$'];\n  movementType: CursorMovePosition = 'wrappedLineEnd';\n}\n\n@RegisterAction\nclass MoveScreenLineEndNonBlank extends MoveByScreenLine {\n  keys = ['g', '_'];\n  movementType: CursorMovePosition = 'wrappedLineLastNonWhitespaceCharacter';\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    count ||= 1;\n    const pos = await super.execActionWithCount(position, vimState, count);\n\n    // If in visual, return a selection\n    if (pos instanceof Position) {\n      return pos.getDown(count - 1);\n    } else {\n      return { start: pos.start, stop: pos.stop.getDown(count - 1).getLeftThroughLineBreaks() };\n    }\n  }\n}\n\n@RegisterAction\nclass MoveScreenLineCenter extends MoveByScreenLine {\n  keys = ['g', 'm'];\n  movementType: CursorMovePosition = 'wrappedLineColumnCenter';\n}\n\n@RegisterAction\nclass MoveUpByDisplayLine extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = [\n    ['g', 'k'],\n    ['g', '<up>'],\n  ];\n  movementType: CursorMovePosition = 'up';\n  override by: CursorMoveByUnit = 'wrappedLine';\n  override value = 1;\n}\n\n@RegisterAction\nclass MoveDownByDisplayLine extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = [\n    ['g', 'j'],\n    ['g', '<down>'],\n  ];\n  movementType: CursorMovePosition = 'down';\n  override by: CursorMoveByUnit = 'wrappedLine';\n  override value = 1;\n}\n\n// Because we can't support moving by screen line when in visualLine mode,\n// we change to moving by regular line in visualLine mode. We can't move by\n// screen line is that our ranges only support a start and stop attribute,\n// and moving by screen line just snaps us back to the original position.\n// Check PR #1600 for discussion.\n@RegisterAction\nclass MoveUpByScreenLineVisualLine extends MoveByScreenLine {\n  override modes = [Mode.VisualLine];\n  keys = [\n    ['g', 'k'],\n    ['g', '<up>'],\n  ];\n  movementType: CursorMovePosition = 'up';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n}\n\n@RegisterAction\nclass MoveDownByScreenLineVisualLine extends MoveByScreenLine {\n  override modes = [Mode.VisualLine];\n  keys = [\n    ['g', 'j'],\n    ['g', '<down>'],\n  ];\n  movementType: CursorMovePosition = 'down';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n}\n\n@RegisterAction\nclass MoveUpByScreenLineVisualBlock extends BaseMovement {\n  override modes = [Mode.VisualBlock];\n  keys = [\n    ['g', 'k'],\n    ['g', '<up>'],\n  ];\n  override preservesDesiredColumn = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (position.line > 0) {\n      return position.with({ character: vimState.desiredColumn }).getUp();\n    } else {\n      return position;\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getUp();\n  }\n}\n\n@RegisterAction\nclass MoveDownByScreenLineVisualBlock extends BaseMovement {\n  override modes = [Mode.VisualBlock];\n  keys = [\n    ['g', 'j'],\n    ['g', '<down>'],\n  ];\n  override preservesDesiredColumn = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (position.line < vimState.document.lineCount - 1) {\n      return position.with({ character: vimState.desiredColumn }).getDown();\n    } else {\n      return position;\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getDown();\n  }\n}\n\n@RegisterAction\nclass MoveScreenToRight extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'h'];\n  movementType: CursorMovePosition = 'right';\n  override by: CursorMoveByUnit = 'character';\n  override value = 1;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveScreenToLeft extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'l'];\n  movementType: CursorMovePosition = 'left';\n  override by: CursorMoveByUnit = 'character';\n  override value = 1;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveScreenToRightHalf extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'H'];\n  movementType: CursorMovePosition = 'right';\n  override by: CursorMoveByUnit = 'halfLine';\n  override value = 1;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveScreenToLeftHalf extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'L'];\n  movementType: CursorMovePosition = 'left';\n  override by: CursorMoveByUnit = 'halfLine';\n  override value = 1;\n  override isJump = true;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveToLineFromViewPortTop extends MoveByScreenLine {\n  keys = ['H'];\n  movementType: CursorMovePosition = 'viewPortTop';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n  override isJump = true;\n}\n\n@RegisterAction\nclass MoveToLineFromViewPortBottom extends MoveByScreenLine {\n  keys = ['L'];\n  movementType: CursorMovePosition = 'viewPortBottom';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n  override isJump = true;\n}\n\n@RegisterAction\nclass MoveToMiddleLineInViewPort extends MoveByScreenLine {\n  keys = ['M'];\n  movementType: CursorMovePosition = 'viewPortCenter';\n  override by: CursorMoveByUnit = 'line';\n  override isJump = true;\n}\n\n@RegisterAction\nclass MoveNonBlank extends BaseMovement {\n  keys = ['^'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.line);\n  }\n}\n\n@RegisterAction\nclass MoveNonBlankFirst extends BaseMovement {\n  keys = [['g', 'g'], ['<C-Home>']];\n  override isJump = true;\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    const line = clamp(count, 1, vimState.document.lineCount) - 1;\n\n    return {\n      start: vimState.cursorStartPosition,\n      stop: position.with({ line }).obeyStartOfLine(vimState.document),\n    };\n  }\n}\n\n@RegisterAction\nclass MoveNonBlankLast extends BaseMovement {\n  keys = ['G'];\n  override isJump = true;\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    let stop: Position;\n    if (count === 0) {\n      stop = new Position(vimState.document.lineCount - 1, position.character).obeyStartOfLine(\n        vimState.document\n      );\n    } else {\n      stop = new Position(\n        Math.min(count, vimState.document.lineCount) - 1,\n        position.character\n      ).obeyStartOfLine(vimState.document);\n    }\n\n    return {\n      start: vimState.cursorStartPosition,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nclass EndOfSpecificLine extends BaseMovement {\n  keys = ['<C-End>'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position> {\n    const line = count\n      ? clamp(count - 1, 0, vimState.document.lineCount - 1)\n      : vimState.document.lineCount - 1;\n\n    return new Position(line, 0).getLineEnd();\n  }\n}\n\n@RegisterAction\nexport class MoveWordBegin extends BaseMovement {\n  keys = ['w'];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<Position> {\n    if (\n      lastIteration &&\n      !configuration.changeWordIncludesWhitespace &&\n      vimState.recordedState.operator instanceof ChangeOperator\n    ) {\n      const line = vimState.document.lineAt(position);\n      if (line.text.length === 0) {\n        return position;\n      }\n\n      const char = line.text[position.character];\n\n      /*\n      From the Vim manual:\n\n      Special case: \"cw\" and \"cW\" are treated like \"ce\" and \"cE\" if the cursor is\n      on a non-blank.  This is because \"cw\" is interpreted as change-word, and a\n      word does not include the following white space.\n      */\n\n      if (' \\t'.includes(char)) {\n        return position.nextWordStart(vimState.document);\n      } else {\n        return position.nextWordEnd(vimState.document, { inclusive: true }).getRight();\n      }\n    } else {\n      return position.nextWordStart(vimState.document);\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<Position> {\n    const result = await this.execAction(position, vimState, firstIteration, lastIteration);\n\n    /*\n    From the Vim documentation:\n\n    Another special case: When using the \"w\" motion in combination with an\n    operator and the last word moved over is at the end of a line, the end of\n    that word becomes the end of the operated text, not the first word in the\n    next line.\n    */\n\n    if (\n      result.line > position.line + 1 ||\n      (result.line === position.line + 1 && result.isFirstWordOfLine(vimState.document))\n    ) {\n      return position.getLineEnd();\n    }\n\n    if (result.isLineEnd()) {\n      return new Position(result.line, result.character + 1);\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nexport class MoveFullWordBegin extends BaseMovement {\n  keys = [['W'], ['<C-right>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    if (\n      !configuration.changeWordIncludesWhitespace &&\n      vimState.recordedState.operator instanceof ChangeOperator\n    ) {\n      // TODO use execForOperator? Or maybe dont?\n\n      // See note for w\n      return position.nextWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n    } else {\n      return position.nextWordStart(vimState.document, { wordType: WordType.Big });\n    }\n  }\n}\n\n@RegisterAction\nclass MoveWordEnd extends BaseMovement {\n  keys = ['e'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.nextWordEnd(vimState.document);\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    const end = position.nextWordEnd(vimState.document);\n\n    return new Position(end.line, end.character + 1);\n  }\n}\n\n@RegisterAction\nclass MoveFullWordEnd extends BaseMovement {\n  keys = ['E'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.nextWordEnd(vimState.document, { wordType: WordType.Big });\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    return position.nextWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n  }\n}\n\n@RegisterAction\nclass MoveLastWordEnd extends BaseMovement {\n  keys = ['g', 'e'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.prevWordEnd(vimState.document);\n  }\n}\n\n@RegisterAction\nclass MoveLastFullWordEnd extends BaseMovement {\n  keys = ['g', 'E'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.prevWordEnd(vimState.document, { wordType: WordType.Big });\n  }\n}\n\n@RegisterAction\nclass MoveBeginningWord extends BaseMovement {\n  keys = [['b'], ['<C-left>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.prevWordStart(vimState.document);\n  }\n}\n\n@RegisterAction\nclass MoveBeginningFullWord extends BaseMovement {\n  keys = ['B'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.prevWordStart(vimState.document, { wordType: WordType.Big });\n  }\n}\n\n@RegisterAction\nclass MovePreviousSentenceBegin extends BaseMovement {\n  keys = ['('];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getSentenceBegin({ forward: false });\n  }\n}\n\n@RegisterAction\nclass GoToOffset extends BaseMovement {\n  keys = ['g', 'o'];\n  override isJump = true;\n\n  public override async execActionWithCount(position: Position, vimState: VimState, count: number) {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return vimState.document.positionAt((count || 1) - 1);\n  }\n}\n\n@RegisterAction\nclass MoveNextSentenceBegin extends BaseMovement {\n  keys = [')'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getSentenceBegin({ forward: true });\n  }\n}\n\n@RegisterAction\nclass MoveParagraphEnd extends BaseMovement {\n  keys = ['}'];\n  override isJump = true;\n  iteration = 0;\n  isFirstLineWise = false;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const hasOperator = vimState.recordedState.operator;\n    const paragraphEnd = getCurrentParagraphEnd(position);\n\n    if (hasOperator) {\n      /**\n       * When paired with an `operator` and a `count` this move will be executed\n       * multiple times which could cause issues like https://github.com/VSCodeVim/Vim/issues/4488\n       * because subsequent runs will receive back whatever position we return\n       * (See comment in `BaseMotion.execActionWithCount()`).\n       *\n       * We keep track of the iteration we are in, this way we can\n       * return the correct position when on the last iteration, and we don't\n       * accidentally set the `registerMode` incorrectly.\n       */\n      this.iteration++;\n\n      const isLineWise = position.isLineBeginning() && vimState.currentMode === Mode.Normal;\n\n      // TODO: `execAction` receives `firstIteration` and `lastIteration` - don't reinvent the wheel\n      const isLastIteration = vimState.recordedState.count\n        ? vimState.recordedState.count === this.iteration\n        : true;\n\n      /**\n       * `position` may not represent the position of the cursor from which the command was initiated.\n       * In the case that we will be repeating this move more than once\n       * we want to respect whether the starting position was at the beginning of line or not.\n       */\n      this.isFirstLineWise = this.iteration === 1 ? isLineWise : this.isFirstLineWise;\n\n      vimState.currentRegisterMode = this.isFirstLineWise ? RegisterMode.LineWise : undefined;\n\n      /**\n       * `paragraphEnd` is the first blank line after the last word in the\n       * current paragraph, we want the position just before that one to\n       * accurately emulate Vim's behaviour, unless we are at EOF.\n       */\n      return isLastIteration && !paragraphEnd.isAtDocumentEnd()\n        ? paragraphEnd.getLeftThroughLineBreaks(true)\n        : paragraphEnd;\n    }\n\n    return paragraphEnd;\n  }\n}\n\n@RegisterAction\nclass MoveParagraphBegin extends BaseMovement {\n  keys = ['{'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return getCurrentParagraphBeginning(position);\n  }\n}\n\nabstract class MoveSectionBoundary extends BaseMovement {\n  abstract begin: boolean;\n  abstract forward: boolean;\n  override isJump = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const document = vimState.document;\n\n    switch (document.languageId) {\n      case 'python':\n        return PythonDocument.moveClassBoundary(\n          document,\n          position,\n          vimState,\n          this.forward,\n          this.begin\n        );\n    }\n\n    const boundary = this.begin ? '{' : '}';\n    let line = position.line;\n\n    if (\n      (this.forward && line === vimState.document.lineCount - 1) ||\n      (!this.forward && line === 0)\n    ) {\n      return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n    }\n\n    line = this.forward ? line + 1 : line - 1;\n\n    while (!vimState.document.lineAt(line).text.startsWith(boundary)) {\n      if (this.forward) {\n        if (line === vimState.document.lineCount - 1) {\n          break;\n        }\n\n        line++;\n      } else {\n        if (line === 0) {\n          break;\n        }\n\n        line--;\n      }\n    }\n\n    return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n  }\n}\n\n@RegisterAction\nclass MoveNextSectionBegin extends MoveSectionBoundary {\n  keys = [']', ']'];\n  begin = true;\n  forward = true;\n}\n\n@RegisterAction\nclass MoveNextSectionEnd extends MoveSectionBoundary {\n  keys = [']', '['];\n  begin = false;\n  forward = true;\n}\n\n@RegisterAction\nclass MovePreviousSectionBegin extends MoveSectionBoundary {\n  keys = ['[', '['];\n  begin = true;\n  forward = false;\n}\n\n@RegisterAction\nclass MovePreviousSectionEnd extends MoveSectionBoundary {\n  keys = ['[', ']'];\n  begin = false;\n  forward = false;\n}\n\n@RegisterAction\nclass MoveToMatchingBracket extends BaseMovement {\n  keys = ['%'];\n  override isJump = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    position = position.getLeftIfEOL();\n\n    const lineText = vimState.document.lineAt(position).text;\n    const failure = failedMovement(vimState);\n\n    for (let col = position.character; col < lineText.length; col++) {\n      const currentChar = lineText[col];\n      const pairing = PairMatcher.getPercentPairing(currentChar);\n\n      // we need to check pairing, because with text: bla |bla < blub > blub\n      // this for loop will walk over bla and check for a pairing till it finds <\n      if (pairing) {\n        // We found an opening char, now move to the matching closing char\n        return (\n          PairMatcher.nextPairedChar(\n            new Position(position.line, col),\n            lineText[col],\n            vimState,\n            false\n          ) || failure\n        );\n      }\n    }\n\n    // No matchable character on the line; admit defeat\n    return failure;\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const result = await this.execAction(position, vimState);\n\n    if (isIMovement(result)) {\n      if (result.failed) {\n        return result;\n      } else {\n        throw new Error('Did not ever handle this case!');\n      }\n    }\n\n    if (position.isAfter(result)) {\n      return {\n        start: result,\n        stop: position.getRight(),\n      };\n    } else {\n      return result.getRight();\n    }\n  }\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    // % has a special mode that lets you use it to jump to a percentage of the file\n    // However, some other bracket motions inherit from this so only do this behavior for % explicitly\n    if (Object.getPrototypeOf(this) === MoveToMatchingBracket.prototype) {\n      if (count === 0) {\n        if (vimState.recordedState.operator) {\n          return this.execActionForOperator(position, vimState);\n        } else {\n          return this.execAction(position, vimState);\n        }\n      }\n\n      // Check to make sure this is a valid percentage\n      if (count < 0 || count > 100) {\n        return failedMovement(vimState);\n      }\n\n      // See `:help N%`\n      const targetLine = Math.trunc((count * vimState.document.lineCount + 99) / 100) - 1;\n\n      return position.with({ line: targetLine }).obeyStartOfLine(vimState.document);\n    } else {\n      return super.execActionWithCount(position, vimState, count);\n    }\n  }\n}\n\nexport abstract class MoveInsideCharacter extends ExpandingSelection {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  protected abstract charToMatch: string;\n\n  /** True for \"around\" actions, such as `a(`, and false for \"inside\" actions, such as `i(`  */\n  protected includeSurrounding = false;\n  override isJump = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<IMovement> {\n    const closingChar = PairMatcher.pairings[this.charToMatch].match;\n    const [selStart, selEnd] = sorted(vimState.cursorStartPosition, position);\n\n    // First, search backwards for the opening character of the sequence\n    let openPos = PairMatcher.nextPairedChar(selStart, closingChar, vimState, true);\n    if (openPos === undefined) {\n      return failedMovement(vimState);\n    }\n\n    // Next, search forwards for the closing character which matches\n    let closePos = PairMatcher.nextPairedChar(openPos, this.charToMatch, vimState, true);\n    if (closePos === undefined) {\n      return failedMovement(vimState);\n    }\n\n    if (\n      !this.includeSurrounding &&\n      (isVisualMode(vimState.currentMode) || !firstIteration) &&\n      selStart.getLeftThroughLineBreaks(false).isBeforeOrEqual(openPos) &&\n      selEnd.getRightThroughLineBreaks(false).isAfterOrEqual(closePos)\n    ) {\n      // Special case: inner, with all inner content already selected\n      const outerOpenPos = PairMatcher.nextPairedChar(openPos, closingChar, vimState, false);\n      const outerClosePos = outerOpenPos\n        ? PairMatcher.nextPairedChar(outerOpenPos, this.charToMatch, vimState, false)\n        : undefined;\n\n      if (outerOpenPos && outerClosePos) {\n        openPos = outerOpenPos;\n        closePos = outerClosePos;\n      }\n    }\n\n    if (this.includeSurrounding) {\n      if (vimState.currentMode !== Mode.Visual) {\n        closePos = new Position(closePos.line, closePos.character + 1);\n      }\n    } else {\n      openPos = openPos.getRightThroughLineBreaks();\n      // If the closing character is the first on the line, don't swallow it.\n      if (closePos.isInLeadingWhitespace(vimState.document)) {\n        closePos = closePos.getLineBegin();\n      }\n\n      if (vimState.currentMode === Mode.Visual) {\n        closePos = closePos.getLeftThroughLineBreaks();\n      }\n    }\n\n    if (lastIteration && !isVisualMode(vimState.currentMode) && selStart.isBefore(openPos)) {\n      vimState.recordedState.operatorPositionDiff = openPos.subtract(selStart);\n    }\n\n    // TODO: setting the cursor manually like this shouldn't be necessary (probably a Cursor, not Position, should be passed to `exec`)\n    vimState.cursorStartPosition = openPos;\n    return {\n      start: openPos,\n      stop: closePos,\n    };\n  }\n}\n\n@RegisterAction\nclass MoveInsideParentheses extends MoveInsideCharacter {\n  keys = [\n    ['i', '('],\n    ['i', ')'],\n    ['i', 'b'],\n  ];\n  charToMatch = '(';\n}\n\n@RegisterAction\nexport class MoveAroundParentheses extends MoveInsideCharacter {\n  keys = [\n    ['a', '('],\n    ['a', ')'],\n    ['a', 'b'],\n  ];\n  charToMatch = '(';\n  override includeSurrounding = true;\n}\n\n@RegisterAction\nclass MoveInsideCurlyBrace extends MoveInsideCharacter {\n  keys = [\n    ['i', '{'],\n    ['i', '}'],\n    ['i', 'B'],\n  ];\n  charToMatch = '{';\n}\n\n@RegisterAction\nexport class MoveAroundCurlyBrace extends MoveInsideCharacter {\n  keys = [\n    ['a', '{'],\n    ['a', '}'],\n    ['a', 'B'],\n  ];\n  charToMatch = '{';\n  override includeSurrounding = true;\n}\n\n@RegisterAction\nclass MoveInsideCaret extends MoveInsideCharacter {\n  keys = [\n    ['i', '<'],\n    ['i', '>'],\n  ];\n  charToMatch = '<';\n}\n\n@RegisterAction\nexport class MoveAroundCaret extends MoveInsideCharacter {\n  keys = [\n    ['a', '<'],\n    ['a', '>'],\n  ];\n  charToMatch = '<';\n  override includeSurrounding = true;\n}\n\n@RegisterAction\nclass MoveInsideSquareBracket extends MoveInsideCharacter {\n  keys = [\n    ['i', '['],\n    ['i', ']'],\n  ];\n  charToMatch = '[';\n}\n\n@RegisterAction\nexport class MoveAroundSquareBracket extends MoveInsideCharacter {\n  keys = [\n    ['a', '['],\n    ['a', ']'],\n  ];\n  charToMatch = '[';\n  override includeSurrounding = true;\n}\n\n// TODO: Shouldn't this be a TextObject? A clearer delineation between motions and objects should be made.\nexport abstract class MoveQuoteMatch extends BaseMovement {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  protected abstract readonly charToMatch: '\"' | \"'\" | '`';\n  protected includeQuotes = false;\n  override isJump = true;\n\n  // HACK: surround uses these classes, but does not want trailing whitespace to be included\n  private adjustForTrailingWhitespace: boolean = true;\n\n  constructor(adjustForTrailingWhitespace: boolean = true) {\n    super();\n    this.adjustForTrailingWhitespace = adjustForTrailingWhitespace;\n  }\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<IMovement> {\n    // TODO: this is super janky\n    return (await super.execActionWithCount(position, vimState, 1)) as IMovement;\n  }\n\n  public override async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    if (\n      !this.includeQuotes &&\n      (vimState.recordedState.count > 1 || vimState.recordedState.operatorCount > 1)\n    ) {\n      // i\" special case: With a count of 2 the quotes are included, but no extra white space as with a\"/a'/a`.\n      // (a\" does not make use of count)\n      this.includeQuotes = true;\n      this.adjustForTrailingWhitespace = false;\n    }\n\n    const text = vimState.document.lineAt(position).text;\n    const quoteMatcher = new QuoteMatcher(this.charToMatch, text);\n    const quoteIndices = quoteMatcher.surroundingQuotes(position.character);\n    if (quoteIndices === undefined) {\n      return failedMovement(vimState);\n    }\n\n    let [start, end] = quoteIndices;\n\n    if (!this.includeQuotes) {\n      // Don't include the quotes\n      start++;\n      end--;\n    } else if (this.adjustForTrailingWhitespace) {\n      // Include trailing whitespace if there is any...\n      const trailingWhitespace = text.substring(end + 1).search(/\\S|$/);\n      if (trailingWhitespace > 0) {\n        end += trailingWhitespace;\n      } else {\n        // ...otherwise include leading whitespace\n        start = text.substring(0, start).search(/\\s*$/);\n      }\n    }\n\n    const startPos = new Position(position.line, start);\n    const endPos = new Position(position.line, end);\n\n    if (!isVisualMode(vimState.currentMode) && position.isBefore(startPos)) {\n      vimState.recordedState.operatorPositionDiff = startPos.subtract(position);\n    }\n\n    return {\n      start: startPos,\n      stop: endPos,\n    };\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const result = await this.execAction(position, vimState);\n    if (isIMovement(result)) {\n      if (result.failed) {\n        vimState.recordedState.hasRunOperator = false;\n        vimState.recordedState.actionsRun = [];\n      } else {\n        result.stop = result.stop.getRight();\n      }\n    }\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveInsideSingleQuotes extends MoveQuoteMatch {\n  keys = ['i', \"'\"];\n  readonly charToMatch = \"'\";\n  override includeQuotes = false;\n}\n\n@RegisterAction\nexport class MoveAroundSingleQuotes extends MoveQuoteMatch {\n  keys = ['a', \"'\"];\n  readonly charToMatch = \"'\";\n  override includeQuotes = true;\n}\n\n@RegisterAction\nclass MoveInsideDoubleQuotes extends MoveQuoteMatch {\n  keys = ['i', '\"'];\n  readonly charToMatch = '\"';\n  override includeQuotes = false;\n}\n\n@RegisterAction\nexport class MoveAroundDoubleQuotes extends MoveQuoteMatch {\n  keys = ['a', '\"'];\n  readonly charToMatch = '\"';\n  override includeQuotes = true;\n}\n\n@RegisterAction\nclass MoveInsideBacktick extends MoveQuoteMatch {\n  keys = ['i', '`'];\n  readonly charToMatch = '`';\n  override includeQuotes = false;\n}\n\n@RegisterAction\nexport class MoveAroundBacktick extends MoveQuoteMatch {\n  keys = ['a', '`'];\n  readonly charToMatch = '`';\n  override includeQuotes = true;\n}\n\n@RegisterAction\nclass MoveToUnclosedRoundBracketBackward extends MoveToMatchingBracket {\n  override keys = ['[', '('];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const charToMatch = ')';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveToUnclosedRoundBracketForward extends MoveToMatchingBracket {\n  override keys = [']', ')'];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const charToMatch = '(';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (\n      vimState.recordedState.operator instanceof ChangeOperator ||\n      vimState.recordedState.operator instanceof DeleteOperator ||\n      vimState.recordedState.operator instanceof YankOperator\n    ) {\n      return result.getLeftThroughLineBreaks();\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveToUnclosedCurlyBracketBackward extends MoveToMatchingBracket {\n  override keys = ['[', '{'];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const charToMatch = '}';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveToUnclosedCurlyBracketForward extends MoveToMatchingBracket {\n  override keys = [']', '}'];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const charToMatch = '{';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (\n      vimState.recordedState.operator instanceof ChangeOperator ||\n      vimState.recordedState.operator instanceof DeleteOperator ||\n      vimState.recordedState.operator instanceof YankOperator\n    ) {\n      return result.getLeftThroughLineBreaks();\n    }\n\n    return result;\n  }\n}\n\nabstract class MoveTagMatch extends ExpandingSelection {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  protected includeTag = false;\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const editorText = vimState.document.getText();\n    const offset = vimState.document.offsetAt(position);\n    const tagMatcher = new TagMatcher(editorText, offset, vimState);\n    const start = tagMatcher.findOpening(this.includeTag);\n    const end = tagMatcher.findClosing(this.includeTag);\n\n    if (start === undefined || end === undefined) {\n      return failedMovement(vimState);\n    }\n\n    const startPosition =\n      start >= 0 ? vimState.document.positionAt(start) : vimState.cursorStartPosition;\n    let endPosition = end >= 0 ? vimState.document.positionAt(end) : position;\n    if (vimState.currentMode === Mode.Visual || vimState.currentMode === Mode.SurroundInputMode) {\n      endPosition = endPosition.getLeftThroughLineBreaks();\n    }\n\n    if (position.isAfter(endPosition)) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'moveCursor',\n        diff: endPosition.subtract(position),\n      });\n    } else if (position.isBefore(startPosition)) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'moveCursor',\n        diff: startPosition.subtract(position),\n      });\n    }\n    // if (start === end) {\n    //   if (vimState.recordedState.operator instanceof ChangeOperator) {\n    //     await vimState.setCurrentMode(ModeName.Insert);\n    //   }\n    //   return failedMovement(vimState);\n    // }\n    vimState.cursorStartPosition = startPosition;\n    return {\n      start: startPosition,\n      stop: endPosition,\n    };\n  }\n}\n\n@RegisterAction\nexport class MoveInsideTag extends MoveTagMatch {\n  keys = ['i', 't'];\n  override includeTag = false;\n}\n\n@RegisterAction\nexport class MoveAroundTag extends MoveTagMatch {\n  keys = ['a', 't'];\n  override includeTag = true;\n}\n","import * as vscode from 'vscode';\n\nimport { PositionDiff, earlierOf, sorted } from './../common/motion/position';\nimport { configuration } from './../configuration/configuration';\nimport { Mode, isVisualMode } from './../mode/mode';\nimport { Register, RegisterMode } from './../register/register';\nimport { VimState } from './../state/vimState';\nimport { TextEditor } from './../textEditor';\nimport { BaseAction, RegisterAction } from './base';\nimport { CommandNumber } from './commands/actions';\nimport { reportLinesChanged, reportLinesYanked } from '../util/statusBarTextUtils';\nimport { commandLine } from './../cmd_line/commandLine';\nimport { Position } from 'vscode';\n\nexport abstract class BaseOperator extends BaseAction {\n  override isOperator = true;\n\n  constructor(multicursorIndex?: number) {\n    super();\n    this.multicursorIndex = multicursorIndex;\n  }\n  override canBeRepeatedWithDot = true;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (this.doesRepeatedOperatorApply(vimState, keysPressed)) {\n      return true;\n    }\n    if (!this.modes.includes(vimState.currentMode)) {\n      return false;\n    }\n    if (!BaseAction.CompareKeypressSequence(this.keys, keysPressed)) {\n      return false;\n    }\n    if (this instanceof BaseOperator && vimState.recordedState.operator) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (!this.modes.includes(vimState.currentMode)) {\n      return false;\n    }\n    if (!BaseAction.CompareKeypressSequence(this.keys.slice(0, keysPressed.length), keysPressed)) {\n      return false;\n    }\n    if (this instanceof BaseOperator && vimState.recordedState.operator) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public doesRepeatedOperatorApply(vimState: VimState, keysPressed: string[]) {\n    const nonCountActions = vimState.recordedState.actionsRun.filter(\n      (x) => !(x instanceof CommandNumber)\n    );\n    const prevAction = nonCountActions[nonCountActions.length - 1];\n    return (\n      keysPressed.length === 1 &&\n      prevAction &&\n      this.modes.includes(vimState.currentMode) &&\n      // The previous action is the same as the one we're testing\n      prevAction.constructor === this.constructor &&\n      // The key pressed is the same as the previous action's last key.\n      BaseAction.CompareKeypressSequence(prevAction.keysPressed.slice(-1), keysPressed)\n    );\n  }\n\n  /**\n   * Run this operator on a range, returning the new location of the cursor.\n   */\n  public abstract run(vimState: VimState, start: Position, stop: Position): Promise<void>;\n\n  public async runRepeat(vimState: VimState, position: Position, count: number): Promise<void> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    await this.run(\n      vimState,\n      position.getLineBegin(),\n      position.getDown(Math.max(0, count - 1)).getLineEnd()\n    );\n  }\n\n  public highlightYankedRanges(vimState: VimState, ranges: vscode.Range[]) {\n    if (!configuration.highlightedyank.enable) {\n      return;\n    }\n\n    const yankDecoration = vscode.window.createTextEditorDecorationType({\n      backgroundColor: configuration.highlightedyank.color,\n      color: configuration.highlightedyank.textColor,\n    });\n\n    vimState.editor.setDecorations(yankDecoration, ranges);\n    setTimeout(() => yankDecoration.dispose(), configuration.highlightedyank.duration);\n  }\n}\n\n@RegisterAction\nexport class DeleteOperator extends BaseOperator {\n  public keys = ['d'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // TODO: this is off by one when character-wise and not including last EOL\n    const numLinesDeleted = Math.abs(start.line - end.line) + 1;\n\n    if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      start = start.getLineBegin();\n      end = end.getLineEnd();\n    }\n\n    end = new Position(end.line, end.character + 1);\n\n    const isOnLastLine = end.line === vimState.document.lineCount - 1;\n\n    // Vim does this weird thing where it allows you to select and delete\n    // the newline character, which it places 1 past the last character\n    // in the line. Here we interpret a character position 1 past the end\n    // as selecting the newline character. Don't allow this in visual block mode\n    if (\n      vimState.currentMode !== Mode.VisualBlock &&\n      !isOnLastLine &&\n      end.character === vimState.document.lineAt(end).text.length + 1\n    ) {\n      end = new Position(end.line + 1, 0);\n    }\n\n    // Yank the text\n    let text = vimState.document.getText(new vscode.Range(start, end));\n    if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      // When deleting linewise, exclude final newline\n      text = text.endsWith('\\r\\n')\n        ? text.slice(0, -2)\n        : text.endsWith('\\n')\n        ? text.slice(0, -1)\n        : text;\n    }\n    Register.put(vimState, text, this.multicursorIndex, true);\n\n    // When deleting the last line linewise, we need to delete the newline\n    // character BEFORE the range because there isn't one after the range.\n    if (\n      isOnLastLine &&\n      start.line !== 0 &&\n      vimState.currentRegisterMode === RegisterMode.LineWise\n    ) {\n      start = start.getUp().getLineEnd();\n    }\n\n    let diff: PositionDiff | undefined;\n    if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      diff = PositionDiff.startOfLine();\n    } else if (start.character > vimState.document.lineAt(start).text.length) {\n      diff = PositionDiff.offset({ character: -1 });\n    }\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'deleteRange',\n      range: new vscode.Range(start, end),\n      diff,\n    });\n\n    await vimState.setCurrentMode(Mode.Normal);\n\n    reportLinesChanged(-numLinesDeleted, vimState);\n  }\n}\n\n@RegisterAction\nclass DeleteOperatorVisual extends BaseOperator {\n  public keys = ['D'];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // ensures linewise deletion when in visual mode\n    // see special case in DeleteOperator.delete()\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    await new DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nexport class YankOperator extends BaseOperator {\n  public keys = ['y'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  override canBeRepeatedWithDot = false;\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    [start, end] = sorted(start, end);\n    let extendedEnd = new Position(end.line, end.character + 1);\n\n    if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      start = start.getLineBegin();\n      extendedEnd = extendedEnd.getLineEnd();\n    }\n\n    const range = new vscode.Range(start, extendedEnd);\n    let text = vimState.document.getText(range);\n\n    // If we selected the newline character, add it as well.\n    if (\n      vimState.currentMode === Mode.Visual &&\n      extendedEnd.character === vimState.document.lineAt(extendedEnd).text.length + 1\n    ) {\n      text = text + '\\n';\n    }\n\n    this.highlightYankedRanges(vimState, [range]);\n\n    Register.put(vimState, text, this.multicursorIndex, true);\n\n    vimState.cursorStopPosition =\n      vimState.currentMode === Mode.Normal && vimState.currentRegisterMode === RegisterMode.LineWise\n        ? start.with({ character: vimState.cursorStopPosition.character })\n        : start;\n\n    await vimState.setCurrentMode(Mode.Normal);\n\n    const numLinesYanked = text.split('\\n').length;\n    reportLinesYanked(numLinesYanked, vimState);\n  }\n}\n\n@RegisterAction\nclass FilterOperator extends BaseOperator {\n  public keys = ['!'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    [start, end] = sorted(start, end);\n\n    if (vimState.currentMode === Mode.Normal && start.line === end.line) {\n      vimState.currentCommandlineText = '.!';\n    } else if (vimState.currentMode === Mode.Normal && start.line !== end.line) {\n      vimState.currentCommandlineText = `.,.+${end.line - start.line}!`;\n    } else {\n      vimState.currentCommandlineText = \"'<,'>!\";\n    }\n\n    vimState.cursorStartPosition = start;\n    if (vimState.currentMode === Mode.Normal) {\n      vimState.cursorStopPosition = start;\n    } else {\n      vimState.cursors = vimState.cursorsInitialState;\n    }\n\n    // Initialize the cursor position\n    vimState.statusBarCursorCharacterPos = vimState.currentCommandlineText.length;\n    // Store the current mode for use in retaining selection\n    commandLine.previousMode = vimState.currentMode;\n    // Change to the new mode\n    await vimState.setCurrentMode(Mode.CommandlineInProgress);\n    // Reset history navigation index\n    commandLine.commandLineHistoryIndex = commandLine.historyEntries.length;\n  }\n}\n\n@RegisterAction\nclass ShiftYankOperatorVisual extends BaseOperator {\n  public keys = ['Y'];\n  public modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    await new YankOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nclass DeleteOperatorXVisual extends BaseOperator {\n  public keys = [['x'], ['<Del>']];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    await new DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nclass ChangeOperatorSVisual extends BaseOperator {\n  public keys = ['s'];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  // Don't clash with Sneak plugin\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && !configuration.sneak;\n  }\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    await new ChangeOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nclass FormatOperator extends BaseOperator {\n  public keys = ['='];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // = operates on complete lines\n    vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n    await vscode.commands.executeCommand('editor.action.formatSelection');\n    let line = vimState.cursorStartPosition.line;\n\n    if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n      line = vimState.cursorStopPosition.line;\n    }\n\n    const newCursorPosition = TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n    vimState.cursorStopPosition = newCursorPosition;\n    vimState.cursorStartPosition = newCursorPosition;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\nabstract class ChangeCaseOperator extends BaseOperator {\n  public modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  abstract transformText(text: string): string;\n\n  public async run(vimState: VimState, startPos: Position, endPos: Position): Promise<void> {\n    if (vimState.currentMode === Mode.VisualBlock) {\n      for (const { start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n        const range = new vscode.Range(start, end);\n        vimState.recordedState.transformer.replace(\n          range,\n          this.transformText(vimState.document.getText(range))\n        );\n      }\n\n      // HACK: currently must do this nonsense to collapse all cursors into one\n      for (let i = 0; i < vimState.editor.selections.length; i++) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'moveCursor',\n          diff: PositionDiff.exactPosition(earlierOf(startPos, endPos)),\n          cursorIndex: i,\n        });\n      }\n    } else {\n      if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n        startPos = startPos.getLineBegin();\n        endPos = endPos.getLineEnd();\n      }\n\n      const range = new vscode.Range(startPos, new Position(endPos.line, endPos.character + 1));\n\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        range,\n        text: this.transformText(vimState.document.getText(range)),\n        diff: PositionDiff.exactPosition(startPos),\n      });\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass UpperCaseOperator extends ChangeCaseOperator {\n  public keys = [['g', 'U'], ['U']];\n\n  public transformText(text: string): string {\n    return text.toUpperCase();\n  }\n}\n\n@RegisterAction\nclass UpperCaseWithMotion extends UpperCaseOperator {\n  public override keys = [['g', 'U']];\n  public override modes = [Mode.Normal];\n}\n\n@RegisterAction\nclass LowerCaseOperator extends ChangeCaseOperator {\n  public keys = [['g', 'u'], ['u']];\n\n  public transformText(text: string): string {\n    return text.toLowerCase();\n  }\n}\n\n@RegisterAction\nclass LowerCaseWithMotion extends LowerCaseOperator {\n  public override keys = [['g', 'u']];\n  public override modes = [Mode.Normal];\n}\n\n@RegisterAction\nclass ToggleCaseOperator extends ChangeCaseOperator {\n  public keys = [['g', '~'], ['~']];\n\n  public transformText(text: string): string {\n    let newText = '';\n    for (const char of text) {\n      let toggled = char.toLocaleLowerCase();\n      if (toggled === char) {\n        toggled = char.toLocaleUpperCase();\n      }\n      newText += toggled;\n    }\n    return newText;\n  }\n}\n\n@RegisterAction\nclass ToggleCaseWithMotion extends ToggleCaseOperator {\n  public override keys = [['g', '~']];\n  public override modes = [Mode.Normal];\n}\n\n@RegisterAction\nclass IndentOperator extends BaseOperator {\n  modes = [Mode.Normal];\n  keys = ['>'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n\n    await vscode.commands.executeCommand('editor.action.indentLines');\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = start.obeyStartOfLine(vimState.document);\n  }\n}\n\n/**\n * `3>` to indent a line 3 times in visual mode is actually a bit of a special case.\n *\n * > is an operator, and generally speaking, you don't run operators multiple times, you run motions multiple times.\n * e.g. `d3w` runs `w` 3 times, then runs d once.\n *\n * Same with literally every other operator motion combination... until `3>`in visual mode\n * walked into my life.\n */\n@RegisterAction\nclass IndentOperatorInVisualModesIsAWeirdSpecialCase extends BaseOperator {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['>'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // Repeating this command with dot should apply the indent to the previous selection\n    if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n      if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n        const shiftSelectionByNum =\n          vimState.dotCommandPreviousVisualSelection.end.line -\n          vimState.dotCommandPreviousVisualSelection.start.line;\n\n        start = vimState.cursorStartPosition;\n        const newEnd = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n\n        vimState.editor.selection = new vscode.Selection(start, newEnd);\n      }\n    }\n\n    for (let i = 0; i < (vimState.recordedState.count || 1); i++) {\n      await vscode.commands.executeCommand('editor.action.indentLines');\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = start.obeyStartOfLine(vimState.document);\n  }\n}\n\n@RegisterAction\nclass OutdentOperator extends BaseOperator {\n  modes = [Mode.Normal];\n  keys = ['<'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.editor.selection = new vscode.Selection(start, end.getLineEnd());\n\n    await vscode.commands.executeCommand('editor.action.outdentLines');\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      start.line\n    );\n  }\n}\n\n/**\n * See comment for IndentOperatorInVisualModesIsAWeirdSpecialCase\n */\n@RegisterAction\nclass OutdentOperatorInVisualModesIsAWeirdSpecialCase extends BaseOperator {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['<'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // Repeating this command with dot should apply the indent to the previous selection\n    if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n      if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n        const shiftSelectionByNum =\n          vimState.dotCommandPreviousVisualSelection.end.line -\n          vimState.dotCommandPreviousVisualSelection.start.line;\n\n        start = vimState.cursorStartPosition;\n        const newEnd = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n\n        vimState.editor.selection = new vscode.Selection(start, newEnd);\n      }\n    }\n\n    for (let i = 0; i < (vimState.recordedState.count || 1); i++) {\n      await vscode.commands.executeCommand('editor.action.outdentLines');\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      start.line\n    );\n  }\n}\n\n@RegisterAction\nexport class ChangeOperator extends BaseOperator {\n  public keys = ['c'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      start = start.getLineBegin();\n      end = end.getLineEnd();\n    } else if (vimState.currentMode === Mode.Visual && end.isLineEnd()) {\n      end = end.getRightThroughLineBreaks();\n    } else {\n      end = end.getRight();\n    }\n\n    const deleteRange = new vscode.Range(start, end);\n\n    Register.put(vimState, vimState.document.getText(deleteRange), this.multicursorIndex, true);\n\n    if (vimState.currentRegisterMode === RegisterMode.LineWise && configuration.autoindent) {\n      // Linewise is a bit of a special case - we want to preserve the first line's indentation,\n      // then let the language server adjust that indentation if it can.\n\n      const firstLineIndent = vimState.document.getText(\n        new vscode.Range(\n          deleteRange.start.getLineBegin(),\n          deleteRange.start.getLineBeginRespectingIndent(vimState.document)\n        )\n      );\n\n      vimState.recordedState.transformer.replace(\n        deleteRange,\n        firstLineIndent,\n        PositionDiff.exactPosition(new Position(deleteRange.start.line, firstLineIndent.length))\n      );\n\n      if (vimState.document.languageId !== 'plaintext') {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'reindent',\n          cursorIndex: this.multicursorIndex,\n          diff: PositionDiff.endOfLine(),\n        });\n      }\n    } else {\n      vimState.recordedState.transformer.delete(deleteRange);\n    }\n\n    vimState.setCurrentMode(Mode.Insert);\n  }\n}\n\n@RegisterAction\nclass YankVisualBlockMode extends BaseOperator {\n  public keys = ['y'];\n  public modes = [Mode.VisualBlock];\n  override canBeRepeatedWithDot = false;\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async run(vimState: VimState, startPos: Position, endPos: Position): Promise<void> {\n    const ranges: vscode.Range[] = [];\n    const lines: string[] = [];\n    for (const { line, start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      lines.push(line);\n      ranges.push(new vscode.Range(start, end));\n    }\n\n    vimState.currentRegisterMode = RegisterMode.BlockWise;\n\n    this.highlightYankedRanges(vimState, ranges);\n\n    Register.put(vimState, lines.join('\\n'), this.multicursorIndex, true);\n\n    vimState.historyTracker.addMark(startPos, '<');\n    vimState.historyTracker.addMark(endPos, '>');\n\n    const numLinesYanked = lines.length;\n    reportLinesYanked(numLinesYanked, vimState);\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = startPos;\n  }\n}\n\n@RegisterAction\nclass CommentOperator extends BaseOperator {\n  public keys = ['g', 'c'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n    await vscode.commands.executeCommand('editor.action.commentLine');\n\n    vimState.cursorStopPosition = new Position(start.line, 0);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class ROT13Operator extends BaseOperator {\n  public keys = ['g', '?'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    let selections: vscode.Selection[];\n    if (isVisualMode(vimState.currentMode)) {\n      selections = vimState.editor.selections;\n    } else if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      selections = [new vscode.Selection(start.getLineBegin(), end.getLineEnd())];\n    } else {\n      selections = [new vscode.Selection(start, end.getRight())];\n    }\n\n    for (const range of selections) {\n      const original = vimState.document.getText(range);\n      vimState.recordedState.transformer.replace(range, ROT13Operator.rot13(original));\n    }\n  }\n\n  /**\n   * https://en.wikipedia.org/wiki/ROT13\n   */\n  public static rot13(str: string) {\n    return str\n      .split('')\n      .map((char: string) => {\n        let charCode = char.charCodeAt(0);\n\n        if (char >= 'a' && char <= 'z') {\n          const a = 'a'.charCodeAt(0);\n          charCode = ((charCode - a + 13) % 26) + a;\n        }\n\n        if (char >= 'A' && char <= 'Z') {\n          const A = 'A'.charCodeAt(0);\n          charCode = ((charCode - A + 13) % 26) + A;\n        }\n\n        return String.fromCharCode(charCode);\n      })\n      .join('');\n  }\n}\n\n@RegisterAction\nclass CommentBlockOperator extends BaseOperator {\n  public keys = ['g', 'C'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    if (vimState.currentMode === Mode.Normal) {\n      // If we're in normal mode, we need to construct a selection for the\n      // command to operate on. If we're not, we've already got it.\n      const endPosition = end.getRight();\n      vimState.editor.selection = new vscode.Selection(start, endPosition);\n    }\n    await vscode.commands.executeCommand('editor.action.blockComment');\n\n    vimState.cursorStopPosition = start;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\ninterface CommentTypeSingle {\n  singleLine: true;\n\n  start: string;\n}\n\ninterface CommentTypeMultiLine {\n  singleLine: false;\n\n  start: string;\n  inner: string;\n  final: string;\n}\n\ntype CommentType = CommentTypeSingle | CommentTypeMultiLine;\n\n@RegisterAction\nclass ActionVisualReflowParagraph extends BaseOperator {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['g', 'q'];\n\n  public static CommentTypes: CommentType[] = [\n    { singleLine: false, start: '/**', inner: '*', final: '*/' },\n    { singleLine: false, start: '/*', inner: '*', final: '*/' },\n    { singleLine: false, start: '{-', inner: '-', final: '-}' },\n    { singleLine: true, start: '///' },\n    { singleLine: true, start: '//!' },\n    { singleLine: true, start: '//' },\n    { singleLine: true, start: '--' },\n    { singleLine: true, start: '#' },\n    { singleLine: true, start: ';' },\n    { singleLine: true, start: '*' },\n    { singleLine: true, start: '%' },\n\n    // Needs to come last, since everything starts with the empty string!\n    { singleLine: true, start: '' },\n  ];\n\n  public getIndentation(s: string): string {\n    // Use the indentation of the first non-whitespace line, if any such line is\n    // selected.\n    for (const line of s.split('\\n')) {\n      const result = line.match(/^\\s+/g);\n      const indent = result ? result[0] : '';\n\n      if (indent !== line) {\n        return indent;\n      }\n    }\n\n    return '';\n  }\n\n  public reflowParagraph(s: string): string {\n    const indent = this.getIndentation(s);\n\n    let indentLevel = 0;\n    for (const char of indent) {\n      indentLevel += char === '\\t' ? configuration.tabstop : 1;\n    }\n    const maximumLineLength = configuration.textwidth - indentLevel;\n\n    // Chunk the lines by commenting style.\n\n    interface Chunk {\n      commentType: CommentType;\n      content: string;\n      indentLevelAfterComment: number;\n      final: boolean;\n    }\n    const chunksToReflow: Chunk[] = [];\n\n    for (const line of s.split('\\n')) {\n      let lastChunk: Chunk | undefined = chunksToReflow[chunksToReflow.length - 1];\n      const trimmedLine = line.trimStart();\n\n      // See what comment type they are using.\n\n      let commentType: CommentType | undefined;\n\n      for (const type of ActionVisualReflowParagraph.CommentTypes) {\n        if (trimmedLine.startsWith(type.start)) {\n          commentType = type;\n\n          break;\n        }\n\n        // If they're currently in a multiline comment, see if they continued it.\n        if (\n          lastChunk &&\n          !lastChunk.final &&\n          type.start === lastChunk.commentType.start &&\n          !type.singleLine\n        ) {\n          if (trimmedLine.startsWith(type.inner)) {\n            commentType = type;\n\n            break;\n          }\n\n          if (trimmedLine.endsWith(type.final)) {\n            commentType = type;\n\n            break;\n          }\n        }\n      }\n\n      if (!commentType) {\n        break;\n      } // will never happen, just to satisfy typechecker.\n\n      // Did they start a new comment type?\n      if (!lastChunk || lastChunk.final || commentType.start !== lastChunk.commentType.start) {\n        const chunk = {\n          commentType,\n          content: `${trimmedLine.substr(commentType.start.length).trimStart()}`,\n          indentLevelAfterComment: 0,\n          final: false,\n        };\n        if (commentType.singleLine) {\n          chunk.indentLevelAfterComment =\n            trimmedLine.substr(commentType.start.length).length - chunk.content.length;\n        } else if (chunk.content.endsWith(commentType.final)) {\n          // Multiline comment started and ended on one line\n          chunk.content = chunk.content\n            .substr(0, chunk.content.length - commentType.final.length)\n            .trim();\n          chunk.final = true;\n        }\n        chunksToReflow.push(chunk);\n\n        continue;\n      }\n\n      // Parse out commenting style, gather words.\n\n      lastChunk = chunksToReflow[chunksToReflow.length - 1];\n\n      if (lastChunk.commentType.singleLine) {\n        // is it a continuation of a comment like \"//\"\n        lastChunk.content += `\\n${trimmedLine\n          .substr(lastChunk.commentType.start.length)\n          .trimStart()}`;\n      } else if (!lastChunk.final) {\n        // are we in the middle of a multiline comment like \"/*\"\n        if (trimmedLine.endsWith(lastChunk.commentType.final)) {\n          lastChunk.final = true;\n          const prefix = trimmedLine.startsWith(lastChunk.commentType.inner)\n            ? lastChunk.commentType.inner.length\n            : 0;\n          lastChunk.content += `\\n${trimmedLine\n            .substr(prefix, trimmedLine.length - lastChunk.commentType.final.length - prefix)\n            .trim()}`;\n        } else if (trimmedLine.startsWith(lastChunk.commentType.inner)) {\n          lastChunk.content += `\\n${trimmedLine\n            .substr(lastChunk.commentType.inner.length)\n            .trimStart()}`;\n        } else if (trimmedLine.startsWith(lastChunk.commentType.start)) {\n          lastChunk.content += `\\n${trimmedLine\n            .substr(lastChunk.commentType.start.length)\n            .trimStart()}`;\n        }\n      }\n    }\n\n    // Reflow each chunk.\n    const result: string[] = [];\n\n    for (const { commentType, content, indentLevelAfterComment } of chunksToReflow) {\n      let lines: string[];\n      const indentAfterComment = Array(indentLevelAfterComment + 1).join(' ');\n      const commentLength = commentType.start.length + indentAfterComment.length;\n\n      // Start with a single empty content line.\n      lines = [``];\n\n      for (let line of content.split('\\n')) {\n        // Preserve blank lines in output.\n        if (line.trim() === '') {\n          // Replace empty content line with blank line.\n          if (lines[lines.length - 1] === '') {\n            lines.pop();\n          }\n\n          lines.push(line);\n\n          // Add new empty content line for remaining content.\n          lines.push(``);\n\n          continue;\n        }\n\n        // Repeatedly partition line into pieces that fit in maximumLineLength\n        while (line) {\n          const lastLine = lines[lines.length - 1];\n\n          // Determine the separator that we'd need to add to the last line\n          // in order to join onto this line.\n          let separator;\n          if (!lastLine) {\n            separator = '';\n          } else if (\n            configuration.joinspaces &&\n            (lastLine.endsWith('.') || lastLine.endsWith('?') || lastLine.endsWith('!'))\n          ) {\n            separator = '  ';\n          } else if (lastLine.endsWith(' ')) {\n            if (\n              configuration.joinspaces &&\n              (lastLine.endsWith('. ') || lastLine.endsWith('? ') || lastLine.endsWith('! '))\n            ) {\n              separator = ' ';\n            } else {\n              separator = '';\n            }\n          } else {\n            separator = ' ';\n          }\n\n          // Consider appending separator and part of line to last line\n          const remaining = maximumLineLength - separator.length - lastLine.length - commentLength;\n          const trimmedLine = line.trimStart();\n          if (trimmedLine.length <= remaining) {\n            // Entire line fits on last line\n            lines[lines.length - 1] += `${separator}${trimmedLine}`;\n            break;\n          } else {\n            // Find largest portion of line that fits on last line,\n            // by searching backward for a whitespace character (space or tab).\n            let breakpoint = Math.max(\n              trimmedLine.lastIndexOf(' ', remaining),\n              trimmedLine.lastIndexOf('\\t', remaining)\n            );\n            if (breakpoint < 0) {\n              // Next word is too long to fit on the current line.\n              if (lastLine) {\n                // Start a new line and try again next round.\n                lines.push('');\n                continue;\n              } else {\n                // Next word is too long to fit on a line by itself.\n                // Break it at the next word boundary, if there is one.\n                breakpoint = trimmedLine.search(/[ \\t]/);\n                if (breakpoint < 0) breakpoint = line.length;\n              }\n            }\n\n            // Split the line into the part that fits on the last line\n            // and the remainder.  Start a new line for the remainder.\n            lines[lines.length - 1] += `${separator}${trimmedLine.slice(0, breakpoint).trimEnd()}`;\n            line = line.slice(breakpoint + 1);\n            lines.push('');\n          }\n        }\n      }\n\n      // Drop final empty content line.\n      if (lines[lines.length - 1] === '') {\n        lines.pop();\n      }\n\n      for (let i = 0; i < lines.length; i++) {\n        if (commentType.singleLine) {\n          lines[i] = `${indent}${commentType.start}${indentAfterComment}${lines[i]}`;\n        } else {\n          if (i === 0) {\n            if (lines[i] === '') {\n              lines[i] = `${indent}${commentType.start}`;\n            } else {\n              lines[i] = `${indent}${commentType.start} ${lines[i]}`;\n            }\n            if (i === lines.length - 1) {\n              lines[i] += ` ${commentType.final}`;\n            }\n          } else if (i === lines.length - 1) {\n            if (lines[i] === '') {\n              lines[i] = `${indent} ${commentType.final}`;\n            } else {\n              lines[i] = `${indent} ${commentType.inner} ${lines[i]} ${commentType.final}`;\n            }\n          } else {\n            if (lines[i] === '') {\n              lines[i] = `${indent} ${commentType.inner}`;\n            } else {\n              lines[i] = `${indent} ${commentType.inner} ${lines[i]}`;\n            }\n          }\n        }\n      }\n\n      result.push(...lines);\n    }\n\n    return result.join('\\n');\n  }\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    [start, end] = sorted(start, end);\n\n    start = start.getLineBegin();\n    end = end.getLineEnd();\n\n    let textToReflow = vimState.document.getText(new vscode.Range(start, end));\n    textToReflow = this.reflowParagraph(textToReflow);\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      text: textToReflow,\n      range: new vscode.Range(start, end),\n      // Move cursor to front of line to realign the view\n      diff: PositionDiff.exactCharacter({ character: 0 }),\n    });\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n","import { VimState } from '../../../state/vimState';\nimport { configuration } from './../../../configuration/configuration';\nimport { Mode, isVisualMode } from './../../../mode/mode';\nimport { RegisterAction, BaseCommand } from './../../base';\nimport { EasyMotion } from './easymotion';\nimport {\n  EasyMotionCharMoveOpions,\n  EasyMotionMoveOptionsBase,\n  EasyMotionWordMoveOpions,\n  EasyMotionSearchAction,\n  Match,\n  SearchOptions,\n} from './types';\nimport { globalState } from '../../../state/globalState';\nimport { TextEditor } from '../../../textEditor';\nimport { MarkerGenerator } from './markerGenerator';\nimport { Position } from 'vscode';\n\nexport interface EasymotionTrigger {\n  key: string;\n  leaderCount?: number;\n}\n\nexport function buildTriggerKeys(trigger: EasymotionTrigger) {\n  return [\n    ...Array.from({ length: trigger.leaderCount || 2 }, () => '<leader>'),\n    ...trigger.key.split(''),\n  ];\n}\n\nabstract class BaseEasyMotionCommand extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  private _baseOptions: EasyMotionMoveOptionsBase;\n\n  public abstract getMatches(position: Position, vimState: VimState): Match[];\n\n  constructor(baseOptions: EasyMotionMoveOptionsBase) {\n    super();\n    this._baseOptions = baseOptions;\n  }\n\n  public abstract resolveMatchPosition(match: Match): Position;\n\n  public processMarkers(matches: Match[], cursorPosition: Position, vimState: VimState) {\n    // Clear existing markers, just in case\n    vimState.easyMotion.clearMarkers();\n\n    let index = 0;\n    const markerGenerator = new MarkerGenerator(matches.length);\n    for (const match of matches) {\n      const matchPosition = this.resolveMatchPosition(match);\n      // Skip if the match position equals to cursor position\n      if (!matchPosition.isEqual(cursorPosition)) {\n        const marker = markerGenerator.generateMarker(index++, matchPosition);\n        if (marker) {\n          vimState.easyMotion.addMarker(marker);\n        }\n      }\n    }\n  }\n\n  protected searchOptions(position: Position): SearchOptions {\n    switch (this._baseOptions.searchOptions) {\n      case 'min':\n        return { min: position };\n      case 'max':\n        return { max: position };\n      default:\n        return {};\n    }\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // Only execute the action if the configuration is set\n    if (configuration.easymotion) {\n      // Search all occurences of the character pressed\n      const matches = this.getMatches(position, vimState);\n\n      // If previous mode was visual, restore visual selection\n      if (isVisualMode(vimState.easyMotion.previousMode)) {\n        vimState.cursorStartPosition = vimState.lastVisualSelection!.start;\n        vimState.cursorStopPosition = vimState.lastVisualSelection!.end;\n      }\n\n      // Stop if there are no matches\n      if (matches.length > 0) {\n        vimState.easyMotion = new EasyMotion();\n        this.processMarkers(matches, position, vimState);\n\n        if (matches.length === 1) {\n          // Only one found, navigate to it\n          const marker = vimState.easyMotion.markers[0];\n          // Set cursor position based on marker entered\n          vimState.cursorStopPosition = marker.position;\n          vimState.easyMotion.clearDecorations(vimState.editor);\n        } else {\n          // Store mode to return to after performing easy motion\n          vimState.easyMotion.previousMode = vimState.currentMode;\n          // Enter the EasyMotion mode and await further keys\n          await vimState.setCurrentMode(Mode.EasyMotionMode);\n        }\n      }\n    }\n  }\n}\n\nfunction getMatchesForString(\n  position: Position,\n  vimState: VimState,\n  searchString: string,\n  options?: SearchOptions\n): Match[] {\n  switch (searchString) {\n    case '':\n      return [];\n    case ' ':\n      // Searching for space should only find the first space\n      return vimState.easyMotion.sortedSearch(\n        vimState.document,\n        position,\n        new RegExp(' {1,}', 'g'),\n        options\n      );\n    default:\n      // Search all occurences of the character pressed\n\n      // If the input is not a letter, treating it as regex can cause issues\n      if (!/[a-zA-Z]/.test(searchString)) {\n        return vimState.easyMotion.sortedSearch(vimState.document, position, searchString, options);\n      }\n\n      const ignorecase =\n        configuration.ignorecase && !(configuration.smartcase && /[A-Z]/.test(searchString));\n      const regexFlags = ignorecase ? 'gi' : 'g';\n      return vimState.easyMotion.sortedSearch(\n        vimState.document,\n        position,\n        new RegExp(searchString, regexFlags),\n        options\n      );\n  }\n}\n\nexport class SearchByCharCommand extends BaseEasyMotionCommand implements EasyMotionSearchAction {\n  keys = [];\n  public searchString: string = '';\n  private _options: EasyMotionCharMoveOpions;\n\n  get searchCharCount() {\n    return this._options.charCount;\n  }\n\n  constructor(options: EasyMotionCharMoveOpions) {\n    super(options);\n    this._options = options;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return getMatchesForString(position, vimState, this.searchString, this.searchOptions(position));\n  }\n\n  public shouldFire() {\n    const charCount = this._options.charCount;\n    return charCount ? this.searchString.length >= charCount : true;\n  }\n\n  public async fire(position: Position, vimState: VimState): Promise<void> {\n    await this.exec(position, vimState);\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    const { line, character } = match.position;\n    switch (this._options.labelPosition) {\n      case 'after':\n        return new Position(line, character + this._options.charCount);\n      case 'before':\n        return new Position(line, Math.max(0, character - 1));\n      default:\n        return match.position;\n    }\n  }\n}\n\nexport class SearchByNCharCommand extends BaseEasyMotionCommand implements EasyMotionSearchAction {\n  keys = [];\n  public searchString: string = '';\n\n  get searchCharCount() {\n    return -1;\n  }\n\n  constructor() {\n    super({});\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    return match.position;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return getMatchesForString(\n      position,\n      vimState,\n      this.removeTrailingLineBreak(this.searchString),\n      {}\n    );\n  }\n\n  private removeTrailingLineBreak(s: string) {\n    return s.replace(new RegExp('\\n+$', 'g'), '');\n  }\n\n  public shouldFire() {\n    // Fire when <CR> typed\n    return this.searchString.endsWith('\\n');\n  }\n\n  public async fire(position: Position, vimState: VimState): Promise<void> {\n    if (this.removeTrailingLineBreak(this.searchString) !== '') {\n      await this.exec(position, vimState);\n    }\n  }\n}\n\nexport abstract class EasyMotionCharMoveCommandBase extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  private _action: EasyMotionSearchAction;\n\n  constructor(action: EasyMotionSearchAction) {\n    super();\n    this._action = action;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // Only execute the action if easymotion is enabled\n    if (configuration.easymotion) {\n      vimState.easyMotion = new EasyMotion();\n      vimState.easyMotion.previousMode = vimState.currentMode;\n      vimState.easyMotion.searchAction = this._action;\n      globalState.hl = true;\n\n      await vimState.setCurrentMode(Mode.EasyMotionInputMode);\n    }\n  }\n}\n\nexport abstract class EasyMotionWordMoveCommandBase extends BaseEasyMotionCommand {\n  private _options: EasyMotionWordMoveOpions;\n\n  constructor(options: EasyMotionWordMoveOpions = {}) {\n    super(options);\n    this._options = options;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return this.getMatchesForWord(position, vimState, this.searchOptions(position));\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    const { line, character } = match.position;\n    switch (this._options.labelPosition) {\n      case 'after':\n        return new Position(line, character + match.text.length - 1);\n      default:\n        return match.position;\n    }\n  }\n\n  private getMatchesForWord(\n    position: Position,\n    vimState: VimState,\n    options?: SearchOptions\n  ): Match[] {\n    const regex = this._options.jumpToAnywhere\n      ? new RegExp(configuration.easymotionJumpToAnywhereRegex, 'g')\n      : new RegExp('\\\\w{1,}', 'g');\n    return vimState.easyMotion.sortedSearch(vimState.document, position, regex, options);\n  }\n}\n\nexport abstract class EasyMotionLineMoveCommandBase extends BaseEasyMotionCommand {\n  private _options: EasyMotionMoveOptionsBase;\n\n  constructor(options: EasyMotionMoveOptionsBase = {}) {\n    super(options);\n    this._options = options;\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    return match.position;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return this.getMatchesForLineStart(position, vimState, this.searchOptions(position));\n  }\n\n  private getMatchesForLineStart(\n    position: Position,\n    vimState: VimState,\n    options?: SearchOptions\n  ): Match[] {\n    // Search for the beginning of all non whitespace chars on each line before the cursor\n    const matches = vimState.easyMotion.sortedSearch(\n      vimState.document,\n      position,\n      new RegExp('^.', 'gm'),\n      options\n    );\n    for (const match of matches) {\n      match.position = TextEditor.getFirstNonWhitespaceCharOnLine(\n        vimState.document,\n        match.position.line\n      );\n    }\n    return matches;\n  }\n}\n\n@RegisterAction\nclass EasyMotionCharInputMode extends BaseCommand {\n  modes = [Mode.EasyMotionInputMode];\n  keys = ['<character>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    const action = vimState.easyMotion.searchAction;\n    action.searchString =\n      key === '<BS>' || key === '<S-BS>'\n        ? action.searchString.slice(0, -1)\n        : action.searchString + key;\n    if (action.shouldFire()) {\n      // Skip Easymotion input mode to make sure not to back to it\n      await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n      await action.fire(vimState.cursorStopPosition, vimState);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandEscEasyMotionCharInputMode extends BaseCommand {\n  modes = [Mode.EasyMotionInputMode];\n  keys = ['<Esc>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass MoveEasyMotion extends BaseCommand {\n  modes = [Mode.EasyMotionMode];\n  keys = ['<character>'];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    if (key) {\n      // \"nail\" refers to the accumulated depth keys\n      const nail = vimState.easyMotion.accumulation + key;\n      vimState.easyMotion.accumulation = nail;\n\n      // Find markers starting with \"nail\"\n      const markers = vimState.easyMotion.findMarkers(nail, true);\n\n      // If previous mode was visual, restore visual selection\n      if (isVisualMode(vimState.easyMotion.previousMode)) {\n        vimState.cursorStartPosition = vimState.lastVisualSelection!.start;\n        vimState.cursorStopPosition = vimState.lastVisualSelection!.end;\n      }\n\n      if (markers.length === 1) {\n        // Only one found, navigate to it\n        const marker = markers[0];\n\n        vimState.easyMotion.clearDecorations(vimState.editor);\n        // Restore the mode from before easy motion\n        await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n\n        // Set cursor position based on marker entered\n        vimState.cursorStopPosition = marker.position;\n      } else if (markers.length === 0) {\n        // None found, exit mode\n        vimState.easyMotion.clearDecorations(vimState.editor);\n        await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n      }\n    }\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { configuration } from './../../../configuration/configuration';\nimport { TextEditor } from './../../../textEditor';\nimport { IEasyMotion, EasyMotionSearchAction, Marker, Match, SearchOptions } from './types';\nimport { Mode } from '../../../mode/mode';\nimport { Position } from 'vscode';\n\nexport class EasyMotion implements IEasyMotion {\n  /**\n   * Refers to the accumulated keys for depth navigation\n   */\n  public accumulation = '';\n\n  // TODO: is this actually always set?\n  public searchAction!: EasyMotionSearchAction;\n\n  /**\n   * Array of all markers and decorations\n   */\n  public readonly markers: Marker[];\n\n  private visibleMarkers: Marker[]; // Array of currently showing markers\n  private decorations: vscode.DecorationOptions[][];\n\n  private static readonly fade = vscode.window.createTextEditorDecorationType({\n    color: configuration.easymotionDimColor,\n  });\n  private static readonly hide = vscode.window.createTextEditorDecorationType({\n    color: 'transparent',\n  });\n\n  /**\n   * TODO: For future motions\n   */\n  private static specialCharactersRegex: RegExp = /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g;\n\n  /**\n   * Caches for decorations\n   */\n  private static decorationTypeCache: vscode.TextEditorDecorationType[] = [];\n\n  /**\n   * Mode to return to after attempting easymotion\n   */\n  // TODO: make this optional (in some circumstances it isn't actually set)\n  public previousMode!: Mode;\n\n  constructor() {\n    this.markers = [];\n    this.visibleMarkers = [];\n    this.decorations = [];\n  }\n\n  /**\n   * Create and cache decoration types for different marker lengths\n   */\n  public static getDecorationType(\n    length: number,\n    decorations?: vscode.DecorationRenderOptions\n  ): vscode.TextEditorDecorationType {\n    const cache = this.decorationTypeCache[length];\n    if (cache) {\n      return cache;\n    } else {\n      const type = vscode.window.createTextEditorDecorationType(decorations || {});\n\n      this.decorationTypeCache[length] = type;\n\n      return type;\n    }\n  }\n\n  /**\n   * Clear all decorations\n   */\n  public clearDecorations(editor: vscode.TextEditor) {\n    for (let i = 1; i <= this.decorations.length; i++) {\n      editor.setDecorations(EasyMotion.getDecorationType(i), []);\n    }\n\n    editor.setDecorations(EasyMotion.fade, []);\n    editor.setDecorations(EasyMotion.hide, []);\n  }\n\n  /**\n   * Clear all markers\n   */\n  public clearMarkers() {\n    while (this.markers.length) {\n      this.markers.pop();\n    }\n    this.visibleMarkers = [];\n  }\n\n  public addMarker(marker: Marker) {\n    this.markers.push(marker);\n  }\n\n  /**\n   * Find markers beginning with a string\n   */\n  public findMarkers(nail: string, onlyVisible: boolean): Marker[] {\n    const markers = onlyVisible ? this.visibleMarkers : this.markers;\n    return markers.filter((marker) => marker.name.startsWith(nail));\n  }\n\n  /**\n   * Search and sort using the index of a match compared to the index of position (usually the cursor)\n   */\n  public sortedSearch(\n    document: vscode.TextDocument,\n    position: Position,\n    search: string | RegExp = '',\n    options: SearchOptions = {}\n  ): Match[] {\n    const regex =\n      typeof search === 'string'\n        ? new RegExp(search.replace(EasyMotion.specialCharactersRegex, '\\\\$&'), 'g')\n        : search;\n\n    const matches: Match[] = [];\n\n    // Cursor index refers to the index of the marker that is on or to the right of the cursor\n    let cursorIndex = position.character;\n    let prevMatch: Match | undefined;\n\n    // Calculate the min/max bounds for the search\n    const lineCount = document.lineCount;\n    const lineMin = options.min ? Math.max(options.min.line, 0) : 0;\n    const lineMax = options.max ? Math.min(options.max.line + 1, lineCount) : lineCount;\n\n    outer: for (let lineIdx = lineMin; lineIdx < lineMax; lineIdx++) {\n      const line = document.lineAt(lineIdx).text;\n      let result = regex.exec(line);\n\n      while (result) {\n        if (matches.length >= 1000) {\n          break outer;\n        } else {\n          const pos = new Position(lineIdx, result.index);\n\n          // Check if match is within bounds\n          if (\n            (options.min && pos.isBefore(options.min)) ||\n            (options.max && pos.isAfter(options.max)) ||\n            Math.abs(pos.line - position.line) > 100\n          ) {\n            // Stop searching after 100 lines in both directions\n            result = regex.exec(line);\n          } else {\n            // Update cursor index to the marker on the right side of the cursor\n            if (!prevMatch || prevMatch.position.isBefore(position)) {\n              cursorIndex = matches.length;\n            }\n            // Matches on the cursor position should be ignored\n            if (pos.isEqual(position)) {\n              result = regex.exec(line);\n            } else {\n              prevMatch = new Match(pos, result[0], matches.length);\n              matches.push(prevMatch);\n              result = regex.exec(line);\n            }\n          }\n        }\n      }\n    }\n\n    // Sort by the index distance from the cursor index\n    matches.sort((a: Match, b: Match): number => {\n      const absDiffA = computeAboluteDiff(a.index);\n      const absDiffB = computeAboluteDiff(b.index);\n      return absDiffA - absDiffB;\n\n      function computeAboluteDiff(matchIndex: number) {\n        const absDiff = Math.abs(cursorIndex - matchIndex);\n        // Prioritize the matches on the right side of the cursor index\n        return matchIndex < cursorIndex ? absDiff - 0.5 : absDiff;\n      }\n    });\n\n    return matches;\n  }\n\n  private getMarkerColor(\n    customizedValue: string,\n    themeColorId: string\n  ): string | vscode.ThemeColor {\n    if (customizedValue) {\n      return customizedValue;\n    } else if (!themeColorId.startsWith('#')) {\n      return new vscode.ThemeColor(themeColorId);\n    } else {\n      return themeColorId;\n    }\n  }\n\n  private getEasymotionMarkerBackgroundColor() {\n    return this.getMarkerColor(configuration.easymotionMarkerBackgroundColor, '#0000');\n  }\n\n  private getEasymotionMarkerForegroundColorOneChar() {\n    return this.getMarkerColor(configuration.easymotionMarkerForegroundColorOneChar, '#ff0000');\n  }\n\n  private getEasymotionMarkerForegroundColorTwoCharFirst() {\n    return this.getMarkerColor(\n      configuration.easymotionMarkerForegroundColorTwoCharFirst,\n      '#ffb400'\n    );\n  }\n\n  private getEasymotionMarkerForegroundColorTwoCharSecond() {\n    return this.getMarkerColor(\n      configuration.easymotionMarkerForegroundColorTwoCharSecond,\n      '#b98300'\n    );\n  }\n\n  private getEasymotionDimColor() {\n    return this.getMarkerColor(configuration.easymotionDimColor, '#777777');\n  }\n\n  public updateDecorations(editor: vscode.TextEditor) {\n    this.clearDecorations(editor);\n\n    this.visibleMarkers = [];\n    this.decorations = [];\n\n    // Set the decorations for all the different marker lengths\n    const dimmingZones: vscode.DecorationOptions[] = [];\n    const dimmingRenderOptions: vscode.ThemableDecorationRenderOptions = {\n      // we update the color here again in case the configuration has changed\n      color: this.getEasymotionDimColor(),\n    };\n    // Why this instead of `background-color` on the marker?\n    // The easy fix would've been to let the user set the marker background to the same\n    // color as the editor so it would hide the character behind, However this would require\n    // the user to do more work, with this solution we temporarily hide the marked character\n    // so no user specific setting is needed\n    const hiddenChars: vscode.Range[] = [];\n    const markers = this.markers\n      .filter((m) => m.name.startsWith(this.accumulation))\n      .sort((a, b) => (a.position.isBefore(b.position) ? -1 : 1));\n\n    // Ignore markers that do not start with the accumulated depth level\n    for (const marker of markers) {\n      const pos = marker.position;\n      // Get keys after the depth we're at\n      const keystroke = marker.name.substr(this.accumulation.length);\n\n      if (!this.decorations[keystroke.length]) {\n        this.decorations[keystroke.length] = [];\n      }\n\n      //#region Hack (remove once backend handles this)\n\n      /*\n        This hack is here because the backend for easy motion reports two adjacent\n        2 char markers resulting in a 4 char wide markers, this isn't what happens in\n        original easymotion for instance: for doom\n            - original reports d[m][m2]m where [m] is a marker and [m2] is secondary\n            - here it reports d[m][m][m][m]m\n        The reason this won't work with current impl is that it overflows resulting in\n        one extra hidden character, hence the check below (until backend truely mimics original)\n\n        if two consecutive 2 char markers, we only use the first char from the current marker\n        and reduce the char substitution by 1. Once backend properly reports adjacent markers\n        all instances of `trim` can be removed\n      */\n      let trim = 0;\n      const next = markers[markers.indexOf(marker) + 1];\n\n      if (\n        next &&\n        next.position.character - pos.character === 1 &&\n        next.position.line === pos.line\n      ) {\n        const nextKeystroke = next.name.substr(this.accumulation.length);\n\n        if (keystroke.length > 1 && nextKeystroke.length > 1) {\n          trim = -1;\n        }\n      }\n\n      //#endregion\n\n      // First Char/One Char decoration\n      const firstCharFontColor =\n        keystroke.length > 1\n          ? this.getEasymotionMarkerForegroundColorTwoCharFirst()\n          : this.getEasymotionMarkerForegroundColorOneChar();\n      const backgroundColor = this.getEasymotionMarkerBackgroundColor();\n      const firstCharRange = new vscode.Range(pos.line, pos.character, pos.line, pos.character);\n      const firstCharRenderOptions: vscode.ThemableDecorationInstanceRenderOptions = {\n        before: {\n          contentText: keystroke.substring(0, 1),\n          backgroundColor,\n          color: firstCharFontColor,\n          margin: `0 -1ch 0 0;\n          position: absolute;\n          font-weight: ${configuration.easymotionMarkerFontWeight};`,\n          height: '100%',\n        },\n      };\n\n      this.decorations[keystroke.length].push({\n        range: firstCharRange,\n        renderOptions: {\n          dark: firstCharRenderOptions,\n          light: firstCharRenderOptions,\n        },\n      });\n\n      // Second Char decoration\n      if (keystroke.length + trim > 1) {\n        const secondCharFontColor = this.getEasymotionMarkerForegroundColorTwoCharSecond();\n        const secondCharRange = new vscode.Range(\n          pos.line,\n          pos.character + 1,\n          pos.line,\n          pos.character + 1\n        );\n\n        const secondCharRenderOptions: vscode.ThemableDecorationInstanceRenderOptions = {\n          before: {\n            contentText: keystroke.slice(1),\n            backgroundColor,\n            color: secondCharFontColor,\n            margin: `0 -1ch 0 0;\n            position: absolute;\n            font-weight: ${configuration.easymotionMarkerFontWeight};`,\n            height: '100%',\n          },\n        };\n        this.decorations[keystroke.length].push({\n          range: secondCharRange,\n          renderOptions: {\n            dark: secondCharRenderOptions,\n            light: secondCharRenderOptions,\n          },\n        });\n      }\n\n      hiddenChars.push(\n        new vscode.Range(pos.line, pos.character, pos.line, pos.character + keystroke.length + trim)\n      );\n\n      if (configuration.easymotionDimBackground) {\n        // This excludes markers from the dimming ranges by using them as anchors\n        // each marker adds the range between it and previous marker to the dimming zone\n        // except last marker after which the rest of document is dimmed\n        //\n        // example [m1] text that has multiple [m2] marks\n        // |<------    |<----------------------     ---->|\n        if (dimmingZones.length === 0) {\n          dimmingZones.push({\n            range: new vscode.Range(0, 0, pos.line, pos.character),\n            renderOptions: dimmingRenderOptions,\n          });\n        } else {\n          const prevMarker = markers[markers.indexOf(marker) - 1];\n          const prevKeystroke = prevMarker.name.substr(this.accumulation.length);\n          const prevDimPos = prevMarker.position;\n          const offsetPrevDimPos = prevDimPos.withColumn(\n            prevDimPos.character + prevKeystroke.length\n          );\n\n          // Don't create dimming ranges in between consecutive markers (the 'after' is in the cases\n          // where you have 2 char consecutive markers where the first one only shows the first char.\n          // since we don't take that into account when creating 'offsetPrevDimPos' it will be after\n          // the current marker position which means we are in the middle of two consecutive markers.\n          // See the hack region above.)\n          if (!offsetPrevDimPos.isAfterOrEqual(pos)) {\n            dimmingZones.push({\n              range: new vscode.Range(\n                offsetPrevDimPos.line,\n                offsetPrevDimPos.character,\n                pos.line,\n                pos.character\n              ),\n              renderOptions: dimmingRenderOptions,\n            });\n          }\n        }\n      }\n\n      this.visibleMarkers.push(marker);\n    }\n\n    // for the last marker dim till document end\n    if (configuration.easymotionDimBackground) {\n      const prevMarker = markers[markers.length - 1];\n      const prevKeystroke = prevMarker.name.substr(this.accumulation.length);\n      const prevDimPos = dimmingZones[dimmingZones.length - 1].range.end;\n      const offsetPrevDimPos = prevDimPos.withColumn(prevDimPos.character + prevKeystroke.length);\n\n      // Don't create any more dimming ranges when the last marker is at document end\n      if (!offsetPrevDimPos.isEqual(TextEditor.getDocumentEnd(editor.document))) {\n        dimmingZones.push({\n          range: new vscode.Range(\n            offsetPrevDimPos,\n            new Position(editor.document.lineCount, Number.MAX_VALUE)\n          ),\n          renderOptions: dimmingRenderOptions,\n        });\n      }\n    }\n\n    for (let j = 1; j < this.decorations.length; j++) {\n      if (this.decorations[j]) {\n        editor.setDecorations(EasyMotion.getDecorationType(j), this.decorations[j]);\n      }\n    }\n\n    editor.setDecorations(EasyMotion.hide, hiddenChars);\n\n    if (configuration.easymotionDimBackground) {\n      editor.setDecorations(EasyMotion.fade, dimmingZones);\n    }\n  }\n}\n","import { Position } from 'vscode';\nimport { configuration } from './../../../configuration/configuration';\nimport { Marker } from './types';\n\nexport class MarkerGenerator {\n  private matchesCount: number;\n  private keyTable: string[];\n  private prefixKeyTable: string[];\n\n  constructor(matchesCount: number) {\n    this.matchesCount = matchesCount;\n    this.keyTable = this.getKeyTable();\n    this.prefixKeyTable = this.createPrefixKeyTable();\n  }\n\n  public generateMarker(index: number, markerPosition: Position): Marker | null {\n    const { keyTable, prefixKeyTable } = this;\n\n    if (index >= keyTable.length - prefixKeyTable.length) {\n      const remainder = index - (keyTable.length - prefixKeyTable.length);\n      const currentStep = Math.floor(remainder / keyTable.length) + 1;\n      if (currentStep > prefixKeyTable.length) {\n        return null;\n      } else {\n        const prefix = prefixKeyTable[currentStep - 1];\n        const label = keyTable[remainder % keyTable.length];\n        return {\n          name: prefix + label,\n          position: markerPosition,\n        };\n      }\n    } else {\n      return {\n        name: keyTable[index],\n        position: markerPosition,\n      };\n    }\n  }\n\n  private createPrefixKeyTable(): string[] {\n    const totalRemainder = Math.max(this.matchesCount - this.keyTable.length, 0);\n    const totalSteps = Math.ceil(totalRemainder / this.keyTable.length);\n    const reversed = this.keyTable.slice().reverse();\n    const count = Math.min(totalSteps, reversed.length);\n    return reversed.slice(0, count);\n  }\n\n  /**\n   * The key sequence for marker name generation\n   */\n  private getKeyTable(): string[] {\n    if (configuration.easymotionKeys) {\n      return configuration.easymotionKeys.split('');\n    } else {\n      return 'hklyuiopnm,qwertzxcvbasdgjf;'.split('');\n    }\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\nimport { Mode } from '../../../mode/mode';\nimport type { VimState } from '../../../state/vimState';\n\nexport type LabelPosition = 'after' | 'before';\nexport type JumpToAnywhere = true | false;\n\nexport interface EasyMotionMoveOptionsBase {\n  searchOptions?: 'min' | 'max';\n}\n\nexport interface EasyMotionCharMoveOpions extends EasyMotionMoveOptionsBase {\n  charCount: number;\n  labelPosition?: LabelPosition;\n}\n\nexport interface EasyMotionWordMoveOpions extends EasyMotionMoveOptionsBase {\n  labelPosition?: LabelPosition;\n  jumpToAnywhere?: JumpToAnywhere;\n}\n\nexport interface Marker {\n  name: string;\n  position: Position;\n}\n\nexport class Match {\n  public position: Position;\n  public readonly text: string;\n  public readonly index: number;\n\n  constructor(position: Position, text: string, index: number) {\n    this.position = position;\n    this.text = text;\n    this.index = index;\n  }\n\n  public toRange(): vscode.Range {\n    return new vscode.Range(this.position, this.position.translate(0, this.text.length));\n  }\n}\n\nexport interface SearchOptions {\n  /**\n   * The minimum bound of the search\n   */\n  min?: Position;\n\n  /**\n   * The maximum bound of the search\n   */\n  max?: Position;\n}\n\nexport interface EasyMotionSearchAction {\n  searchString: string;\n\n  /**\n   * True if it should go to Easymotion mode\n   */\n  shouldFire(): boolean;\n\n  /**\n   * Command to execute when it should fire\n   */\n  fire(position: Position, vimState: VimState): Promise<void>;\n  getMatches(position: Position, vimState: VimState): Match[];\n  readonly searchCharCount: number;\n}\n\nexport interface IEasyMotion {\n  accumulation: string;\n  previousMode: Mode;\n  markers: Marker[];\n  searchAction: EasyMotionSearchAction;\n\n  addMarker(marker: Marker): void;\n  findMarkers(nail: string, onlyVisible: boolean): Marker[];\n  sortedSearch(\n    document: vscode.TextDocument,\n    position: Position,\n    search?: string | RegExp,\n    options?: SearchOptions\n  ): Match[];\n  updateDecorations(editor: vscode.TextEditor): void;\n  clearMarkers(): void;\n  clearDecorations(editor: vscode.TextEditor): void;\n}\n","import { IConfiguration, IKeyRemapping } from '../../configuration/iconfiguration';\n\nexport class PluginDefaultMappings {\n  // plugin authers may add entries here\n  private static defaultMappings: Array<{\n    mode: string;\n    configSwitch: string;\n    mapping: IKeyRemapping;\n  }> = [\n    // default maps for surround\n    {\n      mode: 'normalModeKeyBindingsNonRecursive',\n      configSwitch: 'surround',\n      mapping: { before: ['y', 's'], after: ['<plugys>'] },\n    },\n    {\n      mode: 'normalModeKeyBindingsNonRecursive',\n      configSwitch: 'surround',\n      mapping: { before: ['y', 's', 's'], after: ['<plugys>', '<plugys>'] },\n    },\n    {\n      mode: 'normalModeKeyBindingsNonRecursive',\n      configSwitch: 'surround',\n      mapping: { before: ['c', 's'], after: ['<plugcs>'] },\n    },\n    {\n      mode: 'normalModeKeyBindingsNonRecursive',\n      configSwitch: 'surround',\n      mapping: { before: ['d', 's'], after: ['<plugds>'] },\n    },\n  ];\n\n  public static getPluginDefaultMappings(mode: string, config: IConfiguration): IKeyRemapping[] {\n    return this.defaultMappings\n      .filter((m) => m.mode === mode && config[m.configSwitch])\n      .map((m) => m.mapping);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { configuration } from './../../configuration/configuration';\nimport { RegisterAction } from './../base';\nimport { BaseMovement, IMovement } from '../baseMotion';\nimport { Position } from 'vscode';\n\n@RegisterAction\nexport class SneakForward extends BaseMovement {\n  keys = [\n    ['s', '<character>', '<character>'],\n    ['z', '<character>', '<character>'],\n  ];\n  override isJump = true;\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const startingLetter = vimState.recordedState.operator === undefined ? 's' : 'z';\n\n    return (\n      configuration.sneak &&\n      super.couldActionApply(vimState, keysPressed) &&\n      keysPressed[0] === startingLetter\n    );\n  }\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (!this.isRepeat) {\n      vimState.lastSemicolonRepeatableMovement = new SneakForward(this.keysPressed, true);\n      vimState.lastCommaRepeatableMovement = new SneakBackward(this.keysPressed, true);\n    }\n\n    if (this.keysPressed[2] === '\\n') {\n      // Single key sneak\n      this.keysPressed[2] = '';\n    }\n\n    const searchString = this.keysPressed[1] + this.keysPressed[2];\n\n    const document = vimState.document;\n    const lineCount = document.lineCount;\n    for (let i = position.line; i < lineCount; ++i) {\n      const lineText = document.lineAt(i).text;\n\n      // Start searching after the current character so we don't find the same match twice\n      const fromIndex = i === position.line ? position.character + 1 : 0;\n\n      let matchIndex = -1;\n\n      const ignorecase =\n        configuration.sneakUseIgnorecaseAndSmartcase &&\n        configuration.ignorecase &&\n        !(configuration.smartcase && /[A-Z]/.test(searchString));\n\n      // Check for matches\n      if (ignorecase) {\n        matchIndex = lineText\n          .toLocaleLowerCase()\n          .indexOf(searchString.toLocaleLowerCase(), fromIndex);\n      } else {\n        matchIndex = lineText.indexOf(searchString, fromIndex);\n      }\n\n      if (matchIndex >= 0) {\n        return new Position(i, matchIndex);\n      }\n    }\n\n    return position;\n  }\n}\n\n@RegisterAction\nexport class SneakBackward extends BaseMovement {\n  keys = [\n    ['S', '<character>', '<character>'],\n    ['Z', '<character>', '<character>'],\n  ];\n  override isJump = true;\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const startingLetter = vimState.recordedState.operator === undefined ? 'S' : 'Z';\n\n    return (\n      configuration.sneak &&\n      super.couldActionApply(vimState, keysPressed) &&\n      keysPressed[0] === startingLetter\n    );\n  }\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (!this.isRepeat) {\n      vimState.lastSemicolonRepeatableMovement = new SneakBackward(this.keysPressed, true);\n      vimState.lastCommaRepeatableMovement = new SneakForward(this.keysPressed, true);\n    }\n\n    if (this.keysPressed[2] === '\\n') {\n      // Single key sneak\n      this.keysPressed[2] = '';\n    }\n\n    const searchString = this.keysPressed[1] + this.keysPressed[2];\n\n    const document = vimState.document;\n    for (let i = position.line; i >= 0; --i) {\n      const lineText = document.lineAt(i).text;\n\n      // Start searching before the current character so we don't find the same match twice\n      const fromIndex = i === position.line ? position.character - 1 : +Infinity;\n\n      let matchIndex = -1;\n\n      const ignorecase =\n        configuration.sneakUseIgnorecaseAndSmartcase &&\n        configuration.ignorecase &&\n        !(configuration.smartcase && /[A-Z]/.test(searchString));\n\n      // Check for matches\n      if (ignorecase) {\n        matchIndex = lineText\n          .toLocaleLowerCase()\n          .lastIndexOf(searchString.toLocaleLowerCase(), fromIndex);\n      } else {\n        matchIndex = lineText.lastIndexOf(searchString, fromIndex);\n      }\n\n      if (matchIndex >= 0) {\n        return new Position(i, matchIndex);\n      }\n    }\n\n    return position;\n  }\n}\n","import { configuration } from './../configuration/configuration';\nimport { Mode } from './../mode/mode';\n\n/**\n * See https://vimhelp.org/options.txt.html#%27whichwrap%27\n *\n * @returns true if the given key should cause the cursor to wrap around line boundary\n */\nexport const shouldWrapKey = (mode: Mode, key: string): boolean => {\n  let k: string;\n  if (key === '<left>') {\n    k = [Mode.Insert, Mode.Replace].includes(mode) ? '[' : '<';\n  } else if (key === '<right>') {\n    k = [Mode.Insert, Mode.Replace].includes(mode) ? ']' : '>';\n  } else if (['<BS>', '<C-BS>', '<S-BS>'].includes(key)) {\n    k = 'b';\n  } else if (key === ' ') {\n    k = 's';\n  } else if (['h', 'l', '~'].includes(key)) {\n    k = key;\n  } else {\n    throw new Error(`shouldWrapKey called with unexpected key='${key}'`);\n  }\n  return configuration.whichwrap.split(',').includes(k);\n};\n","import * as vscode from 'vscode';\nimport { CommandLineHistory } from '../history/historyFile';\nimport { Mode } from './../mode/mode';\nimport { Logger } from '../util/logger';\nimport { StatusBar } from '../statusBar';\nimport { VimError, ErrorCode } from '../error';\nimport { VimState } from '../state/vimState';\nimport { configuration } from '../configuration/configuration';\nimport { Register } from '../register/register';\nimport { RecordedState } from '../state/recordedState';\nimport { exCommandParser } from '../vimscript/exCommandParser';\n\nclass CommandLine {\n  private history!: CommandLineHistory;\n  private readonly logger = Logger.get('CommandLine');\n\n  /**\n   *  Index used for navigating commandline history with <up> and <down>\n   */\n  public commandLineHistoryIndex: number = 0;\n\n  /**\n   * for checking the last pressed key in command mode\n   */\n  public lastKeyPressed = '';\n\n  public autoCompleteIndex = 0;\n  public autoCompleteItems: string[] = [];\n  public preCompleteCharacterPos = 0;\n  public preCompleteCommand = '';\n\n  public get historyEntries() {\n    return this.history?.get() || [];\n  }\n\n  public previousMode = Mode.Normal;\n\n  public async load(context: vscode.ExtensionContext): Promise<void> {\n    this.history = new CommandLineHistory(context);\n    return this.history.load();\n  }\n\n  public async Run(commandName: string, vimState: VimState): Promise<void> {\n    if (!commandName || commandName.length === 0) {\n      return;\n    }\n\n    this.history.add(commandName);\n    this.commandLineHistoryIndex = this.history.get().length;\n\n    if (!commandName.startsWith('reg')) {\n      const recState = new RecordedState();\n      recState.registerName = ':';\n      recState.commandList = commandName.split('');\n      Register.setReadonlyRegister(':', recState);\n    }\n\n    try {\n      const { lineRange, command } = exCommandParser.tryParse(commandName);\n      const useNeovim = configuration.enableNeovim && command.neovimCapable();\n\n      if (useNeovim && vimState.nvim) {\n        const { statusBarText, error } = await vimState.nvim.run(vimState, commandName);\n        StatusBar.setText(vimState, statusBarText, error);\n      } else {\n        if (lineRange) {\n          await command.executeWithRange(vimState, lineRange);\n        } else {\n          await command.execute(vimState);\n        }\n      }\n    } catch (e) {\n      if (e instanceof VimError) {\n        if (\n          e.code === ErrorCode.NotAnEditorCommand &&\n          configuration.enableNeovim &&\n          vimState.nvim\n        ) {\n          const { statusBarText } = await vimState.nvim.run(vimState, commandName);\n          StatusBar.setText(vimState, statusBarText, true);\n        } else {\n          StatusBar.setText(vimState, e.toString(), true);\n        }\n      } else {\n        this.logger.error(`Error executing cmd=${commandName}. err=${e}.`);\n      }\n    }\n  }\n\n  /**\n   * Prompts the user for a command using an InputBox, and runs the provided command\n   */\n  public async PromptAndRun(initialText: string, vimState: VimState): Promise<void> {\n    const cmd = await vscode.window.showInputBox(this.getInputBoxOptions(initialText));\n    await this.Run(cmd!, vimState);\n  }\n\n  private getInputBoxOptions(text: string): vscode.InputBoxOptions {\n    return {\n      prompt: 'Vim command line',\n      value: text,\n      ignoreFocusOut: false,\n      valueSelection: [text.length, text.length],\n    };\n  }\n\n  public async showHistory(initialText: string): Promise<string | undefined> {\n    this.history.add(initialText);\n\n    return vscode.window.showQuickPick(this.history.get().slice().reverse(), {\n      placeHolder: 'Vim command history',\n      ignoreFocusOut: false,\n    });\n  }\n}\n\nexport const commandLine = new CommandLine();\n","import { VimState } from '../../state/vimState';\nimport { PositionDiff } from '../../common/motion/position';\nimport { externalCommand } from '../../util/externalCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport interface IBangCommandArguments {\n  command: string;\n}\n\nexport class BangCommand extends ExCommand {\n  protected _arguments: IBangCommandArguments;\n\n  constructor(args: IBangCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  private getReplaceDiff(text: string): PositionDiff {\n    const lines = text.split('\\n');\n    const numNewlines = lines.length - 1;\n    const check = lines[0].match(/^\\s*/);\n    const numWhitespace = check ? check[0].length : 0;\n\n    return PositionDiff.exactCharacter({\n      lineOffset: -numNewlines,\n      character: numWhitespace,\n    });\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await externalCommand.run(this._arguments.command);\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const resolvedRange = range.resolveToRange(vimState);\n\n    // pipe in stdin from lines in range\n    const input = vimState.document.getText();\n    const output = await externalCommand.run(this._arguments.command, input);\n\n    // place cursor at the start of the replaced text and first non-whitespace character\n    const diff = this.getReplaceDiff(output);\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      text: output,\n      range: resolvedRange,\n      diff,\n    });\n  }\n}\n","import * as vscode from 'vscode';\n\nimport * as error from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport interface IBufferDeleteCommandArguments {\n  bang?: boolean;\n  tabPosition?: string;\n}\n\n//\n//  Implements :bd\n// http://vimdoc.sourceforge.net/htmldoc/windows.html#buffers\n//\nexport class BufferDeleteCommand extends ExCommand {\n  public readonly arguments: IBufferDeleteCommandArguments;\n\n  constructor(args: IBufferDeleteCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (vimState.document.isDirty && !this.arguments.bang) {\n      throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n    }\n\n    if (this.arguments.tabPosition !== undefined) {\n      try {\n        await vscode.commands.executeCommand(\n          `workbench.action.openEditorAtIndex${this.arguments.tabPosition}`\n        );\n      } catch (e) {\n        throw error.VimError.fromCode(error.ErrorCode.NoBuffersDeleted);\n      }\n    }\n\n    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n  }\n}\n","import * as vscode from 'vscode';\n\nimport * as error from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\n\nexport interface ICloseCommandArguments {\n  bang?: boolean;\n  range?: LineRange;\n  quitAll?: boolean;\n}\n\n//\n//  Implements :close\n//  http://vimdoc.sourceforge.net/htmldoc/windows.html#:close\n//\nexport class CloseCommand extends ExCommand {\n  public readonly arguments: ICloseCommandArguments;\n\n  constructor(args: ICloseCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (vimState.document.isDirty && !this.arguments.bang) {\n      throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n    }\n\n    if (vscode.window.visibleTextEditors.length === 1) {\n      throw error.VimError.fromCode(error.ErrorCode.CannotCloseLastWindow);\n    }\n\n    const oldViewColumn = vimState.editor.viewColumn;\n    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n\n    if (\n      vscode.window.activeTextEditor !== undefined &&\n      vscode.window.activeTextEditor.viewColumn === oldViewColumn\n    ) {\n      await vscode.commands.executeCommand('workbench.action.previousEditor');\n    }\n  }\n}\n","import { Position, Range } from 'vscode';\nimport { PositionDiff } from '../../common/motion/position';\nimport { ErrorCode, VimError } from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { StatusBar } from '../../statusBar';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { Scanner } from '../scanner';\n\nexport class CopyCommand extends ExCommand {\n  public static parseArgs(args: string): CopyCommand {\n    if (args.trim() === '') {\n      return new CopyCommand();\n    }\n\n    const scanner = new Scanner(args);\n    // TODO: dest should be parsed as a range (and all the special stuff that goes along with that, i.e. % or 'a)\n    const dest = parseInt(scanner.nextWord(), 10);\n    if (isNaN(dest) || !scanner.isAtEof) {\n      throw VimError.fromCode(ErrorCode.TrailingCharacters);\n    }\n\n    return new CopyCommand(dest);\n  }\n\n  private dest?: number;\n  private constructor(dest?: number) {\n    super();\n    this.dest = dest;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  private copyLines(vimState: VimState, sourceStart: number, sourceEnd: number) {\n    if (this.dest === undefined || this.dest < 0 || this.dest > vimState.document.lineCount) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.InvalidAddress));\n      return;\n    }\n\n    if (sourceEnd < sourceStart) {\n      [sourceStart, sourceEnd] = [sourceEnd, sourceStart];\n    }\n\n    const copiedText = vimState.document.getText(\n      new Range(new Position(sourceStart, 0), new Position(sourceEnd, 0).getLineEnd())\n    );\n\n    let text: string;\n    let position: Position;\n    if (this.dest === 0) {\n      text = copiedText + '\\n';\n      position = new Position(0, 0);\n    } else {\n      text = '\\n' + copiedText;\n      position = new Position(this.dest - 1, 0).getLineEnd();\n    }\n\n    const lines = copiedText.split('\\n');\n    const cursorPosition = new Position(\n      this.dest - 1 + lines.length,\n      lines[lines.length - 1].match(/\\S/)?.index ?? 0\n    );\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertText',\n      position,\n      text,\n      diff: PositionDiff.exactPosition(cursorPosition),\n    });\n  }\n\n  public async execute(vimState: VimState): Promise<void> {\n    const line = vimState.cursors[0].stop.line;\n    this.copyLines(vimState, line, line);\n  }\n\n  public override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const { start, end } = range.resolve(vimState)!;\n    this.copyLines(vimState, start, end);\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { VimState } from '../../state/vimState';\nimport { Register, RegisterMode } from '../../register/register';\nimport { Position } from 'vscode';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\n\nexport interface IDeleteRangeCommandArguments {\n  linesToRemove?: number;\n  register?: string;\n}\n\nexport class DeleteRangeCommand extends ExCommand {\n  private readonly arguments: IDeleteRangeCommandArguments;\n\n  constructor(args: IDeleteRangeCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  /**\n   * Deletes text between `startLine` and `endLine`, inclusive.\n   * Puts the cursor at the start of the line where the deleted range was.\n   */\n  private deleteRange(startLine: number, endLine: number, vimState: VimState): void {\n    let start = new Position(startLine, 0);\n    let end = new Position(endLine, 0).getLineEndIncludingEOL();\n\n    if (endLine < vimState.document.lineCount - 1) {\n      end = end.getRightThroughLineBreaks();\n    } else if (startLine > 0) {\n      start = start.getLeftThroughLineBreaks();\n    }\n\n    const range = new vscode.Range(start, end);\n    const text = vimState.document\n      .getText(range)\n      // Remove leading or trailing newline\n      .replace(/^\\r?\\n/, '')\n      .replace(/\\r?\\n$/, '');\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'deleteRange',\n      range: new vscode.Range(start, end),\n      manuallySetCursorPositions: true,\n    });\n    vimState.cursorStopPosition = start.getLineBegin();\n\n    if (this.arguments.register) {\n      vimState.recordedState.registerName = this.arguments.register;\n    }\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    Register.put(vimState, text, 0, true);\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const linesToRemove = this.arguments.linesToRemove ?? 1;\n    // :d[elete][cnt] removes [cnt] lines\n    const startLine = vimState.cursorStartPosition.line;\n    const endLine = startLine + (linesToRemove - 1);\n    this.deleteRange(startLine, endLine, vimState);\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    /**\n     * If a [cnt] and [range] is specified (e.g. :.+2d3), :delete [cnt] is called from\n     * the end of the [range].\n     * Ex. if two lines are VisualLine highlighted, :<,>d3 will :d3\n     * from the end of the selected lines.\n     */\n    const { start, end } = range.resolve(vimState)!;\n    if (this.arguments.linesToRemove) {\n      vimState.cursorStartPosition = new Position(end, 0);\n      await this.execute(vimState);\n      return;\n    }\n    this.deleteRange(start, end, vimState);\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { configuration } from './../../configuration/configuration';\nimport { VimState } from '../../state/vimState';\nimport { DefaultDigraphs } from '../../actions/commands/digraphs';\nimport { TextEditor } from '../../textEditor';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport interface IDigraphsCommandArguments {\n  arg?: string;\n}\n\ninterface DigraphQuickPickItem extends vscode.QuickPickItem {\n  charCodes: number[];\n}\n\nexport class DigraphsCommand extends ExCommand {\n  private readonly arguments: IDigraphsCommandArguments;\n\n  constructor(args: IDigraphsCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  // TODO: replace 'any' with sensible index signature\n  private makeQuickPicks(digraphs: any): DigraphQuickPickItem[] {\n    const quickPicks = new Array<DigraphQuickPickItem>();\n    for (const digraphKey of Object.keys(digraphs)) {\n      const [charDesc, charCodes] = digraphs[digraphKey];\n      quickPicks.push({\n        label: digraphKey,\n        description: `${charDesc} (user)`,\n        charCodes,\n      });\n    }\n    return quickPicks;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.arguments.arg !== undefined && this.arguments.arg.length > 2) {\n      // TODO: Register digraphs in args in state\n    }\n    const digraphKeyAndContent = this.makeQuickPicks(configuration.digraphs).concat(\n      this.makeQuickPicks(DefaultDigraphs)\n    );\n\n    vscode.window.showQuickPick(digraphKeyAndContent).then(async (val) => {\n      if (val) {\n        const char = String.fromCharCode(...val.charCodes);\n        await TextEditor.insert(vimState.editor, char);\n      }\n    });\n  }\n}\n","import * as vscode from 'vscode';\nimport { Logger } from '../../util/logger';\nimport { getPathDetails, resolveUri } from '../../util/path';\nimport { doesFileExist } from 'platform/fs';\nimport untildify = require('untildify');\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport enum FilePosition {\n  NewWindowVerticalSplit,\n  NewWindowHorizontalSplit,\n}\n\nexport interface IFileCommandArguments {\n  name: string | undefined;\n  bang?: boolean;\n  position?: FilePosition;\n  lineNumber?: number;\n  createFileIfNotExists?: boolean;\n}\n\nexport class FileCommand extends ExCommand {\n  private readonly arguments: IFileCommandArguments;\n  private readonly logger = Logger.get('File');\n\n  constructor(args: IFileCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.arguments.bang) {\n      await vscode.commands.executeCommand('workbench.action.files.revert');\n      return;\n    }\n\n    // Need to do this before the split since it loses the activeTextEditor\n    const editorFileUri = vscode.window.activeTextEditor!.document.uri;\n    const editorFilePath = editorFileUri.fsPath;\n\n    // Do the split if requested\n    let split = false;\n    if (this.arguments.position === FilePosition.NewWindowVerticalSplit) {\n      await vscode.commands.executeCommand('workbench.action.splitEditorRight');\n      split = true;\n    }\n    if (this.arguments.position === FilePosition.NewWindowHorizontalSplit) {\n      await vscode.commands.executeCommand('workbench.action.splitEditorDown');\n      split = true;\n    }\n\n    const hidePreviousEditor = async () => {\n      if (split === true) {\n        await vscode.commands.executeCommand('workbench.action.previousEditor');\n        await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n      }\n    };\n\n    // No name was specified\n    if (this.arguments.name === undefined) {\n      if (this.arguments.createFileIfNotExists === true) {\n        await vscode.commands.executeCommand('workbench.action.files.newUntitledFile');\n        await hidePreviousEditor();\n      }\n      return;\n    }\n\n    // Only untidify when the currently open page and file completion is local\n    if (this.arguments.name && editorFileUri.scheme === 'file') {\n      this.arguments.name = untildify(this.arguments.name);\n    }\n\n    let fileUri = editorFileUri;\n    // Using the empty string will request to open a file\n    if (this.arguments.name === '') {\n      // No name on split is fine and just return\n      if (split === true) {\n        return;\n      }\n\n      const fileList = await vscode.window.showOpenDialog({});\n      if (fileList && fileList.length > 0) {\n        fileUri = fileList[0];\n      }\n    } else {\n      // remove file://\n      this.arguments.name = this.arguments.name.replace(/^file:\\/\\//, '');\n\n      // Using a filename, open or create the file\n      const isRemote = !!vscode.env.remoteName;\n      const { fullPath, path: p } = getPathDetails(this.arguments.name, editorFileUri, isRemote);\n      // Only if the expanded path of the full path is different than\n      // the currently opened window path\n      if (fullPath !== editorFilePath) {\n        const uriPath = resolveUri(fullPath, p.sep, editorFileUri, isRemote);\n        if (uriPath === null) {\n          // return if the path is invalid\n          return;\n        }\n\n        let fileExists = await doesFileExist(uriPath);\n        if (fileExists) {\n          // If the file without the added ext exists\n          fileUri = uriPath;\n        } else {\n          // if file does not exist\n          // try to find it with the same extension as the current file\n          const pathWithExt = fullPath + p.extname(editorFilePath);\n          const uriPathWithExt = resolveUri(pathWithExt, p.sep, editorFileUri, isRemote);\n          if (uriPathWithExt !== null) {\n            fileExists = await doesFileExist(uriPathWithExt);\n            if (fileExists) {\n              // if the file with the added ext exists\n              fileUri = uriPathWithExt;\n            }\n          }\n        }\n\n        // If both with and without ext path do not exist\n        if (!fileExists) {\n          if (this.arguments.createFileIfNotExists) {\n            // Change the scheme to untitled to open an\n            // untitled tab\n            fileUri = uriPath.with({ scheme: 'untitled' });\n          } else {\n            this.logger.error(`${this.arguments.name} does not exist.`);\n            return;\n          }\n        }\n      }\n    }\n\n    const doc = await vscode.workspace.openTextDocument(fileUri);\n    vscode.window.showTextDocument(doc);\n\n    if (this.arguments.lineNumber) {\n      vscode.window.activeTextEditor!.revealRange(\n        new vscode.Range(\n          new vscode.Position(this.arguments.lineNumber, 0),\n          new vscode.Position(this.arguments.lineNumber, 0)\n        )\n      );\n    }\n    await hidePreviousEditor();\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { reportFileInfo } from '../../util/statusBarTextUtils';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class FileInfoCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    reportFileInfo(vimState.cursors[0].start, vimState);\n  }\n}\n","import { ErrorCode, VimError } from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { Scanner } from '../scanner';\n\nexport class GotoCommand extends ExCommand {\n  public static parseArgs(args: string): GotoCommand {\n    if (args.trim() === '') {\n      return new GotoCommand();\n    }\n\n    const scanner = new Scanner(args);\n    const offset = parseInt(scanner.nextWord(), 10);\n    if (isNaN(offset)) {\n      throw VimError.fromCode(ErrorCode.TrailingCharacters);\n    }\n    return new GotoCommand(offset);\n  }\n\n  private offset?: number;\n  private constructor(offset?: number) {\n    super();\n    this.offset = offset;\n  }\n\n  private gotoOffset(vimState: VimState, offset: number) {\n    vimState.cursorStopPosition = vimState.document.positionAt(offset);\n  }\n\n  public async execute(vimState: VimState): Promise<void> {\n    this.gotoOffset(vimState, this.offset ?? 0);\n  }\n\n  public override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    if (this.offset === undefined) {\n      this.offset = range.resolve(vimState)?.end ?? 0;\n    }\n    this.gotoOffset(vimState, this.offset);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\n\nexport class GotoLineCommand extends ExCommand {\n  public async execute(vimState: VimState): Promise<void> {\n    return;\n  }\n\n  public override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    vimState.cursorStartPosition = vimState.cursorStopPosition = vimState.cursorStopPosition\n      .with({ line: range.resolve(vimState)!.end })\n      .obeyStartOfLine(vimState.document);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport {\n  CommandShowSearchHistory,\n  CommandShowCommandHistory,\n} from '../../actions/commands/actions';\nimport { SearchDirection } from '../../state/searchState';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport enum HistoryCommandType {\n  Cmd,\n  Search,\n  Expr,\n  Input,\n  Debug,\n  All,\n}\n\nexport interface IHistoryCommandArguments {\n  type: HistoryCommandType;\n  // TODO: :history can accept multiple types\n  // TODO: :history can also accept a range\n}\n\n// http://vimdoc.sourceforge.net/htmldoc/cmdline.html#:history\nexport class HistoryCommand extends ExCommand {\n  private readonly arguments: IHistoryCommandArguments;\n\n  constructor(args: IHistoryCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    switch (this.arguments.type) {\n      case HistoryCommandType.Cmd:\n        await new CommandShowCommandHistory().exec(vimState.cursorStopPosition, vimState);\n        break;\n      case HistoryCommandType.Search:\n        await new CommandShowSearchHistory(SearchDirection.Forward).exec(\n          vimState.cursorStopPosition,\n          vimState\n        );\n        break;\n      // TODO: Implement these\n      case HistoryCommandType.Expr:\n        throw new Error('Not implemented');\n      case HistoryCommandType.Input:\n        throw new Error('Not implemented');\n      case HistoryCommandType.Debug:\n        throw new Error('Not implemented');\n      case HistoryCommandType.All:\n        throw new Error('Not implemented');\n    }\n  }\n}\n","import { window, QuickPickItem } from 'vscode';\n\nimport { VimState } from '../../state/vimState';\nimport { globalState } from '../../state/globalState';\nimport { Jump } from '../../jumps/jump';\nimport { Cursor } from '../../common/motion/cursor';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nclass JumpPickItem implements QuickPickItem {\n  jump: Jump;\n\n  label: string;\n  description?: string;\n  detail?: string;\n  picked?: boolean;\n  alwaysShow?: boolean;\n\n  constructor(jump: Jump, idx: number) {\n    this.jump = jump;\n    this.label = jump.fileName;\n    this.detail = `jump ${idx} line ${jump.position.line + 1} col ${jump.position.character}`;\n    try {\n      this.description = jump.document.lineAt(jump.position).text;\n    } catch (e) {\n      this.description = undefined;\n    }\n  }\n}\n\nexport class JumpsCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    const jumpTracker = globalState.jumpTracker;\n    if (jumpTracker.hasJumps) {\n      const quickPickItems = jumpTracker.jumps.map((jump, idx) => new JumpPickItem(jump, idx));\n      const item = await window.showQuickPick(quickPickItems, {\n        canPickMany: false,\n      });\n      if (item && item.jump.document !== undefined) {\n        window.showTextDocument(item.jump.document);\n        vimState.cursors = [new Cursor(item.jump.position, item.jump.position)];\n      }\n    } else {\n      window.showInformationMessage('No jumps available');\n    }\n  }\n}\n\nexport class ClearJumpsCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    const jumpTracker = globalState.jumpTracker;\n    jumpTracker.clearJumps();\n  }\n}\n","import { window, QuickPickItem } from 'vscode';\n\nimport { VimState } from '../../state/vimState';\nimport { IMark } from '../../history/historyTracker';\nimport { Cursor } from '../../common/motion/cursor';\nimport { StatusBar } from '../../statusBar';\nimport { ErrorCode, VimError } from '../../error';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nclass MarkQuickPickItem implements QuickPickItem {\n  mark: IMark;\n\n  label: string;\n  description: string;\n  detail: string;\n  picked = false;\n  alwaysShow = false;\n\n  constructor(vimState: VimState, mark: IMark) {\n    this.mark = mark;\n    this.label = mark.name;\n    if (mark.document && mark.document !== vimState.document) {\n      this.description = mark.document.fileName;\n    } else {\n      this.description = vimState.document.lineAt(mark.position).text.trim();\n    }\n    this.detail = `line ${mark.position.line} col ${mark.position.character}`;\n  }\n}\n\nexport class MarksCommand extends ExCommand {\n  private marksFilter?: string[];\n\n  constructor(marksFilter?: string[]) {\n    super();\n    this.marksFilter = marksFilter;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const quickPickItems: MarkQuickPickItem[] = vimState.historyTracker\n      .getMarks()\n      .filter((mark) => {\n        return !this.marksFilter || this.marksFilter.includes(mark.name);\n      })\n      .map((mark) => new MarkQuickPickItem(vimState, mark));\n\n    if (quickPickItems.length > 0) {\n      const item = await window.showQuickPick(quickPickItems, {\n        canPickMany: false,\n      });\n      if (item) {\n        vimState.cursors = [new Cursor(item.mark.position, item.mark.position)];\n      }\n    } else {\n      window.showInformationMessage('No marks set');\n    }\n  }\n}\n\nexport class DeleteMarksCommand extends ExCommand {\n  private numbers = '0123456789';\n  private numberRange = /([0-9])-([0-9])/;\n  private letterRange = /([a-zA-Z])-([a-zA-Z])/;\n  private args?: string;\n\n  constructor(args?: string) {\n    super();\n    this.args = args;\n  }\n\n  range(start: number, end: number): number[] {\n    const range: number[] = [];\n    for (let i = start; i <= end; i++) {\n      range.push(i);\n    }\n    return range;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (!this.args) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.ArgumentRequired));\n      return;\n    }\n\n    if (this.args === '!') {\n      vimState.historyTracker.removeLocalMarks();\n      return;\n    }\n\n    if (!this.args.includes('-')) {\n      vimState.historyTracker.removeMarks(this.args.split(''));\n      return;\n    }\n\n    const numberArgs = this.numberRange.exec(this.args);\n    let letterArgs = this.letterRange.exec(this.args);\n\n    if (!numberArgs && !letterArgs && this.args.includes('-')) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.InvalidArgument));\n      return;\n    }\n\n    if (numberArgs && numberArgs.length > 2) {\n      if (parseInt(numberArgs[1], 10) > parseInt(numberArgs[2], 10)) {\n        StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.InvalidArgument));\n        return;\n      }\n\n      const start = this.numbers.indexOf(numberArgs[1]);\n      const end = this.numbers.indexOf(numberArgs[2]);\n      vimState.historyTracker.removeMarks(this.numbers.substring(start, end + 1).split(''));\n    }\n\n    while (letterArgs && letterArgs.length > 2) {\n      if (this.caseMismatch(letterArgs[1], letterArgs[2])) {\n        StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.InvalidArgument));\n        return;\n      }\n\n      const lowerCase = letterArgs[1] === letterArgs[1].toLowerCase();\n\n      const letters = lowerCase ? 'abcdefghijklmnopqrstuvwxyz' : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n      const start = letters.indexOf(letterArgs[1]);\n      const end = letters.indexOf(letterArgs[2]);\n\n      if (start > end) {\n        StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.InvalidArgument));\n        return;\n      }\n\n      vimState.historyTracker.removeMarks(letters.substring(start, end + 1).split(''));\n\n      this.args = this.args.replace(letterArgs[0], '');\n      letterArgs = this.letterRange.exec(this.args);\n    }\n  }\n\n  caseMismatch(a: string, b: string): boolean {\n    return (\n      (a.toLowerCase() === a && b !== b.toLowerCase()) ||\n      (b.toLowerCase() === b && a !== a.toLowerCase())\n    );\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { globalState } from '../../state/globalState';\nimport { StatusBar } from '../../statusBar';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class NohlCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    globalState.hl = false;\n\n    // Clear the `match x of y` message from status bar\n    StatusBar.clear(vimState);\n  }\n}\n","import * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class OnlyCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    await Promise.allSettled([\n      vscode.commands.executeCommand('workbench.action.closeEditorsInOtherGroups'),\n      vscode.commands.executeCommand('workbench.action.maximizeEditor'),\n      vscode.commands.executeCommand('workbench.action.closePanel'),\n    ]);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { configuration } from '../../configuration/configuration';\n\nimport { Register } from '../../register/register';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\nimport { Position } from 'vscode';\nimport { PutBeforeFromCmdLine, PutFromCmdLine } from '../../actions/commands/put';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\n\nexport interface IPutCommandArguments {\n  bang?: boolean;\n  register?: string;\n}\n\n//\n// Implements :put\n// http://vimdoc.sourceforge.net/htmldoc/change.html#:put\n//\n\nexport class PutExCommand extends ExCommand {\n  public readonly arguments: IPutCommandArguments;\n\n  constructor(args: IPutCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  async doPut(vimState: VimState, position: Position): Promise<void> {\n    const registerName = this.arguments.register || (configuration.useSystemClipboard ? '*' : '\"');\n    if (!Register.isValidRegister(registerName)) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.TrailingCharacters));\n      return;\n    }\n\n    vimState.recordedState.registerName = registerName;\n\n    const putCmd = this.arguments.bang ? new PutBeforeFromCmdLine() : new PutFromCmdLine();\n    putCmd.setInsertionLine(position.line);\n    await putCmd.exec(position, vimState);\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await this.doPut(vimState, vimState.cursorStopPosition);\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const { end } = range.resolve(vimState)!;\n    await this.doPut(vimState, new Position(end, 0).getLineEnd());\n  }\n}\n","import * as vscode from 'vscode';\n\nimport * as error from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\n\nexport interface IQuitCommandArguments {\n  bang?: boolean;\n  range?: LineRange;\n  quitAll?: boolean;\n}\n\n//\n//  Implements :quit\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:quit\n//\nexport class QuitCommand extends ExCommand {\n  public arguments: IQuitCommandArguments;\n\n  constructor(args: IQuitCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    // NOTE: We can't currently get all open text editors, so this isn't perfect. See #3809\n    const duplicatedInSplit =\n      vscode.window.visibleTextEditors.filter((editor) => editor.document === vimState.document)\n        .length > 1;\n    if (\n      vimState.document.isDirty &&\n      !this.arguments.bang &&\n      (!duplicatedInSplit || this.arguments.quitAll)\n    ) {\n      throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n    }\n\n    if (this.arguments.quitAll) {\n      await vscode.commands.executeCommand('workbench.action.closeAllEditors');\n    } else {\n      if (!this.arguments.bang) {\n        await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n      } else {\n        await vscode.commands.executeCommand('workbench.action.revertAndCloseActiveEditor');\n      }\n    }\n  }\n}\n","import { TextEditor } from '../../textEditor';\nimport { readFileAsync } from 'platform/fs';\nimport { SUPPORT_READ_COMMAND } from 'platform/constants';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport interface IReadCommandArguments {\n  file?: string;\n  cmd?: string;\n}\n\n//\n//  Implements :read and :read!\n//  http://vimdoc.sourceforge.net/htmldoc/insert.html#:read\n//  http://vimdoc.sourceforge.net/htmldoc/insert.html#:read!\n//\nexport class ReadCommand extends ExCommand {\n  private readonly arguments: IReadCommandArguments;\n\n  constructor(args: IReadCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const textToInsert = await this.getTextToInsert();\n    if (textToInsert) {\n      await TextEditor.insert(vimState.editor, textToInsert);\n    }\n  }\n\n  async getTextToInsert(): Promise<string> {\n    if (this.arguments.file && this.arguments.file.length > 0) {\n      return this.getTextToInsertFromFile();\n    } else if (this.arguments.cmd && this.arguments.cmd.length > 0) {\n      return this.getTextToInsertFromCmd();\n    } else {\n      throw Error('Invalid arguments');\n    }\n  }\n\n  async getTextToInsertFromFile(): Promise<string> {\n    // TODO: Read encoding from ++opt argument.\n    try {\n      const data = await readFileAsync(this.arguments.file as string, 'utf8');\n      return data;\n    } catch (e) {\n      throw e;\n    }\n  }\n\n  async getTextToInsertFromCmd(): Promise<string> {\n    if (SUPPORT_READ_COMMAND) {\n      return new Promise<string>((resolve, reject) => {\n        try {\n          import('child_process').then((cp) => {\n            return cp.exec(this.arguments.cmd as string, (err, stdout, stderr) => {\n              if (err) {\n                reject(err);\n              } else {\n                resolve(stdout);\n              }\n            });\n          });\n        } catch (e) {\n          reject(e);\n        }\n      });\n    } else {\n      return '';\n    }\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { VimState } from '../../state/vimState';\nimport { Register } from '../../register/register';\nimport { RecordedState } from '../../state/recordedState';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport interface IRegisterCommandArguments {\n  registers: string[];\n}\nexport class RegisterCommand extends ExCommand {\n  private readonly arguments: IRegisterCommandArguments;\n\n  constructor(args: IRegisterCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  private async getRegisterDisplayValue(register: string): Promise<string | undefined> {\n    let result = (await Register.get(register))?.text;\n    if (result instanceof Array) {\n      result = result.join('\\n').substr(0, 100);\n    } else if (result instanceof RecordedState) {\n      result = result.actionsRun.map((x) => x.keysPressed.join('')).join('');\n    }\n\n    return result;\n  }\n\n  async displayRegisterValue(vimState: VimState, register: string): Promise<void> {\n    let result = await this.getRegisterDisplayValue(register);\n    if (result === undefined) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NothingInRegister, register));\n    } else {\n      result = result.replace(/\\n/g, '\\\\n');\n      vscode.window.showInformationMessage(`${register} ${result}`);\n    }\n  }\n\n  private regSortOrder(register: string): number {\n    const specials = ['-', '*', '+', '.', ':', '%', '#', '/', '='];\n    if (register === '\"') {\n      return 0;\n    } else if (register >= '0' && register <= '9') {\n      return 10 + parseInt(register, 10);\n    } else if (register >= 'a' && register <= 'z') {\n      return 100 + (register.charCodeAt(0) - 'a'.charCodeAt(0));\n    } else if (specials.includes(register)) {\n      return 1000 + specials.indexOf(register);\n    } else {\n      throw new Error(`Unexpected register ${register}`);\n    }\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.arguments.registers.length === 1) {\n      await this.displayRegisterValue(vimState, this.arguments.registers[0]);\n    } else {\n      const currentRegisterKeys = Register.getKeys()\n        .filter(\n          (reg) =>\n            reg !== '_' &&\n            (this.arguments.registers.length === 0 || this.arguments.registers.includes(reg))\n        )\n        .sort((reg1: string, reg2: string) => this.regSortOrder(reg1) - this.regSortOrder(reg2));\n      const registerKeyAndContent = new Array<vscode.QuickPickItem>();\n\n      for (const registerKey of currentRegisterKeys) {\n        registerKeyAndContent.push({\n          label: registerKey,\n          description: await this.getRegisterDisplayValue(registerKey),\n        });\n      }\n\n      vscode.window.showQuickPick(registerKeyAndContent).then(async (val) => {\n        if (val) {\n          const result = val.description;\n          vscode.window.showInformationMessage(`${val.label} ${result}`);\n        }\n      });\n    }\n  }\n}\n","import { configuration, optionAliases } from '../../configuration/configuration';\nimport { VimError, ErrorCode } from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { StatusBar } from '../../statusBar';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport enum SetOptionOperator {\n  /*\n   * Set string or number option to {value}.\n   * White space between {option} and '=' is allowed and will be ignored.  White space between '=' and {value} is not allowed.\n   */\n  Equal,\n  /*\n   * Toggle option: set, switch it on.\n   * Number option: show value.\n   * String option: show value.\n   */\n  Set,\n  /*\n   * Toggle option: Reset, switch it off.\n   */\n  Reset,\n  /**\n   * Toggle option: Insert value.\n   */\n  Invert,\n  /*\n   * Add the {value} to a number option, or append the {value} to a string option.\n   * When the option is a comma separated list, a comma is added, unless the value was empty.\n   */\n  Append,\n  /*\n   * Subtract the {value} from a number option, or remove the {value} from a string option, if it is there.\n   */\n  Subtract,\n  /**\n   * Multiply the {value} to a number option, or prepend the {value} to a string option.\n   */\n  Multiply,\n  /**\n   * Show value of {option}.\n   */\n  Info,\n}\n\nexport interface IOptionArgs {\n  name?: string;\n  operator?: SetOptionOperator;\n  value?: string | number | boolean;\n}\n\nexport class SetOptionsCommand extends ExCommand {\n  private readonly arguments: IOptionArgs;\n\n  constructor(args: IOptionArgs) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (!this.arguments.name) {\n      throw new Error('Missing argument.');\n    }\n\n    const optionName = optionAliases.get(this.arguments.name) ?? this.arguments.name;\n\n    if (configuration[optionName] == null) {\n      throw VimError.fromCode(ErrorCode.UnknownOption, optionName);\n    }\n\n    switch (this.arguments.operator) {\n      case SetOptionOperator.Set:\n        configuration[optionName] = true;\n        break;\n      case SetOptionOperator.Reset:\n        configuration[optionName] = false;\n        break;\n      case SetOptionOperator.Equal:\n        configuration[optionName] = this.arguments.value!;\n        break;\n      case SetOptionOperator.Invert:\n        configuration[optionName] = !configuration[optionName];\n        break;\n      case SetOptionOperator.Append:\n        configuration[optionName] += this.arguments.value!;\n        break;\n      case SetOptionOperator.Subtract:\n        if (typeof this.arguments.value! === 'number') {\n          configuration[optionName] -= this.arguments.value;\n        } else {\n          const initialValue = configuration[optionName];\n          configuration[optionName] = initialValue.split(this.arguments.value! as string).join('');\n        }\n        break;\n      case SetOptionOperator.Info:\n        const value = configuration[optionName];\n        if (value === undefined) {\n          throw VimError.fromCode(ErrorCode.UnknownOption, optionName);\n        } else {\n          StatusBar.setText(vimState, `${optionName}=${value}`);\n        }\n        break;\n      default:\n        break;\n    }\n  }\n}\n","import { window } from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class ShCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    window.createTerminal().show();\n  }\n}\n","import * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { TextEditor } from '../../textEditor';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class SmileCommand extends ExCommand {\n  static readonly smileText: string = `\n                               oooo$$$$$$$$$$$$oooo\n                          oo$$$$$$$$$$$$$$$$$$$$$$$$o\n                       oo$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o         o$   $$ o$\n     o $ oo          o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o       $$ $$ $$o$\n    oo $ $ \"$      o$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$o       $$$o$$o$\n    \"$$$$$$o$     o$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$o    $$$$$$$$\n      $$$$$$$    $$$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$$$$$$$$$$$$$$\n      $$$$$$$$$$$$$$$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$$$$$$  \"\"\"$$$\n       \"$$$\"\"\"\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     \"$$$\n        $$$   o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     \"$$$o\n       o$$\"   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$       $$$o\n       $$$    $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\" \"$$$$$$ooooo$$$$o\n      o$$$oooo$$$$$  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$   o$$$$$$$$$$$$$$$$$\n      $$$$$$$$\"$$$$   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     $$$$\"\"\"\"\"\"\"\"\n     \"\"\"\"       $$$$    \"$$$$$$$$$$$$$$$$$$$$$$$$$$$$\"      o$$$\n                \"$$$o     \"\"\"$$$$$$$$$$$$$$$$$$\"$$\"         $$$\n                  $$$o          \"$$\"\"$$$$$$\"\"\"\"           o$$$\n                   $$$$o                                o$$$\"\n                    \"$$$$o      o$$$$$$o\"$$$$o        o$$$$\n                      \"$$$$$oo     \"\"$$$$o$$$$$o   o$$$$\"\"\n                         \"\"$$$$$oooo  \"$$$o$$$$$$$$$\"\"\"\n                            \"\"$$$$$$$oo $$$$$$$$$$\n                                    \"\"\"\"$$$$$$$$$$$\n                                        $$$$$$$$$$$$\n                                         $$$$$$$$$$\"\n                                          \"$$$\"\"\"\"`;\n\n  constructor() {\n    super();\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('workbench.action.files.newUntitledFile');\n    await TextEditor.insert(vscode.window.activeTextEditor!, SmileCommand.smileText);\n  }\n}\n","import * as vscode from 'vscode';\nimport { PositionDiff } from '../../common/motion/position';\n\nimport { isVisualMode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\n\nexport interface ISortCommandArguments {\n  reverse: boolean;\n  ignoreCase: boolean;\n  unique: boolean;\n}\n\nexport class SortCommand extends ExCommand {\n  private readonly arguments: ISortCommandArguments;\n\n  constructor(args: ISortCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (isVisualMode(vimState.currentMode)) {\n      const { start, end } = vimState.editor.selection;\n      await this.sortLines(vimState, start.line, end.line);\n    } else {\n      await this.sortLines(vimState, 0, vimState.document.lineCount - 1);\n    }\n  }\n\n  async sortLines(vimState: VimState, startLine: number, endLine: number) {\n    let originalLines: string[] = [];\n\n    for (\n      let currentLine = startLine;\n      currentLine <= endLine && currentLine < vimState.document.lineCount;\n      currentLine++\n    ) {\n      originalLines.push(vimState.document.lineAt(currentLine).text);\n    }\n\n    const lastLineLength = originalLines[originalLines.length - 1].length;\n\n    if (this.arguments.unique) {\n      const seen = new Set<string>();\n      const uniqueLines: string[] = [];\n      for (const line of originalLines) {\n        const adjustedLine = this.arguments.ignoreCase ? line.toLowerCase() : line;\n        if (!seen.has(adjustedLine)) {\n          seen.add(adjustedLine);\n          uniqueLines.push(line);\n        }\n      }\n      originalLines = uniqueLines;\n    }\n\n    const sortedLines = this.arguments.ignoreCase\n      ? originalLines.sort((a: string, b: string) => a.localeCompare(b))\n      : originalLines.sort();\n\n    if (this.arguments.reverse) {\n      sortedLines.reverse();\n    }\n\n    const sortedContent = sortedLines.join('\\n');\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      range: new vscode.Range(startLine, 0, endLine, lastLineLength),\n      text: sortedContent,\n      diff: PositionDiff.exactPosition(\n        new vscode.Position(startLine, sortedLines[0].match(/\\S/)?.index ?? 0)\n      ),\n    });\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const { start, end } = range.resolve(vimState)!;\n\n    await this.sortLines(vimState, start, end);\n  }\n}\n","/* tslint:disable:no-bitwise */\n\nimport * as vscode from 'vscode';\nimport { Jump } from '../../jumps/jump';\nimport { SearchState, SearchDirection } from '../../state/searchState';\nimport { SubstituteState } from '../../state/substituteState';\nimport { VimError, ErrorCode } from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { configuration } from '../../configuration/configuration';\nimport { decoration } from '../../configuration/decoration';\nimport { globalState } from '../../state/globalState';\nimport { Position } from 'vscode';\nimport { StatusBar } from '../../statusBar';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { ExCommand } from '../../vimscript/exCommand';\n\n/**\n * NOTE: for \"pattern\", undefined is different from an empty string.\n * when it's undefined, it means to repeat the previous REPLACEMENT and ignore \"replace\".\n * when it's an empty string, it means to use the previous SEARCH (not replacement) state,\n * and replace with whatever's set by \"replace\" (even an empty string).\n */\nexport interface ISubstituteCommandArguments {\n  pattern: string | undefined;\n  replace: string;\n  flags: number;\n  count?: number;\n}\n\n/**\n * The flags that you can use for the substitute commands:\n * [&] Must be the first one: Keep the flags from the previous substitute command.\n * [c] Confirm each substitution.\n * [e] When the search pattern fails, do not issue an error message and, in\n *     particular, continue in maps as if no error occurred.\n * [g] Replace all occurrences in the line.  Without this argument, replacement\n *     occurs only for the first occurrence in each line.\n * [i] Ignore case for the pattern.\n * [I] Don't ignore case for the pattern.\n * [n] Report the number of matches, do not actually substitute.\n * [p] Print the line containing the last substitute.\n * [#] Like [p] and prepend the line number.\n * [l] Like [p] but print the text like |:list|.\n * [r] When the search pattern is empty, use the previously used search pattern\n *     instead of the search pattern from the last substitute or \":global\".\n */\nexport enum SubstituteFlags {\n  None = 0,\n  KeepPreviousFlags = 0x1, // TODO: use this flag\n  ConfirmEach = 0x2,\n  SuppressError = 0x4, // TODO: use this flag\n  ReplaceAll = 0x8,\n  IgnoreCase = 0x10,\n  NoIgnoreCase = 0x20, // TODO: use this flag\n  PrintCount = 0x40,\n  // TODO: use the following flags:\n  PrintLastMatchedLine = 0x80,\n  PrintLastMatchedLineWithNumber = 0x100,\n  PrintLastMatchedLineWithList = 0x200,\n  UsePreviousPattern = 0x400,\n}\n\n/**\n * vim has a distinctly different state for previous search and for previous substitute.  However, in SOME\n * cases a substitution will also update the search state along with the substitute state.\n *\n * Also, the substitute command itself will sometimes use the search state, and other times it will use the\n * substitute state.\n *\n * These are the following cases and how vim handles them:\n * 1. :s/this/that\n *   - standard search/replace\n *   - update substitution state\n *   - update search state too!\n * 2. :s or :s [flags]\n *   - use previous SUBSTITUTION state, and repeat previous substitution pattern and replace.\n *   - do not touch search state!\n *   - changing substitution state is dont-care cause we're repeating it ;)\n * 3. :s/ or :s// or :s///\n *   - use previous SEARCH state (not substitution), and DELETE the string matching the pattern (replace with nothing)\n *   - update substitution state\n *   - updating search state is dont-care cause we're repeating it ;)\n * 4. :s/this or :s/this/ or :s/this//\n *   - input is pattern - replacement is empty (delete)\n *   - update replacement state\n *   - update search state too!\n */\nexport class SubstituteCommand extends ExCommand {\n  public readonly arguments: ISubstituteCommandArguments;\n  protected abort: boolean;\n  constructor(args: ISubstituteCommandArguments) {\n    super();\n    this.arguments = args;\n    this.abort = false;\n  }\n\n  public override neovimCapable(): boolean {\n    // We need to use VSCode's quickpick capabilities to do confirmation\n    return (this.arguments.flags & SubstituteFlags.ConfirmEach) === 0;\n  }\n\n  getRegex(args: ISubstituteCommandArguments, vimState: VimState) {\n    let jsRegexFlags = '';\n\n    if (configuration.gdefault || configuration.substituteGlobalFlag) {\n      // the gdefault flag is on, then /g if on by default and /g negates that\n      if (!(args.flags & SubstituteFlags.ReplaceAll)) {\n        jsRegexFlags += 'g';\n      }\n    } else {\n      // the gdefault flag is off, then /g means replace all\n      if (args.flags & SubstituteFlags.ReplaceAll) {\n        jsRegexFlags += 'g';\n      }\n    }\n\n    if (args.flags & SubstituteFlags.IgnoreCase) {\n      jsRegexFlags += 'i';\n    }\n\n    if (args.pattern === undefined) {\n      // If no pattern is entered, use previous SUBSTITUTION state and don't update search state\n      // i.e. :s\n      const prevSubstituteState = globalState.substituteState;\n      if (prevSubstituteState === undefined || prevSubstituteState.searchPattern === '') {\n        throw VimError.fromCode(ErrorCode.NoPreviousSubstituteRegularExpression);\n      } else {\n        args.pattern = prevSubstituteState.searchPattern;\n        args.replace = prevSubstituteState.replaceString;\n      }\n    } else {\n      if (args.pattern === '') {\n        // If an explicitly empty pattern is entered, use previous search state (including search with * and #) and update both states\n        // e.g :s/ or :s///\n        const prevSearchState = globalState.searchState;\n        if (prevSearchState === undefined || prevSearchState.searchString === '') {\n          throw VimError.fromCode(ErrorCode.NoPreviousRegularExpression);\n        } else {\n          args.pattern = prevSearchState.searchString;\n        }\n      }\n      globalState.substituteState = new SubstituteState(args.pattern, args.replace);\n      globalState.searchState = new SearchState(\n        SearchDirection.Forward,\n        vimState.cursorStopPosition,\n        args.pattern,\n        { isRegex: true },\n        vimState.currentMode\n      );\n    }\n    return new RegExp(args.pattern, jsRegexFlags);\n  }\n\n  /**\n   * @returns the number of substitutions made on the given line\n   */\n  async replaceTextAtLine(line: number, regex: RegExp, vimState: VimState): Promise<number> {\n    const originalContent = vimState.document.lineAt(line).text;\n\n    const matches = originalContent.match(regex);\n    if (!matches) {\n      return 0;\n    }\n\n    let count = 0;\n\n    if (this.arguments.flags & SubstituteFlags.PrintCount) {\n      return matches.length;\n    } else if (this.arguments.flags & SubstituteFlags.ConfirmEach) {\n      // Loop through each match on this line and get confirmation before replacing\n      let newContent = originalContent;\n\n      const nonGlobalRegex = new RegExp(regex.source, regex.flags.replace('g', ''));\n      let matchPos = 0;\n\n      for (const match of matches) {\n        if (this.abort) {\n          break;\n        }\n\n        matchPos = newContent.indexOf(match, matchPos);\n\n        if (\n          await this.confirmReplacement(this.arguments.replace, line, vimState, match, matchPos)\n        ) {\n          count++;\n\n          const rangeEnd = newContent.length;\n          newContent =\n            newContent.slice(0, matchPos) +\n            newContent.slice(matchPos).replace(nonGlobalRegex, this.arguments.replace);\n\n          vimState.recordedState.transformer.addTransformation({\n            type: 'replaceText',\n            text: newContent,\n            range: new vscode.Range(new Position(line, 0), new Position(line, rangeEnd)),\n            cursorIndex: 0,\n          });\n\n          globalState.jumpTracker.recordJump(\n            new Jump({\n              document: vimState.document,\n              position: new Position(line, 0),\n            }),\n            Jump.fromStateNow(vimState)\n          );\n        }\n        matchPos += this.arguments.replace.length;\n      }\n    } else {\n      count = matches.length;\n\n      const newContent = originalContent.replace(regex, this.arguments.replace);\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: newContent,\n        range: new vscode.Range(new Position(line, 0), new Position(line, originalContent.length)),\n        // move cursor to BOL\n        diff: new Position(line, 0).subtract(new Position(line, newContent.length)),\n        cursorIndex: 0,\n      });\n\n      globalState.jumpTracker.recordJump(\n        new Jump({\n          document: vimState.document,\n          position: new Position(line, 0),\n        }),\n        Jump.fromStateNow(vimState)\n      );\n    }\n\n    return count;\n  }\n\n  async confirmReplacement(\n    replacement: string,\n    line: number,\n    vimState: VimState,\n    match: string,\n    matchIndex: number\n  ): Promise<boolean> {\n    const cancellationToken = new vscode.CancellationTokenSource();\n    const validSelections: string[] = ['y', 'n', 'a', 'q', 'l'];\n    let selection: string = '';\n\n    const searchRanges: vscode.Range[] = [\n      new vscode.Range(line, matchIndex, line, matchIndex + match.length),\n    ];\n\n    vimState.editor.revealRange(new vscode.Range(line, 0, line, 0));\n    vimState.editor.setDecorations(decoration.searchHighlight, searchRanges);\n\n    const prompt = `Replace with ${replacement} (${validSelections.join('/')})?`;\n    await vscode.window.showInputBox(\n      {\n        ignoreFocusOut: true,\n        prompt,\n        placeHolder: validSelections.join('/'),\n        validateInput: (input: string): string => {\n          if (validSelections.includes(input)) {\n            selection = input;\n            cancellationToken.cancel();\n          }\n          return prompt;\n        },\n      },\n      cancellationToken.token\n    );\n\n    if (selection === 'q' || selection === 'l' || !selection) {\n      this.abort = true;\n    } else if (selection === 'a') {\n      this.arguments.flags = this.arguments.flags & ~SubstituteFlags.ConfirmEach;\n    }\n\n    return selection === 'y' || selection === 'a' || selection === 'l';\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const regex = this.getRegex(this.arguments, vimState);\n    const selection = vimState.editor.selection;\n    const line = selection.start.isBefore(selection.end)\n      ? selection.start.line\n      : selection.end.line;\n\n    if (!this.abort) {\n      const substitutions = await this.replaceTextAtLine(line, regex, vimState);\n      this.setStatusBarText(vimState, substitutions, 1, regex);\n    }\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    let { start, end } = range.resolve(vimState)!;\n\n    if (this.arguments.count && this.arguments.count >= 0) {\n      start = end;\n      end = end + this.arguments.count - 1;\n    }\n\n    // TODO: Global Setting.\n    // TODO: There are differencies between Vim Regex and JS Regex.\n    const regex = this.getRegex(this.arguments, vimState);\n    let lines = 0;\n    let substitutions = 0;\n    for (\n      let currentLine = start;\n      currentLine <= end && currentLine < vimState.document.lineCount;\n      currentLine++\n    ) {\n      if (this.abort) {\n        break;\n      }\n      const count = await this.replaceTextAtLine(currentLine, regex, vimState);\n      if (count > 0) {\n        substitutions += count;\n        lines++;\n      }\n    }\n\n    this.setStatusBarText(vimState, substitutions, lines, regex);\n  }\n\n  private setStatusBarText(\n    vimState: VimState,\n    substitutions: number,\n    lines: number,\n    regex: RegExp\n  ) {\n    if (substitutions === 0) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.PatternNotFound, regex.source));\n    } else if (this.arguments.flags & SubstituteFlags.PrintCount) {\n      StatusBar.setText(\n        vimState,\n        `${substitutions} match${substitutions > 1 ? 'es' : ''} on ${lines} line${\n          lines > 1 ? 's' : ''\n        }`\n      );\n    } else if (substitutions > configuration.report) {\n      StatusBar.setText(\n        vimState,\n        `${substitutions} substitution${substitutions > 1 ? 's' : ''} on ${lines} line${\n          lines > 1 ? 's' : ''\n        }`\n      );\n    }\n  }\n}\n","import * as path from 'path';\nimport * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport enum Tab {\n  Next,\n  Previous,\n  First,\n  Last,\n  Absolute,\n  New,\n  Close,\n  Only,\n  Move,\n}\n\nexport interface ITabCommandArguments {\n  tab: Tab;\n  count?: number;\n  direction?: 'left' | 'right';\n  file?: string;\n}\n\n//\n//  Implements tab\n//  http://vimdoc.sourceforge.net/htmldoc/tabpage.html\n//\nexport class TabCommand extends ExCommand {\n  public readonly arguments: ITabCommandArguments;\n\n  constructor(args: ITabCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  private async executeCommandWithCount(count: number, command: string): Promise<void> {\n    for (let i = 0; i < count; i++) {\n      await vscode.commands.executeCommand(command);\n    }\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    switch (this.arguments.tab) {\n      case Tab.Absolute:\n        if (this.arguments.count !== undefined && this.arguments.count >= 0) {\n          await vscode.commands.executeCommand(\n            'workbench.action.openEditorAtIndex',\n            this.arguments.count\n          );\n        }\n        break;\n      case Tab.Next:\n        if (this.arguments.count !== undefined && this.arguments.count <= 0) {\n          break;\n        }\n\n        await this.executeCommandWithCount(\n          this.arguments.count || 1,\n          'workbench.action.nextEditorInGroup'\n        );\n        break;\n      case Tab.Previous:\n        if (this.arguments.count !== undefined && this.arguments.count <= 0) {\n          break;\n        }\n\n        await this.executeCommandWithCount(\n          this.arguments.count || 1,\n          'workbench.action.previousEditorInGroup'\n        );\n        break;\n      case Tab.First:\n        await vscode.commands.executeCommand('workbench.action.openEditorAtIndex1');\n        break;\n      case Tab.Last:\n        await vscode.commands.executeCommand('workbench.action.lastEditorInGroup');\n        break;\n      case Tab.New: {\n        const hasFile = !(this.arguments.file === undefined || this.arguments.file === '');\n        if (hasFile) {\n          const isAbsolute = path.isAbsolute(this.arguments.file!);\n          const isInWorkspace =\n            vscode.workspace.workspaceFolders !== undefined &&\n            vscode.workspace.workspaceFolders.length > 0;\n          const currentFilePath = vscode.window.activeTextEditor!.document.uri.fsPath;\n\n          let toOpenPath: string;\n          if (isAbsolute) {\n            toOpenPath = this.arguments.file!;\n          } else if (isInWorkspace) {\n            const workspacePath = vscode.workspace.workspaceFolders![0].uri.path;\n            toOpenPath = path.join(workspacePath, this.arguments.file!);\n          } else {\n            toOpenPath = path.join(path.dirname(currentFilePath), this.arguments.file!);\n          }\n\n          if (toOpenPath !== currentFilePath) {\n            await vscode.commands.executeCommand('vscode.open', vscode.Uri.file(toOpenPath));\n          }\n        } else {\n          await vscode.commands.executeCommand('workbench.action.files.newUntitledFile');\n        }\n        break;\n      }\n      case Tab.Close:\n        // Navigate the correct position\n        if (this.arguments.count === undefined) {\n          await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n          break;\n        }\n\n        if (this.arguments.count === 0) {\n          // Wrong paramter\n          break;\n        }\n\n        // TODO: Close Page {count}. Page count is one-based.\n        break;\n      case Tab.Only:\n        await vscode.commands.executeCommand('workbench.action.closeOtherEditors');\n        break;\n      case Tab.Move: {\n        const { count, direction } = this.arguments;\n        let args;\n        if (direction !== undefined) {\n          args = { to: direction, by: 'tab', value: count };\n        } else if (count === 0) {\n          args = { to: 'first' };\n        } else if (count === undefined) {\n          args = { to: 'last' };\n        } else {\n          args = { to: 'position', by: 'tab', value: count + 1 };\n        }\n        await vscode.commands.executeCommand('moveActiveEditor', args);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { CommandUndo } from '../../actions/commands/actions';\nimport { Position } from 'vscode';\nimport { ExCommand } from '../../vimscript/exCommand';\n\n//\n//  Implements :u[ndo]\n//  http://vimdoc.sourceforge.net/htmldoc/undo.html\n//\nexport class UndoCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    await new CommandUndo().exec(new Position(0, 0), vimState);\n  }\n}\n","import { ErrorCode, VimError } from '../../error';\nimport { StatusBar } from '../../statusBar';\nimport * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { Scanner } from '../scanner';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class VsCodeCommand extends ExCommand {\n  private command?: string;\n  private constructor(command?: string) {\n    super();\n    this.command = command;\n  }\n\n  public static parseArgs(args: string): VsCodeCommand {\n    const scanner = new Scanner(args);\n    scanner.skipWhiteSpace();\n    return new VsCodeCommand(scanner.isAtEof ? undefined : scanner.nextWord());\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (!this.command) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.ArgumentRequired));\n      return;\n    }\n    await vscode.commands.executeCommand(this.command);\n  }\n}\n","import * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\n\nexport interface IWallCommandArguments {\n  bang?: boolean;\n  range?: LineRange;\n}\n\n//\n//  Implements :wall (write all)\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:wall\n//\nexport class WallCommand extends ExCommand {\n  private readonly arguments: IWallCommandArguments;\n\n  constructor(args: IWallCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    // TODO : overwrite readonly files when bang? == true\n    await vscode.workspace.saveAll(false);\n  }\n}\n","import * as fs from 'platform/fs';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\nimport { Logger } from '../../util/logger';\nimport { StatusBar } from '../../statusBar';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\n\nexport interface IWriteCommandArguments {\n  opt?: string;\n  optValue?: string;\n  bang?: boolean;\n  range?: LineRange;\n  file?: string;\n  append?: boolean;\n  cmd?: string;\n  bgWrite?: boolean;\n}\n\n//\n//  Implements :write\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:write\n//\nexport class WriteCommand extends ExCommand {\n  public readonly arguments: IWriteCommandArguments;\n  private readonly logger = Logger.get('Write');\n\n  constructor(args: IWriteCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.arguments.opt) {\n      this.logger.warn('not implemented');\n      return;\n    } else if (this.arguments.file) {\n      this.logger.warn('not implemented');\n      return;\n    } else if (this.arguments.append) {\n      this.logger.warn('not implemented');\n      return;\n    } else if (this.arguments.cmd) {\n      this.logger.warn('not implemented');\n      return;\n    }\n\n    // defer saving the file to vscode if file is new (to present file explorer) or if file is a remote file\n    if (vimState.document.isUntitled || vimState.document.uri.scheme !== 'file') {\n      await this.background(vscode.commands.executeCommand('workbench.action.files.save'));\n      return;\n    }\n\n    try {\n      await fs.accessAsync(vimState.document.fileName, fs.constants.W_OK);\n      return this.save(vimState);\n    } catch (accessErr) {\n      if (this.arguments.bang) {\n        try {\n          await fs.chmodAsync(vimState.document.fileName, 666);\n          return this.save(vimState);\n        } catch (e) {\n          StatusBar.setText(vimState, e.message);\n        }\n      } else {\n        StatusBar.setText(vimState, accessErr.message);\n      }\n    }\n  }\n\n  private async save(vimState: VimState): Promise<void> {\n    await this.background(\n      vimState.document.save().then(\n        () => {\n          const text =\n            '\"' +\n            path.basename(vimState.document.fileName) +\n            '\" ' +\n            vimState.document.lineCount +\n            'L ' +\n            vimState.document.getText().length +\n            'C written';\n          StatusBar.setText(vimState, text);\n        },\n        (e) => StatusBar.setText(vimState, e)\n      )\n    );\n  }\n\n  private async background(fn: Thenable<void>): Promise<void> {\n    if (!this.arguments.bgWrite) {\n      await fn;\n    }\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport * as quit from './quit';\nimport * as write from './write';\n\n//\n// Implements :writequit\n// http://vimdoc.sourceforge.net/htmldoc/editing.html#write-quit\n//\nexport interface IWriteQuitCommandArguments {\n  // arguments\n  // [++opt]\n  opt?: string;\n  optValue?: string;\n  // wq! [++opt]\n  bang?: boolean;\n  // wq [++opt] {file}\n  file?: string;\n  // wq! [++opt] {file}\n  // [range]wq[!] [++opt] [file]\n  range?: LineRange;\n}\n\nexport class WriteQuitCommand extends ExCommand {\n  private readonly arguments: IWriteQuitCommandArguments;\n\n  constructor(args: IWriteQuitCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  // Writing command. Taken as a basis from the \"write.ts\" file.\n  async execute(vimState: VimState): Promise<void> {\n    const writeArgs: write.IWriteCommandArguments = {\n      opt: this.arguments.opt,\n      optValue: this.arguments.optValue,\n      bang: this.arguments.bang,\n      file: this.arguments.file,\n      range: this.arguments.range,\n    };\n\n    const writeCmd = new write.WriteCommand(writeArgs);\n    await writeCmd.execute(vimState);\n    const quitArgs: quit.IQuitCommandArguments = {\n      // wq! fails when no file name is provided\n      bang: false,\n      range: this.arguments.range,\n    };\n\n    const quitCmd = new quit.QuitCommand(quitArgs);\n    await quitCmd.execute(vimState);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport * as wall from '../commands/wall';\nimport * as quit from './quit';\n\n//\n// Implements :writequitall\n// http://vimdoc.sourceforge.net/htmldoc/editing.html#:wqall\n//\nexport interface IWriteQuitAllCommandArguments {\n  // arguments\n  // [++opt]\n  opt?: string;\n  optValue?: string;\n  // wqa! [++opt]\n  bang?: boolean;\n}\n\nexport class WriteQuitAllCommand extends ExCommand {\n  private readonly arguments: IWriteQuitAllCommandArguments;\n\n  constructor(args: IWriteQuitAllCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  // Writing command. Taken as a basis from the \"write.ts\" file.\n  async execute(vimState: VimState): Promise<void> {\n    const writeArgs: wall.IWallCommandArguments = {\n      bang: this.arguments.bang,\n    };\n\n    const quitArgs: quit.IQuitCommandArguments = {\n      // wq! fails when no file name is provided\n      bang: false,\n    };\n\n    const wallCmd = new wall.WallCommand(writeArgs);\n    await wallCmd.execute(vimState);\n\n    quitArgs.quitAll = true;\n    const quitCmd = new quit.QuitCommand(quitArgs);\n    await quitCmd.execute(vimState);\n  }\n}\n","import { Position } from 'vscode';\nimport { YankOperator } from '../../actions/operator';\nimport { RegisterMode } from '../../register/register';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { Scanner } from '../scanner';\n\nexport interface YankCommandArguments {\n  linesToYank?: number;\n  register?: string;\n}\n\nexport class YankCommand extends ExCommand {\n  private readonly arguments: YankCommandArguments;\n\n  constructor(args: YankCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  public static parseArgs(args: string): YankCommand {\n    if (!args || !args.trim()) {\n      return new YankCommand({});\n    }\n    /**\n     * :y[ank] [register] [cnt]\n     * :y[ank] [cnt] (if the first argument is a number)\n     */\n    const scanner = new Scanner(args);\n    const arg1 = scanner.nextWord(); // [cnt] or [register]\n    const arg2 = scanner.nextWord(); // [cnt] or EOF\n\n    let register;\n    let linesToYank;\n\n    if (isNaN(+arg1)) {\n      register = arg1;\n      linesToYank = isNaN(+arg2) ? undefined : +arg2;\n    } else {\n      linesToYank = +arg1;\n    }\n\n    return new YankCommand({\n      register,\n      linesToYank,\n    });\n  }\n\n  private async yank(vimState: VimState, start: Position, end: Position) {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    if (this.arguments.register) {\n      vimState.recordedState.registerName = this.arguments.register;\n    }\n\n    const cursorPosition = vimState.cursorStopPosition;\n\n    await new YankOperator().run(vimState, start.getLineBegin(), end.getLineEnd());\n\n    // YankOperator moves the cursor - undo that\n    vimState.cursorStopPosition = cursorPosition;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const linesToYank = this.arguments.linesToYank ?? 1;\n    const startPosition = vimState.cursorStartPosition;\n    const endPosition = linesToYank\n      ? startPosition.getDown(linesToYank - 1).getLineEnd()\n      : vimState.cursorStopPosition;\n    await this.yank(vimState, startPosition, endPosition);\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    /**\n     * If a [cnt] and [range] is specified (e.g. :.+2y3), :yank [cnt] is called from\n     * the end of the [range].\n     * Ex. if two lines are VisualLine highlighted, :<,>y3 will :y3\n     * from the end of the selected lines.\n     */\n    const { start, end } = range.resolve(vimState)!;\n    if (this.arguments.linesToYank) {\n      vimState.cursorStartPosition = new Position(end, 0);\n      await this.execute(vimState);\n      return;\n    }\n\n    await this.yank(vimState, new Position(start, 0), new Position(end, 0));\n  }\n}\n","// Provides state and behavior to scan an input string character by character.\nexport class Scanner {\n  static EOF: string = '__EOF__';\n  start: number = 0;\n  pos: number = 0;\n  input: string;\n\n  constructor(input: string) {\n    this.input = input;\n  }\n\n  // Returns the next character in the input, or EOF.\n  next(): string {\n    if (this.isAtEof) {\n      this.pos = this.input.length;\n      return Scanner.EOF;\n    }\n    const c = this.input[this.pos];\n    this.pos++;\n    return c;\n  }\n\n  nextWhile(fn: (c: string) => boolean): string {\n    if (this.isAtEof) {\n      return '';\n    }\n\n    while (true) {\n      const c = this.next();\n\n      if (c === Scanner.EOF) {\n        break;\n      } else if (!fn(c)) {\n        this.backup();\n        break;\n      }\n    }\n\n    return this.emit();\n  }\n\n  // Returns the next word in the input, or EOF.\n  nextWord(wordSeparators: string[] = [' ', '\\t']): string {\n    this.skipRun(wordSeparators);\n\n    if (this.isAtEof) {\n      this.pos = this.input.length;\n      return Scanner.EOF;\n    }\n\n    let result = '';\n    let c: string | undefined;\n\n    while (!this.isAtEof) {\n      c = this.next();\n\n      if (c === Scanner.EOF || wordSeparators.includes(c)) {\n        break;\n      }\n\n      result += c;\n    }\n\n    if (c && wordSeparators.includes(c)) {\n      this.backup();\n    }\n\n    this.ignore();\n    return result;\n  }\n\n  // Returns whether we've reached EOF.\n  get isAtEof(): boolean {\n    return this.pos >= this.input.length;\n  }\n\n  // Ignores the span of text between the current start and the current position.\n  ignore(): void {\n    this.start = this.pos;\n  }\n\n  // Returns the span of text between the current start and the current position.\n  emit(): string {\n    const s = this.input.substring(this.start, this.pos);\n    this.ignore();\n    return s;\n  }\n\n  // Returns the text from the current position to the end.\n  remaining(): string {\n    while (!this.isAtEof) {\n      this.next();\n    }\n    return this.emit();\n  }\n\n  backup(): void {\n    this.pos--;\n  }\n\n  // skips over c and ignores the text span\n  skip(c: string): void {\n    if (this.isAtEof) {\n      return;\n    }\n    let s = this.next();\n    while (!this.isAtEof) {\n      if (s !== c) {\n        break;\n      }\n      s = this.next();\n    }\n    this.backup();\n    this.ignore();\n  }\n\n  // skips text while any of chars matches and ignores the text span\n  skipRun(chars: string[]): void {\n    if (this.isAtEof) {\n      return;\n    }\n    while (!this.isAtEof) {\n      const c = this.next();\n      if (!chars.includes(c)) {\n        break;\n      }\n    }\n    this.backup();\n    this.ignore();\n  }\n\n  // skips over whitespace (tab, space) and ignores the text span\n  skipWhiteSpace(): void {\n    if (this.isAtEof) {\n      return;\n    }\n    let c: string | null = null;\n\n    while (!this.isAtEof) {\n      c = this.next();\n      if (c === ' ' || c === '\\t') {\n        continue;\n      }\n      break;\n    }\n\n    if (c !== Scanner.EOF && c !== ' ' && c !== '\\t') {\n      this.backup();\n    }\n    this.ignore();\n  }\n\n  expect(value: string): void {\n    if (!this.input.substring(this.pos).startsWith(value)) {\n      throw new Error('Unexpected character.');\n    }\n    this.pos += value.length;\n  }\n\n  expectOneOf(values: string[]): void {\n    const match = values.filter((s) => this.input.substr(this.pos).startsWith(s));\n    if (match.length !== 1) {\n      if (match.length > 1) {\n        throw new Error('Too many matches.');\n      }\n      throw new Error('Unexpected character.');\n    }\n    this.pos += match[0].length;\n  }\n}\n","import { BangCommand } from '../commands/bang';\n\nexport function parseBangCommand(args: string): BangCommand {\n  return new BangCommand({\n    command: args,\n  });\n}\n","import { BufferDeleteCommand, IBufferDeleteCommandArguments } from '../commands/bufferDelete';\nimport { Scanner } from '../scanner';\n\nexport function parseBufferDeleteCommandArgs(args: string): BufferDeleteCommand {\n  if (!args) {\n    return new BufferDeleteCommand({});\n  }\n  const scannedArgs: IBufferDeleteCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  }\n  const tabPosition = scanner.remaining();\n  scannedArgs.tabPosition = tabPosition.trim();\n  return new BufferDeleteCommand(scannedArgs);\n}\n","import { ErrorCode, VimError } from '../../error';\nimport { CloseCommand, ICloseCommandArguments } from '../commands/close';\nimport { Scanner } from '../scanner';\n\nexport function parseCloseCommandArgs(args: string): CloseCommand {\n  if (!args) {\n    return new CloseCommand({});\n  }\n  const scannedArgs: ICloseCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  } else if (c !== ' ') {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  scanner.skipWhiteSpace();\n  if (!scanner.isAtEof) {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  return new CloseCommand(scannedArgs);\n}\n","import { DeleteRangeCommand } from '../commands/deleteRange';\nimport { Scanner } from '../scanner';\n\nexport function parseDeleteRangeLinesCommandArgs(args: string): DeleteRangeCommand {\n  if (!args || !args.trim()) {\n    return new DeleteRangeCommand({});\n  }\n\n  /**\n   * :d[elete] [register] [cnt]\n   * :d[elete] [cnt] (if the first argument is a number)\n   */\n  const scanner = new Scanner(args);\n  const arg1 = scanner.nextWord(); // [cnt] or [register]\n  const arg2 = scanner.nextWord(); // [cnt] or EOF\n\n  let register;\n  let linesToRemove;\n\n  if (isNaN(+arg1)) {\n    register = arg1;\n    linesToRemove = isNaN(+arg2) ? undefined : +arg2;\n  } else {\n    linesToRemove = +arg1;\n  }\n\n  return new DeleteRangeCommand({\n    register,\n    linesToRemove,\n  });\n}\n","import { DigraphsCommand } from '../commands/digraph';\nimport { Scanner } from '../scanner';\n\nexport function parseDigraphCommandArgs(args: string): DigraphsCommand {\n  if (!args || !args.trim()) {\n    return new DigraphsCommand({});\n  }\n\n  return new DigraphsCommand({\n    arg: new Scanner(args).nextWord(),\n  });\n}\n","import { FileCommand, FilePosition } from '../commands/file';\nimport { Scanner } from '../scanner';\n\nexport function parseEditFileCommandArgs(args: string): FileCommand {\n  if (!args || !args.trim()) {\n    return new FileCommand({ name: '', createFileIfNotExists: true });\n  }\n\n  const scanner = new Scanner(args);\n  const bang = scanner.next() === '!';\n  if (scanner.isAtEof) {\n    return new FileCommand({ name: '', bang, createFileIfNotExists: true });\n  }\n\n  const name = scanner.remaining();\n  return new FileCommand({\n    name: name.trim(),\n    bang,\n    createFileIfNotExists: true,\n  });\n}\n\nexport function parseEditNewFileCommandArgs(): FileCommand {\n  return new FileCommand({\n    name: undefined,\n    createFileIfNotExists: true,\n  });\n}\n\nexport function parseEditFileInNewVerticalWindowCommandArgs(args: string): FileCommand {\n  let name = '';\n\n  if (args) {\n    const scanner = new Scanner(args);\n    name = scanner.nextWord();\n  }\n\n  return new FileCommand({\n    name,\n    position: FilePosition.NewWindowVerticalSplit,\n  });\n}\n\nexport function parseEditFileInNewHorizontalWindowCommandArgs(args: string): FileCommand {\n  let name = '';\n\n  if (args) {\n    const scanner = new Scanner(args);\n    name = scanner.nextWord();\n  }\n\n  return new FileCommand({\n    name,\n    position: FilePosition.NewWindowHorizontalSplit,\n  });\n}\n\nexport function parseEditNewFileInNewVerticalWindowCommandArgs(): FileCommand {\n  return new FileCommand({\n    name: undefined,\n    createFileIfNotExists: true,\n    position: FilePosition.NewWindowVerticalSplit,\n  });\n}\n\nexport function parseEditNewFileInNewHorizontalWindowCommandArgs(): FileCommand {\n  return new FileCommand({\n    name: undefined,\n    createFileIfNotExists: true,\n    position: FilePosition.NewWindowHorizontalSplit,\n  });\n}\n","import { FileInfoCommand } from '../commands/fileInfo';\n\nexport function parseFileInfoCommandArgs(args: string): FileInfoCommand {\n  // TODO: implement bang, file name parameters. http://vimdoc.sourceforge.net/htmldoc/editing.html#CTRL-G\n  return new FileInfoCommand();\n}\n","import { HistoryCommand, HistoryCommandType, IHistoryCommandArguments } from '../commands/history';\nimport { Scanner } from '../scanner';\n\nexport function parseHistoryCommandArgs(input?: string): HistoryCommand {\n  const args: IHistoryCommandArguments = { type: HistoryCommandType.Cmd };\n\n  if (input) {\n    const scanner = new Scanner(input);\n    scanner.skipWhiteSpace();\n    const type = scanner.nextWord();\n\n    if (type === '/' || (type.startsWith('s') && 'search'.startsWith(type))) {\n      args.type = HistoryCommandType.Search;\n    }\n  }\n\n  return new HistoryCommand(args);\n}\n","import { MarksCommand, DeleteMarksCommand } from '../commands/marks';\n\nexport function parseMarksCommandArgs(args: string): MarksCommand {\n  if (!args || !args.trim()) {\n    return new MarksCommand();\n  }\n  return new MarksCommand(args.split(''));\n}\n\nexport function parseMarksRemoveCommandArgs(args: string): DeleteMarksCommand {\n  if (!args) {\n    return new DeleteMarksCommand();\n  }\n  return new DeleteMarksCommand(args.trimStart());\n}\n","import { PutExCommand, IPutCommandArguments } from '../commands/put';\nimport { Scanner } from '../scanner';\n\nexport function parsePutExCommandArgs(args: string): PutExCommand {\n  if (!args) {\n    return new PutExCommand({});\n  }\n\n  const scannedArgs: IPutCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  } else {\n    scanner.backup();\n  }\n  scanner.skipWhiteSpace();\n\n  if (!scanner.isAtEof) {\n    scannedArgs.register = scanner.nextWord();\n  }\n  return new PutExCommand(scannedArgs);\n}\n","import { ErrorCode, VimError } from '../../error';\nimport { IQuitCommandArguments, QuitCommand } from '../commands/quit';\nimport { Scanner } from '../scanner';\n\nexport function parseQuitCommandArgs(args: string): QuitCommand {\n  if (!args) {\n    return new QuitCommand({});\n  }\n  const scannedArgs: IQuitCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  } else if (c !== ' ') {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  scanner.skipWhiteSpace();\n  if (!scanner.isAtEof) {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  return new QuitCommand(scannedArgs);\n}\n\nexport function parseQuitAllCommandArgs(args: string): QuitCommand {\n  const command = parseQuitCommandArgs(args);\n  command.arguments.quitAll = true;\n  return command;\n}\n","import { IReadCommandArguments, ReadCommand } from '../commands/read';\nimport { Scanner } from '../scanner';\n\nexport function parseReadCommandArgs(args: string): ReadCommand {\n  if (!args || !args.trim()) {\n    throw Error('Expected arguments.');\n  }\n\n  const scannedArgs: IReadCommandArguments = {};\n  const scanner = new Scanner(args);\n\n  scanner.skipWhiteSpace();\n  const c = scanner.next();\n  // read command has 2 forms - 'read <file-path>' and 'read! <shell-command>'\n  if (c === '!') {\n    scanner.ignore();\n    scanner.skipWhiteSpace();\n    scannedArgs.cmd = scanner.remaining();\n    if (!scannedArgs.cmd || scannedArgs.cmd.length === 0) {\n      throw Error('Expected shell command.');\n    }\n  } else {\n    scannedArgs.file = scanner.remaining();\n    if (!scannedArgs.file || scannedArgs.file.length === 0) {\n      throw Error('Expected file path.');\n    }\n  }\n\n  return new ReadCommand(scannedArgs);\n}\n","import { RegisterCommand } from '../commands/register';\nimport { Scanner } from '../scanner';\n\nexport function parseRegisterCommandArgs(args: string): RegisterCommand {\n  if (!args || !args.trim()) {\n    return new RegisterCommand({\n      registers: [],\n    });\n  }\n\n  const scanner = new Scanner(args);\n  const regs: string[] = [];\n  let reg = scanner.nextWord();\n  while (reg !== Scanner.EOF) {\n    regs.push(reg);\n    reg = scanner.nextWord();\n  }\n\n  return new RegisterCommand({\n    registers: regs,\n  });\n}\n","import { IOptionArgs, SetOptionOperator, SetOptionsCommand } from '../commands/setoptions';\nimport { Scanner } from '../scanner';\n\nexport function parseOption(args?: string): IOptionArgs {\n  const scanner = new Scanner(args ?? '');\n  scanner.skipWhiteSpace();\n\n  if (scanner.isAtEof) {\n    return {};\n  }\n\n  const optionName = scanner.nextWord('?!&=:^+-'.split(''));\n\n  if (optionName.startsWith('no')) {\n    return {\n      name: optionName.substring(2, optionName.length),\n      operator: SetOptionOperator.Reset,\n    };\n  }\n\n  if (optionName.startsWith('inv')) {\n    return {\n      name: optionName.substring(3, optionName.length),\n      operator: SetOptionOperator.Invert,\n    };\n  }\n\n  scanner.skipWhiteSpace();\n\n  if (scanner.isAtEof) {\n    return {\n      name: optionName,\n      operator: SetOptionOperator.Set,\n    };\n  }\n\n  const operator = scanner.next();\n  const optionArgs: IOptionArgs = {\n    name: optionName,\n    value: scanner.nextWord([]),\n  };\n\n  switch (operator) {\n    case '=':\n    case ':':\n      optionArgs.operator = SetOptionOperator.Equal;\n      break;\n    case '!':\n      optionArgs.operator = SetOptionOperator.Invert;\n      break;\n    case '^':\n      optionArgs.operator = SetOptionOperator.Multiply;\n      break;\n    case '+':\n      optionArgs.operator = SetOptionOperator.Append;\n      break;\n    case '-':\n      optionArgs.operator = SetOptionOperator.Subtract;\n      break;\n    case '?':\n      optionArgs.operator = SetOptionOperator.Info;\n      break;\n    case '&':\n      optionArgs.operator = SetOptionOperator.Reset;\n      break;\n    default:\n      throw new Error(`Unsupported operator (${operator}).`);\n  }\n\n  return optionArgs;\n}\n\nexport function parseOptionsCommandArgs(args: string): SetOptionsCommand {\n  return new SetOptionsCommand(parseOption(args));\n}\n","import { SortCommand } from '../commands/sort';\nimport { Scanner } from '../scanner';\n\nexport function parseSortCommandArgs(args: string): SortCommand {\n  if (!args || !args.trim()) {\n    return new SortCommand({ reverse: false, ignoreCase: false, unique: false });\n  }\n\n  const scanner = new Scanner(args);\n  const reverse = scanner.next() === '!';\n  if (!reverse) {\n    scanner.backup();\n  }\n\n  const flags = scanner.nextWord();\n  const ignoreCase = flags.includes('i');\n  const unique = flags.includes('u');\n\n  return new SortCommand({\n    reverse,\n    ignoreCase,\n    unique,\n  });\n}\n","/* tslint:disable:no-bitwise */\n\nimport { Scanner } from '../scanner';\nimport * as error from '../../error';\nimport { SubstituteCommand, SubstituteFlags } from '../commands/substitute';\n\nfunction isValidDelimiter(char: string): boolean {\n  return !!/^[^\\w\\s\\\\|\"]{1}$/g.exec(char);\n}\n\nfunction parsePattern(scanner: Scanner, delimiter: string): [string, boolean] {\n  let pattern = '';\n  while (!scanner.isAtEof) {\n    let currentChar = scanner.next();\n\n    if (currentChar === delimiter) {\n      return [pattern, true]; // found second delimiter\n    } else if (currentChar === '\\\\') {\n      if (!scanner.isAtEof) {\n        currentChar = scanner.next();\n        if (currentChar === delimiter) {\n          pattern += delimiter;\n        } else {\n          pattern += '\\\\' + currentChar;\n        }\n      } else {\n        pattern += '\\\\\\\\'; // :s/\\ is treated like :s/\\\\\n      }\n    } else {\n      pattern += currentChar;\n    }\n  }\n  return [pattern, false];\n}\n\n// See Vim's sub-replace-special documentation\n// TODO: \\u, \\U, \\l, \\L, \\e, \\E\nconst replaceEscapes = {\n  b: '\\b',\n  r: '\\r',\n  n: '\\n',\n  t: '\\t',\n  '&': '$&',\n  '0': '$0',\n  '1': '$1',\n  '2': '$2',\n  '3': '$3',\n  '4': '$4',\n  '5': '$5',\n  '6': '$6',\n  '7': '$7',\n  '8': '$8',\n  '9': '$9',\n};\n\nfunction parseReplace(scanner: Scanner, delimiter: string): string {\n  let replace = '';\n  while (!scanner.isAtEof) {\n    let currentChar = scanner.next();\n\n    if (currentChar === delimiter) {\n      return replace; // found second delimiter\n    } else if (currentChar === '\\\\') {\n      if (!scanner.isAtEof) {\n        currentChar = scanner.next();\n        if (currentChar === delimiter) {\n          replace += delimiter;\n        } else if (replaceEscapes.hasOwnProperty(currentChar)) {\n          replace += replaceEscapes[currentChar];\n        } else {\n          replace += currentChar;\n        }\n      } else {\n        replace += '\\\\'; // :s/.../\\ is treated like :s/.../\\\\\n      }\n    } else {\n      replace += currentChar;\n    }\n  }\n  return replace;\n}\n\nfunction parseSubstituteFlags(scanner: Scanner): number {\n  let flags: number = 0;\n  let index = 0;\n  while (true) {\n    if (scanner.isAtEof) {\n      break;\n    }\n\n    const c = scanner.next();\n    switch (c) {\n      case '&':\n        if (index === 0) {\n          flags |= SubstituteFlags.KeepPreviousFlags;\n        } else {\n          // Raise Error\n          return SubstituteFlags.None;\n        }\n        break;\n      case 'c':\n        flags |= SubstituteFlags.ConfirmEach;\n        break;\n      case 'e':\n        flags |= SubstituteFlags.SuppressError;\n        break;\n      case 'g':\n        flags |= SubstituteFlags.ReplaceAll;\n        break;\n      case 'i':\n        flags |= SubstituteFlags.IgnoreCase;\n        break;\n      case 'I':\n        flags |= SubstituteFlags.NoIgnoreCase;\n        break;\n      case 'n':\n        flags |= SubstituteFlags.PrintCount;\n        break;\n      case 'p':\n        flags |= SubstituteFlags.PrintLastMatchedLine;\n        break;\n      case '#':\n        flags |= SubstituteFlags.PrintLastMatchedLineWithNumber;\n        break;\n      case 'l':\n        flags |= SubstituteFlags.PrintLastMatchedLineWithList;\n        break;\n      case 'r':\n        flags |= SubstituteFlags.UsePreviousPattern;\n        break;\n      default:\n        scanner.backup();\n        return flags;\n    }\n\n    index++;\n  }\n\n  return flags;\n}\n\nfunction parseCount(scanner: Scanner): number {\n  let countStr = '';\n\n  while (true) {\n    if (scanner.isAtEof) {\n      break;\n    }\n    countStr += scanner.next();\n  }\n\n  const count = Number.parseInt(countStr, 10);\n\n  // TODO: If count is not valid number, raise error\n  return Number.isInteger(count) ? count : -1;\n}\n/**\n * Substitute\n * :[range]s[ubstitute]/{pattern}/{string}/[flags] [count]\n * For each line in [range] replace a match of {pattern} with {string}.\n * {string} can be a literal string, or something special; see |sub-replace-special|.\n */\nexport function parseSubstituteCommandArgs(args: string): SubstituteCommand {\n  try {\n    let searchPattern: string | undefined;\n    let replaceString: string;\n    let flags: number;\n    let count: number;\n\n    if (!args || !args.trim()) {\n      // special case for :s\n      return new SubstituteCommand({\n        pattern: undefined,\n        replace: '', // ignored in this context\n        flags: SubstituteFlags.None,\n      });\n    }\n    let scanner: Scanner;\n\n    const delimiter = args[0];\n\n    if (isValidDelimiter(delimiter)) {\n      if (args.length === 1) {\n        // special case for :s/ or other delimiters\n        return new SubstituteCommand({\n          pattern: '',\n          replace: '',\n          flags: SubstituteFlags.None,\n        });\n      }\n\n      let secondDelimiterFound: boolean;\n\n      scanner = new Scanner(args.substr(1, args.length - 1));\n      [searchPattern, secondDelimiterFound] = parsePattern(scanner, delimiter);\n\n      if (!secondDelimiterFound) {\n        // special case for :s/search\n        return new SubstituteCommand({\n          pattern: searchPattern,\n          replace: '',\n          flags: SubstituteFlags.None,\n        });\n      }\n      replaceString = parseReplace(scanner, delimiter);\n    } else {\n      // if it's not a valid delimiter, it must be flags, so start parsing from here\n      searchPattern = undefined;\n      replaceString = '';\n      scanner = new Scanner(args);\n    }\n\n    scanner.skipWhiteSpace();\n    flags = parseSubstituteFlags(scanner);\n    scanner.skipWhiteSpace();\n    count = parseCount(scanner);\n\n    return new SubstituteCommand({\n      pattern: searchPattern,\n      replace: replaceString,\n      flags,\n      count,\n    });\n  } catch (e) {\n    throw error.VimError.fromCode(error.ErrorCode.PatternNotFound);\n  }\n}\n","import { Scanner } from '../scanner';\nimport { ErrorCode, VimError } from '../../error';\nimport { Tab, TabCommand } from '../commands/tab';\n\nconst isDigit = (c: string) => '0' <= c && c <= '9';\n\nfunction parseCount(args: string): number | undefined {\n  if (!args) {\n    return undefined;\n  }\n\n  const scanner = new Scanner(args);\n  scanner.skipWhiteSpace();\n\n  if (scanner.isAtEof) {\n    return undefined;\n  }\n\n  const input = scanner.nextWhile(isDigit);\n  scanner.skipWhiteSpace();\n\n  const count = Number.parseInt(input, 10);\n\n  if (scanner.isAtEof && Number.isInteger(count) && count >= 0) {\n    return count;\n  } else {\n    throw VimError.fromCode(ErrorCode.InvalidArgument);\n  }\n}\n\nfunction parseCountOrOffset(args: string): {\n  count: number | undefined;\n  direction?: 'left' | 'right';\n} {\n  if (!args) {\n    return { count: undefined };\n  }\n\n  const scanner = new Scanner(args);\n  scanner.skipWhiteSpace();\n\n  if (scanner.isAtEof) {\n    return { count: undefined };\n  }\n\n  const c = scanner.next();\n\n  const direction = (() => {\n    if (c === '-') {\n      return 'left';\n    } else if (c === '+') {\n      return 'right';\n    } else {\n      return undefined;\n    }\n  })();\n\n  if (direction === undefined) {\n    scanner.backup();\n  } else {\n    scanner.ignore();\n  }\n\n  const input = scanner.nextWhile(isDigit);\n  scanner.skipWhiteSpace();\n\n  if (scanner.isAtEof) {\n    const count = input.length === 0 ? 1 : Number.parseInt(input, 10);\n\n    if (Number.isInteger(count) && (count > 0 || (direction === undefined && count === 0))) {\n      return { count, direction };\n    }\n  }\n\n  throw VimError.fromCode(ErrorCode.InvalidArgument);\n}\n\n/**\n * :tabn[ext] Go to the next tab page.\n * :tabn[ext] {count} Go to tab page {count}.\n */\nexport function parseTabNCommandArgs(args: string): TabCommand {\n  return new TabCommand({\n    tab: Tab.Next,\n    count: parseCount(args),\n  });\n}\n\n/**\n * :tabp[revious] Go to the previous tab page.  Wraps around from the first one  to the last one.\n * :tabp[revious] {count} Go {count} tab pages back.\n */\nexport function parseTabPCommandArgs(args: string): TabCommand {\n  return new TabCommand({\n    tab: Tab.Previous,\n    count: parseCount(args),\n  });\n}\n\n/**\n * :tabfir[st]  Go to the first tab page.\n */\nexport function parseTabFirstCommandArgs(args: string): TabCommand {\n  return new TabCommand({\n    tab: Tab.First,\n  });\n}\n\n/**\n * :tabl[ast]  Go to the last tab page.\n */\nexport function parseTabLastCommandArgs(args: string): TabCommand {\n  return new TabCommand({\n    tab: Tab.Last,\n  });\n}\n\n/**\n * :tabe[dit]\n * :tabnew Open a new tab page with an empty window, after the current tab page.\n */\nexport function parseTabNewCommandArgs(args: string): TabCommand {\n  let name = '';\n\n  if (args) {\n    const scanner = new Scanner(args);\n    name = scanner.nextWord();\n  }\n\n  return new TabCommand({\n    tab: Tab.New,\n    file: name,\n  });\n}\n\n/**\n * :tabc[lose][!]  Close current tab page.\n * :tabc[lose][!] {count}. Close tab page {count}.\n */\nexport function parseTabCloseCommandArgs(args: string): TabCommand {\n  return new TabCommand({\n    tab: Tab.Close,\n    count: parseCount(args),\n  });\n}\n\nexport function parseTabOnlyCommandArgs(args: string): TabCommand {\n  return new TabCommand({\n    tab: Tab.Only,\n  });\n}\n\n/**\n * :tabm[ove] [N]\n * :tabm[ove] +[N]\n * :tabm[ove] -[N]\n */\nexport function parseTabMovementCommandArgs(args: string): TabCommand {\n  const { count, direction } = parseCountOrOffset(args);\n  return new TabCommand({\n    tab: Tab.Move,\n    count,\n    direction,\n  });\n}\n","import { ErrorCode, VimError } from '../../error';\nimport { IWallCommandArguments, WallCommand } from '../commands/wall';\nimport { Scanner } from '../scanner';\n\nexport function parseWallCommandArgs(args: string): WallCommand {\n  if (!args) {\n    return new WallCommand({});\n  }\n  const scannedArgs: IWallCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  } else if (c !== ' ') {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  scanner.skipWhiteSpace();\n  if (!scanner.isAtEof) {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  return new WallCommand(scannedArgs);\n}\n","import { IWriteCommandArguments, WriteCommand } from '../commands/write';\nimport { Scanner } from '../scanner';\n\nexport function parseWriteCommandArgs(args: string): WriteCommand {\n  if (!args) {\n    return new WriteCommand({ bgWrite: true });\n  }\n  const scannedArgs: IWriteCommandArguments = { bgWrite: true };\n  const scanner = new Scanner(args);\n  while (true) {\n    scanner.skipWhiteSpace();\n    if (scanner.isAtEof) {\n      break;\n    }\n    let c = scanner.next();\n    switch (c) {\n      case '!':\n        if (scanner.start > 0) {\n          // :write !cmd\n          scanner.ignore();\n          while (!scanner.isAtEof) {\n            scanner.next();\n          }\n          // vim ignores silently if no command after :w !\n          scannedArgs.cmd = scanner.emit().trim() || undefined;\n          continue;\n        }\n        // :write!\n        scannedArgs.bang = true;\n        scanner.ignore();\n        continue;\n      case '+':\n        // :write ++opt=value\n        scanner.expect('+');\n        scanner.ignore();\n        scanner.expectOneOf(['bin', 'nobin', 'ff', 'enc']);\n        scannedArgs.opt = scanner.emit();\n        scanner.expect('=');\n        scanner.ignore();\n        while (!scanner.isAtEof) {\n          c = scanner.next();\n          if (c !== ' ' && c !== '\\t') {\n            continue;\n          }\n          scanner.backup();\n          continue;\n        }\n        const value = scanner.emit();\n        if (!value) {\n          throw new Error('Expected value for option.');\n        }\n        scannedArgs.optValue = value;\n        continue;\n      default:\n        throw new Error('Not implemented.');\n    }\n  }\n  // TODO: actually parse arguments.\n  // ++bin ++nobin ++ff ++enc =VALUE\n  return new WriteCommand(scannedArgs);\n}\n","import { IWriteQuitCommandArguments, WriteQuitCommand } from '../commands/writequit';\nimport { Scanner } from '../scanner';\n\nexport function parseWriteQuitCommandArgs(args: string): WriteQuitCommand {\n  if (!args) {\n    return new WriteQuitCommand({});\n  }\n  const scannedArgs: IWriteQuitCommandArguments = {};\n  const scanner = new Scanner(args);\n  while (true) {\n    scanner.skipWhiteSpace();\n    if (scanner.isAtEof) {\n      break;\n    }\n    let c = scanner.next();\n    switch (c) {\n      case '!':\n        // :writequit!\n        scannedArgs.bang = true;\n        scanner.ignore();\n        continue;\n      case '+':\n        // :writequit ++opt=value\n        scanner.expect('+');\n        scanner.ignore();\n        scanner.expectOneOf(['bin', 'nobin', 'ff', 'enc']);\n        scannedArgs.opt = scanner.emit();\n        scanner.expect('=');\n        scanner.ignore();\n        while (!scanner.isAtEof) {\n          c = scanner.next();\n          if (c !== ' ' && c !== '\\t') {\n            continue;\n          }\n          scanner.backup();\n          continue;\n        }\n        const value = scanner.emit();\n        if (!value) {\n          throw new Error('Expected value for option.');\n        }\n        scannedArgs.optValue = value;\n        continue;\n      default:\n        throw new Error('Not implemented');\n    }\n  }\n  // TODO: parse the stuff (it's really not).\n  // ++bin ++nobin ++ff ++enc =VALUE\n  return new WriteQuitCommand(scannedArgs);\n}\n","import { ErrorCode, VimError } from '../../error';\nimport { IWriteQuitAllCommandArguments, WriteQuitAllCommand } from '../commands/writequitall';\nimport { Scanner } from '../scanner';\n\nexport function parseWriteQuitAllCommandArgs(args: string): WriteQuitAllCommand {\n  if (!args) {\n    return new WriteQuitAllCommand({});\n  }\n  const scannedArgs: IWriteQuitAllCommandArguments = {};\n  const scanner = new Scanner(args);\n  const c = scanner.next();\n  if (c === '!') {\n    scannedArgs.bang = true;\n    scanner.ignore();\n  } else if (c !== ' ') {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  scanner.skipWhiteSpace();\n  if (!scanner.isAtEof) {\n    throw VimError.fromCode(ErrorCode.TrailingCharacters);\n  }\n  return new WriteQuitAllCommand(scannedArgs);\n}\n","import { VimState } from '../../state/vimState';\nimport { Position } from 'vscode';\nimport { configuration } from '../../configuration/configuration';\n\nexport type Pairing = {\n  match: string;\n  isNextMatchForward: boolean;\n  directionless?: boolean;\n};\n\n/**\n * PairMatcher finds the position matching the given character, respecting nested\n * instances of the pair.\n */\nexport class PairMatcher {\n  static pairings: {\n    [key: string]: Pairing;\n  } = {\n    '(': { match: ')', isNextMatchForward: true },\n    '{': { match: '}', isNextMatchForward: true },\n    '[': { match: ']', isNextMatchForward: true },\n    ')': { match: '(', isNextMatchForward: false },\n    '}': { match: '{', isNextMatchForward: false },\n    ']': { match: '[', isNextMatchForward: false },\n\n    // These characters can't be used for \"%\"-based matching, but are still\n    // useful for text objects.\n    // matchesWithPercentageMotion can be overwritten with configuration.matchpairs\n    '<': { match: '>', isNextMatchForward: true },\n    '>': { match: '<', isNextMatchForward: false },\n    // These are useful for deleting closing and opening quotes, but don't seem to negatively\n    // affect how text objects such as `ci\"` work, which was my worry.\n    '\"': { match: '\"', isNextMatchForward: false, directionless: true },\n    \"'\": { match: \"'\", isNextMatchForward: false, directionless: true },\n    '`': { match: '`', isNextMatchForward: false, directionless: true },\n  };\n\n  private static findPairedChar(\n    position: Position,\n    charToFind: string,\n    charToStack: string,\n    stackHeight: number,\n    isNextMatchForward: boolean,\n    vimState: VimState,\n    allowCurrentPosition: boolean\n  ): Position | undefined {\n    let lineNumber = position.line;\n    const linePosition = position.character;\n    const lineCount = vimState.document.lineCount;\n    const cursorChar = vimState.document.lineAt(position).text[position.character];\n    if (\n      allowCurrentPosition &&\n      vimState.cursorStartPosition.isEqual(vimState.cursorStopPosition) &&\n      cursorChar === charToFind\n    ) {\n      return position;\n    }\n\n    while (PairMatcher.keepSearching(lineNumber, lineCount, isNextMatchForward)) {\n      let lineText = vimState.document.lineAt(lineNumber).text.split('');\n      const originalLineLength = lineText.length;\n      if (lineNumber === position.line) {\n        if (isNextMatchForward) {\n          lineText = lineText.slice(linePosition + 1, originalLineLength);\n        } else {\n          lineText = lineText.slice(0, linePosition);\n        }\n      }\n\n      while (true) {\n        if (lineText.length <= 0 || stackHeight <= -1) {\n          break;\n        }\n\n        let nextChar: string | undefined;\n        if (isNextMatchForward) {\n          nextChar = lineText.shift();\n        } else {\n          nextChar = lineText.pop();\n        }\n\n        if (nextChar === charToStack) {\n          stackHeight++;\n        } else if (nextChar === charToFind) {\n          stackHeight--;\n        } else {\n          continue;\n        }\n      }\n\n      if (stackHeight <= -1) {\n        let pairMemberChar: number;\n        if (isNextMatchForward) {\n          pairMemberChar = Math.max(0, originalLineLength - lineText.length - 1);\n        } else {\n          pairMemberChar = lineText.length;\n        }\n        return new Position(lineNumber, pairMemberChar);\n      }\n\n      if (isNextMatchForward) {\n        lineNumber++;\n      } else {\n        lineNumber--;\n      }\n    }\n    return undefined;\n  }\n\n  private static keepSearching(lineNumber: number, lineCount: number, isNextMatchForward: boolean) {\n    if (isNextMatchForward) {\n      return lineNumber <= lineCount - 1;\n    } else {\n      return lineNumber >= 0;\n    }\n  }\n\n  static getPercentPairing(char: string): Pairing | undefined {\n    for (const pairing of configuration.matchpairs.split(',')) {\n      const components = pairing.split(':');\n      if (components.length === 2) {\n        if (components[0] === char) {\n          return {\n            match: components[1],\n            isNextMatchForward: true,\n          };\n        } else if (components[1] === char) {\n          return {\n            match: components[0],\n            isNextMatchForward: false,\n          };\n        }\n      }\n    }\n    return undefined;\n  }\n\n  static nextPairedChar(\n    position: Position,\n    charToMatch: string,\n    vimState: VimState,\n    allowCurrentPosition: boolean\n  ): Position | undefined {\n    /**\n     * We do a fairly basic implementation that only tracks the state of the type of\n     * character you're over and its pair (e.g. \"[\" and \"]\"). This is similar to\n     * what Vim does.\n     *\n     * It can't handle strings very well - something like \"|( ')' )\" where | is the\n     * cursor will cause it to go to the ) in the quotes, even though it should skip over it.\n     *\n     * PRs welcomed! (TODO)\n     * Though ideally VSC implements https://github.com/Microsoft/vscode/issues/7177\n     */\n    const pairing = this.pairings[charToMatch];\n\n    if (pairing === undefined || pairing.directionless) {\n      return undefined;\n    }\n\n    const stackHeight = 0;\n    const charToFind = pairing.match;\n    const charToStack = charToMatch;\n\n    return PairMatcher.findPairedChar(\n      position,\n      charToFind,\n      charToStack,\n      stackHeight,\n      pairing.isNextMatchForward,\n      vimState,\n      allowCurrentPosition\n    );\n  }\n}\n","enum QuoteMatch {\n  Opening,\n  Closing,\n}\n\n/**\n * QuoteMatcher matches quoted strings, respecting escaped quotes (\\\") and friends\n */\nexport class QuoteMatcher {\n  static readonly escapeChar = '\\\\';\n\n  private readonly quoteMap: QuoteMatch[] = [];\n\n  constructor(quote: '\"' | \"'\" | '`', corpus: string) {\n    let openingQuote = true;\n    // Loop over corpus, marking quotes and respecting escape characters.\n    for (let i = 0; i < corpus.length; i++) {\n      if (corpus[i] === QuoteMatcher.escapeChar) {\n        i += 1;\n        continue;\n      }\n      if (corpus[i] === quote) {\n        this.quoteMap[i] = openingQuote ? QuoteMatch.Opening : QuoteMatch.Closing;\n        openingQuote = !openingQuote;\n      }\n    }\n  }\n\n  public surroundingQuotes(cursorIndex: number): [number, number] | undefined {\n    const cursorQuoteType = this.quoteMap[cursorIndex];\n    if (cursorQuoteType === QuoteMatch.Opening) {\n      const closing = this.getNextQuote(cursorIndex);\n      return closing !== undefined ? [cursorIndex, closing] : undefined;\n    } else if (cursorQuoteType === QuoteMatch.Closing) {\n      return [this.getPrevQuote(cursorIndex)!, cursorIndex];\n    } else {\n      const opening = this.getPrevQuote(cursorIndex) ?? this.getNextQuote(cursorIndex);\n\n      if (opening !== undefined) {\n        const closing = this.getNextQuote(opening);\n        if (closing !== undefined) {\n          return [opening, closing];\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  private getNextQuote(start: number): number | undefined {\n    for (let i = start + 1; i < this.quoteMap.length; i++) {\n      if (this.quoteMap[i] !== undefined) {\n        return i;\n      }\n    }\n\n    return undefined;\n  }\n\n  private getPrevQuote(start: number): number | undefined {\n    for (let i = start - 1; i >= 0; i--) {\n      if (this.quoteMap[i] !== undefined) {\n        return i;\n      }\n    }\n\n    return undefined;\n  }\n}\n","import { TextEditor } from '../../textEditor';\nimport { VimState } from '../../state/vimState';\n\ntype Tag = { name: string; type: 'close' | 'open'; startPos: number; endPos: number };\ntype MatchedTag = {\n  tag: string;\n  openingTagStart: number;\n  openingTagEnd: number;\n  closingTagStart: number;\n  closingTagEnd: number;\n};\n\nexport class TagMatcher {\n  // see regexr.com/3t585\n  static TAG_REGEX = /\\<(\\/)?([^\\>\\<\\s\\/]+)(?:[^\\>\\<]*?)(\\/)?\\>/g;\n  static OPEN_FORWARD_SLASH = 1;\n  static TAG_NAME = 2;\n  static CLOSE_FORWARD_SLASH = 3;\n\n  openStart: number | undefined;\n  openEnd: number | undefined;\n  closeStart: number | undefined;\n  closeEnd: number | undefined;\n\n  constructor(corpus: string, position: number, vimState: VimState) {\n    let match = TagMatcher.TAG_REGEX.exec(corpus);\n    const tags: Tag[] = [];\n\n    // Gather all the existing tags.\n    while (match) {\n      // Node is a self closing tag, skip.\n      if (match[TagMatcher.CLOSE_FORWARD_SLASH]) {\n        match = TagMatcher.TAG_REGEX.exec(corpus);\n        continue;\n      }\n\n      tags.push({\n        name: match[TagMatcher.TAG_NAME],\n        type: match[TagMatcher.OPEN_FORWARD_SLASH] ? 'close' : 'open',\n        startPos: match.index,\n        endPos: TagMatcher.TAG_REGEX.lastIndex,\n      });\n\n      match = TagMatcher.TAG_REGEX.exec(corpus);\n    }\n\n    const stack: Tag[] = [];\n    const matchedTags: MatchedTag[] = [];\n\n    for (const tag of tags) {\n      // We have to push on the stack\n      // if it is an open tag.\n      if (tag.type === 'open') {\n        stack.push(tag);\n      } else {\n        // We have an unmatched closing tag,\n        // so try and match it with any existing tag.\n        for (let i = stack.length - 1; i >= 0; i--) {\n          const openNode = stack[i];\n\n          if (openNode.type === 'open' && openNode.name === tag.name) {\n            // A matching tag was found, ignore\n            // any tags that were in between.\n            matchedTags.push({\n              tag: openNode.name,\n              openingTagStart: openNode.startPos,\n              openingTagEnd: openNode.endPos,\n              closingTagStart: tag.startPos,\n              closingTagEnd: tag.endPos,\n            });\n\n            stack.splice(i);\n            break;\n          }\n        }\n      }\n    }\n\n    const firstNonWhitespacePositionOnLine = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStartPosition.line\n    );\n\n    /**\n     * This adjustment fixes the following situation:\n     * <foo>\n     * |  <bar>\n     *    test\n     *    </bar>\n     * </foo>\n     * Now in tag matching situations, the tag opening on the cursor line is considered as well\n     * (if there is only whitespace before the tag and the cursor is standing on these whitespaces)\n     */\n    const startPos =\n      vimState.cursorStartPosition.character < firstNonWhitespacePositionOnLine.character\n        ? firstNonWhitespacePositionOnLine\n        : vimState.cursorStartPosition;\n\n    const startPosOffset = vimState.document.offsetAt(startPos);\n    const endPosOffset = position;\n    const tagsSurrounding = matchedTags.filter((n) => {\n      return startPosOffset >= n.openingTagStart && endPosOffset < n.closingTagEnd;\n    });\n\n    if (!tagsSurrounding.length) {\n      return;\n    }\n\n    const nodeSurrounding = this.determineRelevantTag(\n      tagsSurrounding,\n      startPosOffset,\n      vimState.cursorStartPosition.compareTo(vimState.cursorStopPosition) !== 0\n    );\n\n    if (!nodeSurrounding) {\n      return;\n    }\n\n    this.openStart = nodeSurrounding.openingTagStart;\n    this.closeEnd = nodeSurrounding.closingTagEnd;\n    // if the inner tag content is already selected, expand to enclose tags with 'it' as in vim\n    if (\n      startPosOffset === nodeSurrounding.openingTagEnd &&\n      endPosOffset + 1 === nodeSurrounding.closingTagStart\n    ) {\n      this.openEnd = this.openStart;\n      this.closeStart = this.closeEnd;\n    } else {\n      this.openEnd = nodeSurrounding.openingTagEnd;\n      this.closeStart = nodeSurrounding.closingTagStart;\n    }\n  }\n\n  /**\n   * Most of the time the relevant tag is the innermost tag, but when Visual mode is active,\n   * the rules are different.\n   * When the cursorStart is standing on the < character of the inner tag, with \"at\" we must\n   * jump to the outer tag.\n   */\n  determineRelevantTag(\n    tagsSurrounding: MatchedTag[],\n    adjustedStartPosOffset: number,\n    selectionActive: boolean\n  ): MatchedTag | undefined {\n    const relevantTag = tagsSurrounding[0];\n\n    if (selectionActive && adjustedStartPosOffset === relevantTag.openingTagStart) {\n      // we adjusted so we have to return the outer tag\n      return tagsSurrounding[1];\n    } else {\n      return relevantTag;\n    }\n  }\n\n  findOpening(inclusive: boolean): number | undefined {\n    if (inclusive) {\n      return this.openStart;\n    }\n    return this.openEnd;\n  }\n\n  findClosing(inclusive: boolean): number | undefined {\n    if (inclusive) {\n      return this.closeEnd;\n    }\n    return this.closeStart;\n  }\n}\n","import { Position, Selection, TextEditor } from 'vscode';\n\nexport class Cursor {\n  public readonly start: Position;\n  public readonly stop: Position;\n\n  constructor(start: Position, stop: Position) {\n    this.start = start;\n    this.stop = stop;\n  }\n\n  public isValid(textEditor: TextEditor) {\n    return this.start.isValid(textEditor) && this.stop.isValid(textEditor);\n  }\n\n  /**\n   * Create a Cursor from a VSCode selection.\n   */\n  public static FromVSCodeSelection(sel: Selection): Cursor {\n    return new Cursor(sel.start, sel.end);\n  }\n\n  public equals(other: Cursor): boolean {\n    return this.start.isEqual(other.start) && this.stop.isEqual(other.stop);\n  }\n\n  /**\n   * Returns a new Cursor which is the same as this Cursor, but with the provided stop value.\n   */\n  public withNewStop(stop: Position): Cursor {\n    return new Cursor(this.start, stop);\n  }\n\n  /**\n   * Returns a new Cursor which is the same as this Cursor, but with the provided start value.\n   */\n  public withNewStart(start: Position): Cursor {\n    return new Cursor(start, this.stop);\n  }\n\n  public toString(): string {\n    return `[${this.start.toString()} | ${this.stop.toString()}]`;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { configuration } from './../../configuration/configuration';\nimport { TextEditor } from './../../textEditor';\nimport { clamp } from '../../util/util';\nimport { getSentenceBegin, getSentenceEnd } from '../../textobject/sentence';\nimport {\n  WordType,\n  nextWordEnd,\n  prevWordEnd,\n  prevWordStart,\n  nextWordStart,\n} from '../../textobject/word';\nimport { Position } from 'vscode';\n\n/**\n * Controls how a PositionDiff affects the Position it's applied to.\n */\nenum PositionDiffType {\n  /** Sets both the line and character exactly */\n  ExactPosition,\n  /** Offsets both the line and character */\n  Offset,\n  /** Offsets the line and sets the column exactly */\n  ExactCharacter,\n  /** Brings the Position to the beginning of the line if `vim.startofline` is true */\n  ObeyStartOfLine,\n  /** Brings the Position to the end of the line */\n  EndOfLine,\n}\n\n/**\n * Represents a difference between two Positions.\n * Add it to a Position to get another Position.\n */\nexport class PositionDiff {\n  public readonly line: number;\n  public readonly character: number;\n  public readonly type: PositionDiffType;\n\n  private constructor(type: PositionDiffType, line: number, character: number) {\n    this.type = type;\n    this.line = line;\n    this.character = character;\n  }\n\n  /** Has no effect */\n  public static identity(): PositionDiff {\n    return PositionDiff.offset({ line: 0, character: 0 });\n  }\n\n  /** Offsets both the Position's line and character */\n  public static offset({ line = 0, character = 0 }): PositionDiff {\n    return new PositionDiff(PositionDiffType.Offset, line, character);\n  }\n\n  /** Sets the Position's line and character exactly */\n  public static exactPosition(position: Position): PositionDiff {\n    return new PositionDiff(PositionDiffType.ExactPosition, position.line, position.character);\n  }\n\n  /** Brings the Position to the beginning of the line if `vim.startofline` is true */\n  public static startOfLine(): PositionDiff {\n    return new PositionDiff(PositionDiffType.ObeyStartOfLine, 0, 0);\n  }\n\n  /** Brings the Position to the end of the line */\n  public static endOfLine(): PositionDiff {\n    return new PositionDiff(PositionDiffType.EndOfLine, 0, 0);\n  }\n\n  /** Offsets the Position's line and sets its character exactly */\n  public static exactCharacter({\n    lineOffset,\n    character,\n  }: {\n    lineOffset?: number;\n    character: number;\n  }): PositionDiff {\n    return new PositionDiff(PositionDiffType.ExactCharacter, lineOffset ?? 0, character);\n  }\n\n  public toString(): string {\n    switch (this.type) {\n      case PositionDiffType.Offset:\n        return `[ Diff: Offset ${this.line} ${this.character} ]`;\n      case PositionDiffType.ExactCharacter:\n        return `[ Diff: ExactCharacter ${this.line} ${this.character} ]`;\n      case PositionDiffType.ExactPosition:\n        return `[ Diff: ExactPosition ${this.line} ${this.character} ]`;\n      case PositionDiffType.ObeyStartOfLine:\n        return `[ Diff: ObeyStartOfLine ${this.line} ]`;\n      case PositionDiffType.EndOfLine:\n        return `[ Diff: EndOfLine ${this.line} ]`;\n      default:\n        const guard: never = this.type;\n        throw new Error(`Unknown PositionDiffType: ${this.type}`);\n    }\n  }\n}\n\n/**\n * @returns the Position of the 2 provided which comes earlier in the document.\n */\nexport function earlierOf(p1: Position, p2: Position): Position {\n  return p1.isBefore(p2) ? p1 : p2;\n}\n\n/**\n * @returns the Position of the 2 provided which comes later in the document.\n */\nexport function laterOf(p1: Position, p2: Position): Position {\n  return p1.isBefore(p2) ? p2 : p1;\n}\n\n/**\n * @returns the given Positions in the order they appear in the document.\n */\nexport function sorted(p1: Position, p2: Position): [Position, Position] {\n  return p1.isBefore(p2) ? [p1, p2] : [p2, p1];\n}\n\ndeclare module 'vscode' {\n  interface Position {\n    toString(): string;\n\n    add(document: vscode.TextDocument, diff: PositionDiff, boundsCheck?: boolean): Position;\n    subtract(other: Position): PositionDiff;\n\n    /**\n     * @returns a new Position with the same line and the given character.\n     * Does bounds-checking to make sure the result is valid.\n     * @deprecated use `Position.with` instead\n     */\n    withColumn(column: number): Position;\n\n    /**\n     * @returns the Position `count` characters to the left of this Position. Does not go over line breaks.\n     */\n    getLeft(count?: number): Position;\n    /**\n     * @returns the Position `count` characters to the right of this Position. Does not go over line breaks.\n     */\n    getRight(count?: number): Position;\n    /**\n     * @returns the Position `count` lines down from this Position\n     */\n    getDown(count?: number): Position;\n    /**\n     * @returns the Position `count` lines up from this Position\n     */\n    getUp(count?: number): Position;\n\n    getLeftThroughLineBreaks(includeEol?: boolean): Position;\n    getRightThroughLineBreaks(includeEol?: boolean): Position;\n    getOffsetThroughLineBreaks(offset: number): Position;\n\n    /**\n     * @returns the start of the first word to the left of the current position, like `b`\n     *\n     * @param wordType how word boundaries are determined\n     * @param inclusive if true, returns the current position if it's at the start of a word\n     */\n    prevWordStart(\n      document: vscode.TextDocument,\n      args?: { wordType?: WordType; inclusive?: boolean }\n    ): Position;\n\n    /**\n     * @returns the start of the first word to the right of the current position, like `w`\n     *\n     * @param wordType how word boundaries are determined\n     * @param inclusive if true, returns the current position if it's at the start of a word\n     */\n    nextWordStart(\n      document: vscode.TextDocument,\n      args?: { wordType?: WordType; inclusive?: boolean }\n    ): Position;\n\n    /**\n     * @returns the end of the first word to the left of the current position, like `ge`\n     *\n     * @param wordType how word boundaries are determined\n     */\n    prevWordEnd(document: vscode.TextDocument, args?: { wordType?: WordType }): Position;\n\n    /**\n     * @returns the end of the first word to the right of the current position, like `e`\n     *\n     * @param wordType how word boundaries are determined\n     * @param inclusive if true, returns the current position if it's at the end of a word\n     */\n    nextWordEnd(\n      document: vscode.TextDocument,\n      args?: { wordType?: WordType; inclusive?: boolean }\n    ): Position;\n\n    getSentenceBegin(args: { forward: boolean }): Position;\n    getSentenceEnd(): Position;\n\n    getLineBegin(): Position;\n\n    /**\n     * @returns the beginning of the line, excluding preceeding whitespace.\n     * This respects the `autoindent` setting, and returns `getLineBegin()` if auto-indent is disabled.\n     */\n    getLineBeginRespectingIndent(document: vscode.TextDocument): Position;\n\n    /**\n     * @returns a new Position at the end of this position's line.\n     */\n    getLineEnd(): Position;\n\n    /**\n     * @returns a new Position at the end of this Position's line, including the invisible newline character.\n     */\n    getLineEndIncludingEOL(): Position;\n\n    /**\n     * @returns a new Position one to the left if this Position is on the EOL. Otherwise, returns this position.\n     */\n    getLeftIfEOL(): Position;\n\n    /**\n     * @returns the position that the cursor would be at if you pasted *text* at the current position.\n     */\n    advancePositionByText(text: string): Position;\n\n    /**\n     * Is this position at the beginning of the line?\n     */\n    isLineBeginning(): boolean;\n\n    /**\n     * Is this position at the end of the line?\n     */\n    isLineEnd(): boolean;\n\n    isFirstWordOfLine(document: vscode.TextDocument): boolean;\n\n    isAtDocumentBegin(): boolean;\n\n    isAtDocumentEnd(): boolean;\n\n    /**\n     * Returns whether the current position is in the leading whitespace of a line\n     */\n    isInLeadingWhitespace(document: vscode.TextDocument): boolean;\n\n    /**\n     * If `vim.startofline` is set, get first non-blank character's position.\n     */\n    obeyStartOfLine(document: vscode.TextDocument): Position;\n\n    isValid(textEditor: vscode.TextEditor): boolean;\n  }\n}\n\nPosition.prototype.toString = function (this: Position) {\n  return `[${this.line}, ${this.character}]`;\n};\n\nPosition.prototype.add = function (\n  this: Position,\n  document: vscode.TextDocument,\n  diff: PositionDiff,\n  boundsCheck = true\n): Position {\n  if (diff.type === PositionDiffType.ExactPosition) {\n    return new Position(diff.line, diff.character);\n  }\n\n  const resultLine = clamp(this.line + diff.line, 0, document.lineCount - 1);\n\n  let resultChar: number;\n  if (diff.type === PositionDiffType.Offset) {\n    resultChar = this.character + diff.character;\n  } else if (diff.type === PositionDiffType.ExactCharacter) {\n    resultChar = diff.character;\n  } else if (diff.type === PositionDiffType.ObeyStartOfLine) {\n    resultChar = this.obeyStartOfLine(document).character;\n  } else if (diff.type === PositionDiffType.EndOfLine) {\n    resultChar = this.getLineEnd().character;\n  } else {\n    throw new Error(`Unknown PositionDiffType: ${diff.type}`);\n  }\n\n  const pos = new Position(resultLine, Math.max(resultChar, 0));\n  return boundsCheck ? document.validatePosition(pos) : pos;\n};\n\nPosition.prototype.subtract = function (this: Position, other: Position): PositionDiff {\n  return PositionDiff.offset({\n    line: this.line - other.line,\n    character: this.character - other.character,\n  });\n};\n\n/**\n * @returns a new Position with the same line and the given character.\n * Does bounds-checking to make sure the result is valid.\n */\nPosition.prototype.withColumn = function (this: Position, column: number): Position {\n  column = clamp(column, 0, TextEditor.getLineLength(this.line));\n  return new Position(this.line, column);\n};\n\n/**\n * @returns the Position `count` characters to the left of this Position. Does not go over line breaks.\n */\nPosition.prototype.getLeft = function (this: Position, count = 1): Position {\n  return new Position(this.line, Math.max(this.character - count, 0));\n};\n\n/**\n * @returns the Position `count` characters to the right of this Position. Does not go over line breaks.\n */\nPosition.prototype.getRight = function (this: Position, count = 1): Position {\n  return new Position(\n    this.line,\n    Math.min(this.character + count, TextEditor.getLineLength(this.line))\n  );\n};\n\n/**\n * @returns the Position `count` lines down from this Position\n */\nPosition.prototype.getDown = function (this: Position, count = 1): Position {\n  if (vscode.window.activeTextEditor) {\n    const line = Math.min(this.line + count, TextEditor.getLineCount() - 1);\n    return new Position(line, Math.min(this.character, TextEditor.getLineLength(line)));\n  } else {\n    return this.translate({ lineDelta: count });\n  }\n};\n\n/**\n * @returns the Position `count` lines up from this Position\n */\nPosition.prototype.getUp = function (this: Position, count = 1): Position {\n  const line = Math.max(this.line - count, 0);\n  return new Position(line, Math.min(this.character, TextEditor.getLineLength(line)));\n};\n\n/**\n * Same as getLeft, but goes up to the previous line on line breaks.\n * Equivalent to left arrow (in a non-vim editor!)\n */\nPosition.prototype.getLeftThroughLineBreaks = function (\n  this: Position,\n  includeEol = true\n): Position {\n  if (!this.isLineBeginning()) {\n    return this.getLeft();\n  }\n\n  // First char on first line, can not go left any more\n  if (this.line === 0) {\n    return this;\n  }\n\n  if (includeEol) {\n    return this.getUp().getLineEnd();\n  } else {\n    return this.getUp().getLineEnd().getLeft();\n  }\n};\n\nPosition.prototype.getRightThroughLineBreaks = function (\n  this: Position,\n  includeEol = false\n): Position {\n  if (this.isAtDocumentEnd()) {\n    return this;\n  }\n\n  if (this.line < TextEditor.getLineCount() - 1) {\n    const pos = includeEol ? this : this.getRight();\n    if (pos.isLineEnd()) {\n      return this.with({ character: 0 }).getDown();\n    }\n  } else if (!includeEol && this.character === TextEditor.getLineLength(this.line) - 1) {\n    // Last character of document, don't go on to non-existent EOL\n    return this;\n  }\n\n  return this.getRight();\n};\n\nPosition.prototype.getOffsetThroughLineBreaks = function (\n  this: Position,\n  offset: number\n): Position {\n  let pos = new Position(this.line, this.character);\n\n  if (offset < 0) {\n    for (let i = 0; i < -offset; i++) {\n      pos = pos.getLeftThroughLineBreaks();\n    }\n  } else {\n    for (let i = 0; i < offset; i++) {\n      pos = pos.getRightThroughLineBreaks();\n    }\n  }\n\n  return pos;\n};\n\nPosition.prototype.prevWordStart = function (\n  this: Position,\n  document: vscode.TextDocument,\n  args?: { wordType?: WordType; inclusive?: boolean }\n): Position {\n  return prevWordStart(document, this, args?.wordType ?? WordType.Normal, args?.inclusive ?? false);\n};\n\nPosition.prototype.nextWordStart = function (\n  this: Position,\n  document: vscode.TextDocument,\n  args?: { wordType?: WordType; inclusive?: boolean }\n): Position {\n  return nextWordStart(document, this, args?.wordType ?? WordType.Normal, args?.inclusive ?? false);\n};\n\nPosition.prototype.prevWordEnd = function (\n  this: Position,\n  document: vscode.TextDocument,\n  args?: { wordType?: WordType }\n): Position {\n  return prevWordEnd(document, this, args?.wordType ?? WordType.Normal);\n};\n\nPosition.prototype.nextWordEnd = function (\n  this: Position,\n  document: vscode.TextDocument,\n  args?: { wordType?: WordType; inclusive?: boolean }\n): Position {\n  return nextWordEnd(document, this, args?.wordType ?? WordType.Normal, args?.inclusive ?? false);\n};\n\nPosition.prototype.getSentenceBegin = function (\n  this: Position,\n  args: { forward: boolean }\n): Position {\n  return getSentenceBegin(this, args);\n};\n\nPosition.prototype.getSentenceEnd = function (this: Position): Position {\n  return getSentenceEnd(this);\n};\n\n/**\n * @returns a new Position at the beginning of the current line.\n */\nPosition.prototype.getLineBegin = function (this: Position): Position {\n  return new Position(this.line, 0);\n};\n\n/**\n * @returns the beginning of the line, excluding preceeding whitespace.\n * This respects the `autoindent` setting, and returns `getLineBegin()` if auto-indent is disabled.\n */\nPosition.prototype.getLineBeginRespectingIndent = function (\n  this: Position,\n  document: vscode.TextDocument\n): Position {\n  if (!configuration.autoindent) {\n    return this.getLineBegin();\n  }\n  return TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line);\n};\n\n/**\n * @returns a new Position at the end of this position's line.\n */\nPosition.prototype.getLineEnd = function (this: Position): Position {\n  return new Position(this.line, TextEditor.getLineLength(this.line));\n};\n\n/**\n * @returns a new Position at the end of this Position's line, including the invisible newline character.\n */\nPosition.prototype.getLineEndIncludingEOL = function (this: Position): Position {\n  // TODO: isn't this one too far?\n  return new Position(this.line, TextEditor.getLineLength(this.line) + 1);\n};\n\n/**\n * @returns a new Position one to the left if this Position is on the EOL. Otherwise, returns this position.\n */\nPosition.prototype.getLeftIfEOL = function (this: Position): Position {\n  return this.character === TextEditor.getLineLength(this.line) ? this.getLeft() : this;\n};\n\n/**\n * @returns the position that the cursor would be at if you pasted *text* at the current position.\n */\nPosition.prototype.advancePositionByText = function (this: Position, text: string): Position {\n  const newlines: number[] = [];\n  let idx = text.indexOf('\\n', 0);\n  while (idx >= 0) {\n    newlines.push(idx);\n    idx = text.indexOf('\\n', idx + 1);\n  }\n\n  if (newlines.length === 0) {\n    return new Position(this.line, this.character + text.length);\n  } else {\n    return new Position(\n      this.line + newlines.length,\n      text.length - (newlines[newlines.length - 1] + 1)\n    );\n  }\n};\n\n/**\n * Is this position at the beginning of the line?\n */\nPosition.prototype.isLineBeginning = function (this: Position): boolean {\n  return this.character === 0;\n};\n\n/**\n * Is this position at the end of the line?\n */\nPosition.prototype.isLineEnd = function (this: Position): boolean {\n  return this.character >= TextEditor.getLineLength(this.line);\n};\n\nPosition.prototype.isFirstWordOfLine = function (\n  this: Position,\n  document: vscode.TextDocument\n): boolean {\n  return (\n    TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line).character === this.character\n  );\n};\n\nPosition.prototype.isAtDocumentBegin = function (this: Position): boolean {\n  return this.line === 0 && this.isLineBeginning();\n};\n\nPosition.prototype.isAtDocumentEnd = function (this: Position): boolean {\n  return this.line === TextEditor.getLineCount() - 1 && this.isLineEnd();\n};\n\n/**\n * Returns whether the current position is in the leading whitespace of a line\n * @param allowEmpty : Use true if \"\" is valid\n */\nPosition.prototype.isInLeadingWhitespace = function (\n  this: Position,\n  document: vscode.TextDocument\n): boolean {\n  return /^\\s+$/.test(document.getText(new vscode.Range(this.getLineBegin(), this)));\n};\n\n/**\n * If `vim.startofline` is set, get first non-blank character's position.\n */\nPosition.prototype.obeyStartOfLine = function (\n  this: Position,\n  document: vscode.TextDocument\n): Position {\n  return configuration.startofline\n    ? TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line)\n    : this;\n};\n\nPosition.prototype.isValid = function (this: Position, textEditor: vscode.TextEditor): boolean {\n  try {\n    // line\n    // TODO: this `|| 1` seems dubious...\n    const lineCount = TextEditor.getLineCount(textEditor) || 1;\n    if (this.line >= lineCount) {\n      return false;\n    }\n\n    // char\n    const charCount = TextEditor.getLineLength(this.line);\n    if (this.character > charCount + 1) {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n","/**\n *      aaaa0x111bbbbbb\n *      |-------------| => NumericString\n *      |--|            => prefix\n *          |---|       => core\n *               |----| => suffix\n *          ||          => numPrefix\n *            |-|       => num\n *\n * Greedy matching, leftmost match wins.\n * If multiple matches begin at the same position, the match with the biggest\n *   span wins.\n * If multiple matches have the same begin position and span (This usually\n *   happens on octal and decimal), following priority sequence is used:\n *   (decimal => octal => hexadecimal)\n *\n * Example:\n *                    |  core  |     What we got      |     Rather than     |\n *  ------------------|--------|----------------------|---------------------|\n *  Leftmost rule:    | 010xff |    (010)xff [octal]  |    01(0xff) [hex]   |\n *  Biggest span rule:| 0xff   |     (0xff) [hex]     |   (0)xff [decimal]  |\n *  Priority rule:    | 00007  |    (00007) [octal]   |  (00007) [decimal]  |\n *\n * Side Effect:\n *  -0xf  Will be parsed as (-0)xf rather than -(0xf), current workaround is\n *          capturing '-' in hexadecimal regex but not consider '-' as a part\n *          of the number. This is achieved by using `negative` boolean value\n *          in `NumericString`.\n */\nexport class NumericString {\n  radix: number;\n  value: number;\n  numLength: number;\n  prefix: string;\n  suffix: string;\n  // If a negative sign should be manually added when converting to string.\n  negative: boolean;\n\n  // Map radix to number prefix\n  private static numPrefix = {\n    8: '0',\n    10: '',\n    16: '0x',\n  };\n\n  // Keep octal at the top of decimal to avoid regarding 0000007 as decimal.\n  // '000009' matches decimal.\n  // '000007' matches octal.\n  // '-0xf' matches hex rather than decimal '-0'\n  private static matchings: Array<{ regex: RegExp; radix: number }> = [\n    { regex: /(-)?0[0-7]+/, radix: 8 },\n    { regex: /(-)?\\d+/, radix: 10 },\n    { regex: /(-)?0x[\\da-fA-F]+/, radix: 16 },\n  ];\n\n  // Return parse result and offset of suffix\n  public static parse(input: string): { num: NumericString; suffixOffset: number } | undefined {\n    // Find core numeric part of input\n    let coreBegin = -1;\n    let coreLength = -1;\n    let coreRadix = -1;\n    let coreSign = false;\n    for (const { regex, radix } of NumericString.matchings) {\n      const match = regex.exec(input);\n      if (match != null) {\n        // Get the leftmost and largest match\n        if (\n          coreRadix < 0 ||\n          match.index < coreBegin ||\n          (match.index === coreBegin && match[0].length > coreLength)\n        ) {\n          coreBegin = match.index;\n          coreLength = match[0].length;\n          coreRadix = radix;\n          coreSign = match[1] === '-';\n        }\n      }\n    }\n\n    if (coreRadix < 0) {\n      return undefined;\n    }\n\n    const coreEnd = coreBegin + coreLength;\n\n    const prefix = input.slice(0, coreBegin);\n    const core = input.slice(coreBegin, coreEnd);\n    const suffix = input.slice(coreEnd, input.length);\n\n    let value = parseInt(core, coreRadix);\n\n    // 0x00ff:  numLength = 4\n    // 077:     numLength = 2\n    // -0999:   numLength = 3\n    // The numLength is only useful for parsing non-decimal. Decimal with\n    // leading zero will be trimmed in `toString()`. If value is negative,\n    // remove the width of negative sign.\n    const numLength = coreLength - NumericString.numPrefix[coreRadix].length - (coreSign ? 1 : 0);\n\n    // According to original vim's behavior, for hex and octal, the leading\n    // '-' *should* be captured and preserved but *should not* be regarded as\n    // part of number, which means with <C-a>, `-0xf` turns into `-0x10`. So\n    // for hex and octal, we make the value absolute and set the negative\n    // sign flag.\n    let negative = false;\n    if (coreRadix !== 10 && coreSign) {\n      value = -value;\n      negative = true;\n    }\n\n    return {\n      num: new NumericString(value, coreRadix, numLength, prefix, suffix, negative),\n      suffixOffset: coreEnd,\n    };\n  }\n\n  private constructor(\n    value: number,\n    radix: number,\n    numLength: number,\n    prefix: string,\n    suffix: string,\n    negative: boolean\n  ) {\n    this.value = value;\n    this.radix = radix;\n    this.numLength = numLength;\n    this.prefix = prefix;\n    this.suffix = suffix;\n    this.negative = negative;\n  }\n\n  public toString(): string {\n    // For decreased octal and hexadecimal\n    if (this.radix !== 10) {\n      const max = 0xffffffff;\n      while (this.value < 0) {\n        this.value = max + this.value + 1;\n      }\n    }\n\n    // Gen num part\n    const absValue = Math.abs(this.value);\n    let num = absValue.toString(this.radix);\n    // numLength of decimal *should not* be preserved.\n    if (this.radix !== 10) {\n      const diff = this.numLength - num.length;\n      if (diff > 0) {\n        // Preserve num length if it's narrower.\n        num = '0'.repeat(diff) + num;\n      }\n    }\n\n    const sign = this.negative || this.value < 0 ? '-' : '';\n    const core = sign + NumericString.numPrefix[this.radix] + num;\n    return this.prefix + core + this.suffix;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { TextEditor } from './../textEditor';\nimport { VimState } from '../state/vimState';\nimport { Position } from 'vscode';\n\n/**\n * Return open text documents, with a given file at the top of the list.\n * @param startingFileName File that will be first in the array, typically current file\n */\nconst documentsStartingWith = (startingFileName: string) => {\n  return [...vscode.workspace.textDocuments].sort((a, b) => {\n    if (a.fileName === startingFileName) {\n      return -1;\n    } else if (b.fileName === startingFileName) {\n      return 1;\n    }\n    return 0;\n  });\n};\n\n/**\n * Get lines, with leading tabs or whitespace stripped.\n * @param document Document to get lines from.\n * @param lineToStartScanFrom Where to start looking for matches first. Closest matches are sorted first.\n * @param scanAboveFirst Whether to start scan above or below cursor. Other direction is scanned last.\n * @returns\n */\nconst linesWithoutIndentation = (\n  document: vscode.TextDocument,\n  lineToStartScanFrom: number,\n  scanAboveFirst: boolean\n): Array<{ sortPriority: number; text: string }> => {\n  const distanceFromStartLine = (line: number) => {\n    let sortPriority = scanAboveFirst ? lineToStartScanFrom - line : line - lineToStartScanFrom;\n    if (sortPriority < 0) {\n      // We prioritized any items in the main direction searched,\n      // but now find closest items in opposite direction.\n      sortPriority = lineToStartScanFrom + Math.abs(sortPriority);\n    }\n\n    return sortPriority;\n  };\n\n  return document\n    .getText()\n    .split('\\n')\n    .map((text, line) => ({\n      sortPriority: distanceFromStartLine(line),\n      text: text.replace(/^[ \\t]*/, ''),\n    }))\n    .sort((a, b) => (a.sortPriority > b.sortPriority ? 1 : -1));\n};\n\n/**\n * Get all completions that match given text within open documents.\n * @example\n * a1\n * a2\n * a| // <--- Perform line completion here\n * a3\n * a4\n * // Returns: ['a2', 'a1', 'a3', 'a4']\n * @param text Text to partially match. Indentation is stripped.\n * @param currentFileName Current file, which is prioritized in sorting.\n * @param currentPosition Current position, which is prioritized when sorting for current file.\n */\nconst getCompletionsForText = (\n  text: string,\n  currentFileName: string,\n  currentPosition: Position\n): string[] | null => {\n  const matchedLines: string[] = [];\n\n  for (const document of documentsStartingWith(currentFileName)) {\n    let lineToStartScanFrom = 0;\n    let scanAboveFirst = false;\n\n    if (document.fileName === currentFileName) {\n      lineToStartScanFrom = currentPosition.line;\n      scanAboveFirst = true;\n    }\n\n    for (const line of linesWithoutIndentation(document, lineToStartScanFrom, scanAboveFirst)) {\n      if (\n        !matchedLines.includes(line.text) &&\n        line.text &&\n        line.text.startsWith(text) &&\n        line.text !== text\n      ) {\n        matchedLines.push(line.text);\n      }\n    }\n  }\n\n  return matchedLines;\n};\n\n/**\n * Get all completions that match given text within open documents.\n * Results are sorted in a few ways:\n * 1) The current document is prioritized over other open documents.\n * 2) For the current document, lines above the current cursor are always prioritized over lines below it.\n * 3) For the current document, lines are also prioritized based on distance from cursor.\n * 4) For other documents, lines are prioritized based on distance from the top.\n * @example\n * a1\n * a2\n * a| // <--- Perform line completion here\n * a3\n * a4\n * // Returns: ['a2', 'a1', 'a3', 'a4']\n * @param position Position to start scan from\n * @param document Document to start scanning from, starting at the position (other open documents are scanned from top)\n */\nexport const getCompletionsForCurrentLine = (\n  position: Position,\n  document: vscode.TextDocument\n): string[] | null => {\n  const currentLineText = document.getText(\n    new vscode.Range(TextEditor.getFirstNonWhitespaceCharOnLine(document, position.line), position)\n  );\n\n  return getCompletionsForText(currentLineText, document.fileName, position);\n};\n\nexport const lineCompletionProvider = {\n  /**\n   * Get all completions that match given text within open documents.\n   * Results are sorted by priority.\n   * @see getCompletionsForCurrentLine\n   *\n   * Any trailing characters are stripped. Trailing characters are often\n   * from auto-close, such as when importing in JavaScript ES6 and typing a\n   * curly brace. So the trailing characters are removed on purpose.\n   *\n   * Modifies vimState, adding transformations that replaces the\n   * current line's text with the chosen completion, with proper indentation.\n   *\n   * Here we use Quick Pick, instead of registerCompletionItemProvider\n   * Originally I looked at using a standard completion dropdown using that method,\n   * but it doesn't allow you to limit completions, and it became overwhelming\n   * when e.g. trying to do a line completion when the cursor is positioned after\n   * a space character (such that it shows almost any symbol in the list).\n   * Quick Pick also allows for searching, which is a nice bonus.\n   */\n  showLineCompletionsQuickPick: async (position: Position, vimState: VimState): Promise<void> => {\n    const completions = getCompletionsForCurrentLine(position, vimState.document);\n\n    if (!completions) {\n      return;\n    }\n\n    const selectedCompletion = await vscode.window.showQuickPick(completions);\n\n    if (!selectedCompletion) {\n      return;\n    }\n\n    vimState.recordedState.transformer.delete(\n      new vscode.Range(\n        TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.line),\n        position.getLineEnd()\n      )\n    );\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertTextVSCode',\n      text: selectedCompletion,\n    });\n  },\n};\n","import * as vscode from 'vscode';\nimport { Globals } from '../globals';\nimport { Notation } from './notation';\nimport { ValidatorResults } from './iconfigurationValidator';\nimport { VSCodeContext } from '../util/vscodeContext';\nimport { configurationValidator } from './configurationValidator';\nimport { decoration } from './decoration';\nimport * as process from 'process';\n\nimport {\n  IConfiguration,\n  IKeyRemapping,\n  IModeSpecificStrings,\n  IAutoSwitchInputMethod,\n  IDebugConfiguration,\n  IHighlightedYankConfiguration,\n  ICamelCaseMotionConfiguration,\n} from './iconfiguration';\n\nimport * as packagejson from '../../package.json';\nimport { SUPPORT_VIMRC } from 'platform/constants';\n\n// https://stackovrflow.com/questions/51465182/how-to-remove-index-signature-using-mapped-types/51956054#51956054\ntype RemoveIndex<T> = {\n  [P in keyof T as string extends P ? never : number extends P ? never : P]: T[P];\n};\n\nexport const extensionVersion = packagejson.version;\n\n/**\n * Most options supported by Vim have a short alias. They are provided here.\n * Please keep this list up to date and sorted alphabetically.\n */\nexport const optionAliases: ReadonlyMap<string, string> = new Map<string, string>([\n  ['ai', 'autoindent'],\n  ['et', 'expandtab'],\n  ['gd', 'gdefault'],\n  ['hi', 'history'],\n  ['hls', 'hlsearch'],\n  ['ic', 'ignorecase'],\n  ['is', 'incsearch'],\n  ['isk', 'iskeyword'],\n  ['js', 'joinspaces'],\n  ['mmd', 'maxmapdepth'],\n  ['mps', 'matchpairs'],\n  ['nu', 'number'],\n  ['rnu', 'relativenumber'],\n  ['sc', 'showcmd'],\n  ['scr', 'scroll'],\n  ['scs', 'smartcase'],\n  ['smd', 'showmode'],\n  ['sol', 'startofline'],\n  ['to', 'timeout'],\n  ['ts', 'tabstop'],\n  ['tw', 'textwidth'],\n  ['ws', 'wrapscan'],\n  ['ww', 'whichwrap'],\n]);\n\ntype OptionValue = number | string | boolean;\n\ninterface VSCodeKeybinding {\n  key: string;\n  mac?: string;\n  linux?: string;\n  command: string;\n  when: string;\n}\n\ninterface IHandleKeys {\n  [key: string]: boolean;\n}\n\ninterface IKeyBinding {\n  key: string;\n  command: string;\n}\n\n/**\n * Every Vim option we support should\n * 1. Be added to contribution section of `package.json`.\n * 2. Named as `vim.{optionName}`, `optionName` is the name we use in Vim.\n * 3. Define a public property in `Configuration` with the same name and a default value.\n *    Or define a private property and define customized Getter/Setter accessors for it.\n *    Always remember to decorate Getter accessor as @enumerable()\n * 4. If user doesn't set the option explicitly\n *    a. we don't have a similar setting in Code, initialize the option as default value.\n *    b. we have a similar setting in Code, use Code's setting.\n *\n * Vim option override sequence.\n * 1. `:set {option}` on the fly\n * 2. `vim.{option}`\n * 3. VS Code configuration\n * 4. VSCodeVim configuration default values\n *\n */\nclass Configuration implements IConfiguration {\n  private readonly leaderDefault = '\\\\';\n  private readonly cursorTypeMap = {\n    line: vscode.TextEditorCursorStyle.Line,\n    block: vscode.TextEditorCursorStyle.Block,\n    underline: vscode.TextEditorCursorStyle.Underline,\n    'line-thin': vscode.TextEditorCursorStyle.LineThin,\n    'block-outline': vscode.TextEditorCursorStyle.BlockOutline,\n    'underline-thin': vscode.TextEditorCursorStyle.UnderlineThin,\n  };\n\n  public async load(): Promise<ValidatorResults> {\n    const vimConfigs: { [key: string]: any } = Globals.isTesting\n      ? Globals.mockConfiguration\n      : this.getConfiguration('vim');\n\n    // tslint:disable-next-line: forin\n    for (const option in this) {\n      let val = vimConfigs[option];\n      if (val !== null && val !== undefined) {\n        if (val.constructor.name === Object.name) {\n          val = Configuration.unproxify(val);\n        }\n        this[option] = val;\n      }\n    }\n\n    if (SUPPORT_VIMRC && this.vimrc.enable) {\n      await import('./vimrc').then((vimrcModel) => {\n        return vimrcModel.vimrc.load(this);\n      });\n    }\n\n    this.leader = Notation.NormalizeKey(this.leader, this.leaderDefault);\n\n    this.clearKeyBindingsMaps();\n\n    const validatorResults = await configurationValidator.validate(configuration);\n\n    // read package.json for bound keys\n    // enable/disable certain key combinations\n    this.boundKeyCombinations = [];\n    for (const keybinding of packagejson.contributes.keybindings) {\n      if (keybinding.when.includes('listFocus')) {\n        continue;\n      }\n\n      if (keybinding.command.startsWith('notebook')) {\n        continue;\n      }\n\n      let key = keybinding.key;\n      if (process.platform === 'darwin') {\n        key = keybinding.mac || key;\n      } else if (process.platform === 'linux') {\n        key = keybinding.linux || key;\n      }\n\n      this.boundKeyCombinations.push({\n        key: Notation.NormalizeKey(key, this.leader),\n        command: keybinding.command,\n      });\n    }\n\n    // decorations\n    decoration.load(this);\n\n    for (const boundKey of this.boundKeyCombinations) {\n      // By default, all key combinations are used\n      let useKey = true;\n\n      const handleKey = this.handleKeys[boundKey.key];\n      if (handleKey !== undefined) {\n        // enabled/disabled through `vim.handleKeys`\n        useKey = handleKey;\n      } else if (!this.useCtrlKeys && boundKey.key.slice(1, 3) === 'C-') {\n        // user has disabled CtrlKeys and the current key is a CtrlKey\n        // <C-c>, still needs to be captured to overrideCopy\n        if (boundKey.key === '<C-c>' && this.overrideCopy) {\n          useKey = true;\n        } else {\n          useKey = false;\n        }\n      }\n\n      VSCodeContext.set(`vim.use${boundKey.key}`, useKey);\n    }\n\n    VSCodeContext.set('vim.overrideCopy', this.overrideCopy);\n    VSCodeContext.set('vim.overrideCtrlC', this.overrideCopy || this.useCtrlKeys);\n\n    return validatorResults;\n  }\n\n  getConfiguration(section: string = ''): RemoveIndex<vscode.WorkspaceConfiguration> {\n    const document = vscode.window.activeTextEditor?.document;\n    const resource = document ? { uri: document.uri, languageId: document.languageId } : undefined;\n    return vscode.workspace.getConfiguration(section, resource);\n  }\n\n  cursorStyleFromString(cursorStyle: string): vscode.TextEditorCursorStyle | undefined {\n    return this.cursorTypeMap[cursorStyle];\n  }\n\n  clearKeyBindingsMaps() {\n    // Clear the KeyBindingsMaps so that the previous configuration maps don't leak to this one\n    this.normalModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.insertModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.visualModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.commandLineModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.operatorPendingModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n  }\n\n  handleKeys: IHandleKeys[] = [];\n\n  useSystemClipboard = false;\n\n  useCtrlKeys = false;\n\n  overrideCopy = true;\n\n  textwidth = 80;\n\n  hlsearch = false;\n\n  ignorecase = true;\n\n  smartcase = true;\n\n  autoindent = true;\n\n  matchpairs = '(:),{:},[:]';\n\n  joinspaces = true;\n\n  camelCaseMotion: ICamelCaseMotionConfiguration = {\n    enable: true,\n  };\n\n  replaceWithRegister = false;\n\n  smartRelativeLine = false;\n\n  sneak = false;\n  sneakUseIgnorecaseAndSmartcase = false;\n  sneakReplacesF = false;\n\n  surround = true;\n\n  argumentObjectSeparators = [','];\n  argumentObjectOpeningDelimiters = ['(', '['];\n  argumentObjectClosingDelimiters = [')', ']'];\n\n  easymotion = false;\n  easymotionMarkerBackgroundColor = '#0000';\n  easymotionMarkerForegroundColorOneChar = '#ff0000';\n  easymotionMarkerForegroundColorTwoChar = '#ffa500'; // Deprecated! Use the ones bellow\n  easymotionMarkerForegroundColorTwoCharFirst = '#ffb400';\n  easymotionMarkerForegroundColorTwoCharSecond = '#b98300';\n  easymotionIncSearchForegroundColor = '#7fbf00';\n  easymotionDimColor = '#777777';\n  easymotionMarkerWidthPerChar = 8; // Deprecated! No longer needed!\n  easymotionDimBackground = true;\n  easymotionMarkerFontFamily = 'Consolas'; // Deprecated! No longer needed!\n  easymotionMarkerFontSize = '14'; // Deprecated! No longer needed!\n  easymotionMarkerFontWeight = 'bold';\n  easymotionMarkerMargin = 0; // Deprecated! No longer needed!\n  easymotionKeys = 'hklyuiopnm,qwertzxcvbasdgjf;';\n  easymotionJumpToAnywhereRegex = '\\\\b[A-Za-z0-9]|[A-Za-z0-9]\\\\b|_.|#.|[a-z][A-Z]';\n\n  autoSwitchInputMethod: IAutoSwitchInputMethod = {\n    enable: false,\n    defaultIM: '',\n    obtainIMCmd: '',\n    switchIMCmd: '',\n  };\n\n  timeout = 1000;\n\n  maxmapdepth = 1000;\n\n  showcmd = true;\n\n  showmodename = true;\n\n  leader = this.leaderDefault;\n\n  history = 50;\n\n  incsearch = true;\n\n  startInInsertMode = false;\n\n  statusBarColorControl = false;\n\n  statusBarColors: IModeSpecificStrings<string | string[]> = {\n    normal: '#005f5f',\n    insert: '#5f0000',\n    visual: '#5f00af',\n    visualline: '#005f87',\n    visualblock: '#86592d',\n    replace: '#000000',\n  };\n\n  debug: IDebugConfiguration = {\n    silent: false,\n    loggingLevelForAlert: 'error',\n    loggingLevelForConsole: 'error',\n  };\n\n  searchHighlightColor = '';\n  searchHighlightTextColor = '';\n\n  highlightedyank: IHighlightedYankConfiguration = {\n    enable: false,\n    color: 'rgba(250, 240, 170, 0.5)',\n    textColor: '',\n    duration: 200,\n  };\n\n  @overlapSetting({ settingName: 'tabSize', defaultValue: 8 })\n  tabstop!: number;\n\n  @overlapSetting({ settingName: 'cursorStyle', defaultValue: 'line' })\n  private editorCursorStyleRaw!: string;\n\n  get editorCursorStyle(): vscode.TextEditorCursorStyle | undefined {\n    return this.cursorStyleFromString(this.editorCursorStyleRaw);\n  }\n  set editorCursorStyle(val: vscode.TextEditorCursorStyle | undefined) {\n    // nop\n  }\n\n  @overlapSetting({ settingName: 'insertSpaces', defaultValue: false })\n  expandtab!: boolean;\n\n  @overlapSetting({\n    settingName: 'lineNumbers',\n    defaultValue: true,\n    map: new Map([\n      ['on', true],\n      ['off', false],\n      ['relative', false],\n      ['interval', false],\n    ]),\n  })\n  number!: boolean;\n\n  @overlapSetting({\n    settingName: 'lineNumbers',\n    defaultValue: false,\n    map: new Map([\n      ['on', false],\n      ['off', false],\n      ['relative', true],\n      ['interval', false],\n    ]),\n  })\n  relativenumber!: boolean;\n\n  @overlapSetting({\n    settingName: 'wordSeparators',\n    defaultValue: '/\\\\()\"\\':,.;<>~!@#$%^&*|+=[]{}`?-',\n  })\n  iskeyword!: string;\n\n  @overlapSetting({\n    settingName: 'wordWrap',\n    defaultValue: false,\n    map: new Map([\n      ['on', true],\n      ['off', false],\n      ['wordWrapColumn', true],\n      ['bounded', true],\n    ]),\n  })\n  wrap!: boolean;\n\n  boundKeyCombinations: IKeyBinding[] = [];\n\n  visualstar = false;\n\n  mouseSelectionGoesIntoVisualMode = true;\n\n  changeWordIncludesWhitespace = false;\n\n  foldfix = false;\n\n  disableExtension: boolean = false;\n\n  enableNeovim = false;\n  neovimPath = '';\n  neovimUseConfigFile = false;\n  neovimConfigPath = '';\n\n  vimrc = {\n    enable: false,\n    path: '',\n  };\n\n  digraphs = {};\n\n  gdefault = false;\n  substituteGlobalFlag = false; // Deprecated in favor of gdefault\n\n  whichwrap = 'b,s';\n\n  startofline = true;\n\n  showMarksInGutter = false;\n\n  report = 2;\n  wrapscan = true;\n\n  scroll = 0;\n  getScrollLines(visibleRanges: vscode.Range[]): number {\n    return this.scroll === 0\n      ? Math.ceil((visibleRanges[0].end.line - visibleRanges[0].start.line) / 2)\n      : this.scroll;\n  }\n\n  cursorStylePerMode: IModeSpecificStrings<string> = {\n    normal: undefined,\n    insert: undefined,\n    visual: undefined,\n    visualline: undefined,\n    visualblock: undefined,\n    replace: undefined,\n  };\n\n  getCursorStyleForMode(modeName: string): vscode.TextEditorCursorStyle | undefined {\n    const cursorStyle = this.cursorStylePerMode[modeName.toLowerCase()];\n    if (cursorStyle) {\n      return this.cursorStyleFromString(cursorStyle);\n    }\n\n    return;\n  }\n\n  // remappings\n  insertModeKeyBindings: IKeyRemapping[] = [];\n  insertModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  normalModeKeyBindings: IKeyRemapping[] = [];\n  normalModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  operatorPendingModeKeyBindings: IKeyRemapping[] = [];\n  operatorPendingModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  visualModeKeyBindings: IKeyRemapping[] = [];\n  visualModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  commandLineModeKeyBindings: IKeyRemapping[] = [];\n  commandLineModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n\n  insertModeKeyBindingsMap: Map<string, IKeyRemapping> = new Map();\n  normalModeKeyBindingsMap: Map<string, IKeyRemapping> = new Map();\n  operatorPendingModeKeyBindingsMap: Map<string, IKeyRemapping> = new Map();\n  visualModeKeyBindingsMap: Map<string, IKeyRemapping> = new Map();\n  commandLineModeKeyBindingsMap: Map<string, IKeyRemapping> = new Map();\n\n  private static unproxify(obj: object): object {\n    const result = {};\n    // tslint:disable-next-line: forin\n    for (const key in obj) {\n      const val = obj[key] as any;\n      if (val !== null && val !== undefined) {\n        result[key] = val;\n      }\n    }\n    return result;\n  }\n}\n\n// handle mapped settings between vscode to vim\nfunction overlapSetting(args: {\n  settingName: string;\n  defaultValue: OptionValue;\n  map?: Map<string | number | boolean, string | number | boolean>;\n}) {\n  return (target: any, propertyKey: string) => {\n    Object.defineProperty(target, propertyKey, {\n      get() {\n        // retrieve value from vim configuration\n        // if the value is not defined or empty\n        // look at the equivalent `editor` setting\n        // if that is not defined then defer to the default value\n        let val = this['_' + propertyKey];\n        if (val !== undefined && val !== '') {\n          return val;\n        }\n\n        val = this.getConfiguration('editor').get(args.settingName, args.defaultValue);\n        if (args.map && val !== undefined) {\n          val = args.map.get(val);\n        }\n\n        return val;\n      },\n      set(value) {\n        // synchronize the vim setting with the `editor` equivalent\n        this['_' + propertyKey] = value;\n\n        if (value === undefined || value === '' || Globals.isTesting) {\n          return;\n        }\n\n        if (args.map) {\n          for (const [vscodeSetting, vimSetting] of args.map.entries()) {\n            if (value === vimSetting) {\n              value = vscodeSetting;\n              break;\n            }\n          }\n        }\n\n        // update configuration asynchronously\n        this.getConfiguration('editor').update(\n          args.settingName,\n          value,\n          vscode.ConfigurationTarget.Global\n        );\n      },\n      enumerable: true,\n      configurable: true,\n    });\n  };\n}\n\nexport const configuration = new Configuration();\n","import { IConfiguration } from './iconfiguration';\nimport { IConfigurationValidator, ValidatorResults } from './iconfigurationValidator';\n\nclass ConfigurationValidator {\n  private readonly validators: IConfigurationValidator[];\n\n  constructor() {\n    this.validators = [];\n  }\n\n  public registerValidator(validator: IConfigurationValidator) {\n    this.validators.push(validator);\n  }\n\n  public async validate(config: IConfiguration): Promise<ValidatorResults> {\n    const results = new ValidatorResults();\n\n    for (const validator of this.validators) {\n      const validatorResults = await validator.validate(config);\n      if (validatorResults.hasError) {\n        // errors found in configuration, disable feature\n        validator.disable(config);\n      }\n\n      results.concat(validatorResults);\n    }\n\n    return results;\n  }\n}\n\nexport const configurationValidator = new ConfigurationValidator();\n","import * as vscode from 'vscode';\nimport { IConfiguration } from './iconfiguration';\n\nclass DecorationImpl {\n  private _default!: vscode.TextEditorDecorationType;\n  private _searchHighlight!: vscode.TextEditorDecorationType;\n  private _easyMotionIncSearch!: vscode.TextEditorDecorationType;\n  private _easyMotionDimIncSearch!: vscode.TextEditorDecorationType;\n  private _insertModeVirtualCharacter!: vscode.TextEditorDecorationType;\n  private _operatorPendingModeCursor!: vscode.TextEditorDecorationType;\n  private _operatorPendingModeCursorChar!: vscode.TextEditorDecorationType;\n\n  private _markDecorationCache = new Map<string, vscode.TextEditorDecorationType>();\n\n  private _createMarkDecoration(name: string): vscode.TextEditorDecorationType {\n    const svg = [\n      '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 30 30\" width=\"30px\" height=\"30px\">',\n      '<style>text { font-family: sans-serif; font-size: 0.8em; }</style>',\n      '<path fill=\"rgb(3,102,214)\" d=\"M23,27l-8-7l-8,7V5c0-1.105,0.895-2,2-2h12c1.105,0,2,0.895,2,2V27z\"/>',\n      `<text x=\"50%\" y=\"40%\" fill=\"rgb(200,200,200)\" text-anchor=\"middle\" dominant-baseline=\"middle\">${name}</text>`,\n      '</svg>',\n    ].join('');\n\n    const uri = vscode.Uri.parse(`data:image/svg+xml;utf8,${encodeURI(svg)}`, true);\n\n    return vscode.window.createTextEditorDecorationType({\n      isWholeLine: false,\n      gutterIconPath: uri,\n      gutterIconSize: 'cover',\n    });\n  }\n\n  public set default(value: vscode.TextEditorDecorationType) {\n    if (this._default) {\n      this._default.dispose();\n    }\n    this._default = value;\n  }\n\n  public get default() {\n    return this._default;\n  }\n\n  public set searchHighlight(value: vscode.TextEditorDecorationType) {\n    if (this._searchHighlight) {\n      this._searchHighlight.dispose();\n    }\n    this._searchHighlight = value;\n  }\n\n  public get searchHighlight() {\n    return this._searchHighlight;\n  }\n\n  public get easyMotionIncSearch() {\n    return this._easyMotionIncSearch;\n  }\n\n  public set easyMotionIncSearch(value: vscode.TextEditorDecorationType) {\n    if (this._easyMotionIncSearch) {\n      this._easyMotionIncSearch.dispose();\n    }\n    this._easyMotionIncSearch = value;\n  }\n\n  public get easyMotionDimIncSearch() {\n    return this._easyMotionDimIncSearch;\n  }\n\n  public set easyMotionDimIncSearch(value: vscode.TextEditorDecorationType) {\n    if (this._easyMotionDimIncSearch) {\n      this._easyMotionDimIncSearch.dispose();\n    }\n    this._easyMotionDimIncSearch = value;\n  }\n\n  public getOrCreateMarkDecoration(name: string): vscode.TextEditorDecorationType {\n    const decorationType = this.getMarkDecoration(name);\n\n    if (decorationType) {\n      return decorationType;\n    } else {\n      const type = this._createMarkDecoration(name);\n      this._markDecorationCache.set(name, type);\n      return type;\n    }\n  }\n\n  public getMarkDecoration(name: string): vscode.TextEditorDecorationType | undefined {\n    return this._markDecorationCache.get(name);\n  }\n\n  public allMarkDecorations(): IterableIterator<vscode.TextEditorDecorationType> {\n    return this._markDecorationCache.values();\n  }\n\n  public set insertModeVirtualCharacter(value: vscode.TextEditorDecorationType) {\n    if (this._insertModeVirtualCharacter) {\n      this._insertModeVirtualCharacter.dispose();\n    }\n    this._insertModeVirtualCharacter = value;\n  }\n\n  public get insertModeVirtualCharacter() {\n    return this._insertModeVirtualCharacter;\n  }\n\n  public set operatorPendingModeCursor(value: vscode.TextEditorDecorationType) {\n    if (this._operatorPendingModeCursor) {\n      this._operatorPendingModeCursor.dispose();\n    }\n    this._operatorPendingModeCursor = value;\n  }\n\n  public get operatorPendingModeCursor() {\n    return this._operatorPendingModeCursor;\n  }\n\n  public set operatorPendingModeCursorChar(value: vscode.TextEditorDecorationType) {\n    if (this._operatorPendingModeCursorChar) {\n      this._operatorPendingModeCursorChar.dispose();\n    }\n    this._operatorPendingModeCursorChar = value;\n  }\n\n  public get operatorPendingModeCursorChar() {\n    return this._operatorPendingModeCursorChar;\n  }\n\n  public load(configuration: IConfiguration) {\n    this.default = vscode.window.createTextEditorDecorationType({\n      backgroundColor: new vscode.ThemeColor('editorCursor.foreground'),\n      borderColor: new vscode.ThemeColor('editorCursor.foreground'),\n      dark: {\n        color: 'rgb(81,80,82)',\n      },\n      light: {\n        // used for light colored themes\n        color: 'rgb(255, 255, 255)',\n      },\n      borderStyle: 'solid',\n      borderWidth: '1px',\n    });\n\n    const searchHighlightColor = configuration.searchHighlightColor\n      ? configuration.searchHighlightColor\n      : new vscode.ThemeColor('editor.findMatchHighlightBackground');\n\n    this.searchHighlight = vscode.window.createTextEditorDecorationType({\n      backgroundColor: searchHighlightColor,\n      color: configuration.searchHighlightTextColor,\n      overviewRulerColor: new vscode.ThemeColor('editorOverviewRuler.findMatchForeground'),\n    });\n\n    this.easyMotionIncSearch = vscode.window.createTextEditorDecorationType({\n      color: configuration.easymotionIncSearchForegroundColor,\n      fontWeight: configuration.easymotionMarkerFontWeight,\n    });\n\n    this.easyMotionDimIncSearch = vscode.window.createTextEditorDecorationType({\n      color: configuration.easymotionDimColor,\n    });\n\n    this.insertModeVirtualCharacter = vscode.window.createTextEditorDecorationType({\n      color: 'transparent', // no color to hide the existing character\n      before: {\n        color: 'currentColor',\n        backgroundColor: new vscode.ThemeColor('editor.background'),\n        borderColor: new vscode.ThemeColor('editor.background'),\n        margin: '0 -1ch 0 0',\n        height: '100%',\n      },\n    });\n\n    // This creates the half block cursor when on operator pending mode\n    this.operatorPendingModeCursor = vscode.window.createTextEditorDecorationType({\n      before: {\n        // no color to hide the existing character. We only need the character here to make\n        // the width be the same as the existing character.\n        color: 'transparent',\n        // The '-1ch' right margin is so that it displays on top of the existing character. The amount\n        // here doesn't really matter, it could be '-1px' it just needs to be negative so that the left\n        // of this 'before' element coincides with the left of the existing character.\n        margin: `0 -1ch 0 0;\n        position: absolute;\n        bottom: 0;\n        line-height: 0;`,\n        height: '50%',\n        backgroundColor: new vscode.ThemeColor('editorCursor.foreground'),\n      },\n    });\n\n    // This puts a character on top of the half block cursor and on top of the existing character\n    // to create the mix-blend 'magic'\n    this.operatorPendingModeCursorChar = vscode.window.createTextEditorDecorationType({\n      // We make the existing character 'black' -> rgb(0,0,0), because when using the mix-blend-mode\n      // with 'exclusion' it subtracts the darker color from the lightest color which means we will\n      // subtract zero from our 'currentcolor' leaving us with 'currentcolor' on the part above the\n      // background of the half cursor.\n      color: 'black',\n      before: {\n        color: 'currentcolor',\n        // The '-1ch' right margin is so that it displays on top of the existing character. The amount\n        // here doesn't really matter, it could be '-1px' it just needs to be negative so that the left\n        // of this 'before' element coincides with the left of the existing character.\n        margin: `0 -1ch 0 0;\n        position: absolute;\n        mix-blend-mode: exclusion;`,\n        height: '100%',\n      },\n    });\n  }\n}\n\nexport const decoration = new DecorationImpl();\n","import { IConfiguration } from './iconfiguration';\n\ninterface IValidatorResult {\n  level: 'error' | 'warning';\n  message: string;\n}\n\nexport class ValidatorResults {\n  errors = new Array<IValidatorResult>();\n\n  public append(validationResult: IValidatorResult) {\n    this.errors.push(validationResult);\n  }\n\n  public concat(validationResults: ValidatorResults) {\n    this.errors = this.errors.concat(validationResults.get());\n  }\n\n  public get(): ReadonlyArray<IValidatorResult> {\n    return this.errors;\n  }\n\n  public get numErrors(): number {\n    return this.errors.filter((e) => e.level === 'error').length;\n  }\n\n  public get hasError(): boolean {\n    return this.numErrors > 0;\n  }\n\n  public get numWarnings(): number {\n    return this.errors.filter((e) => e.level === 'warning').length;\n  }\n\n  public get hasWarning(): boolean {\n    return this.numWarnings > 0;\n  }\n}\n\nexport interface IConfigurationValidator {\n  validate(config: IConfiguration): Promise<ValidatorResults>;\n  disable(config: IConfiguration): void;\n}\n","export class Notation {\n  // Mapping from a regex to the normalized string that it should be converted to.\n  private static readonly notationMap: ReadonlyArray<[RegExp, string]> = [\n    [/ctrl\\+|c\\-/gi, 'C-'],\n    [/cmd\\+|d\\-/gi, 'D-'],\n    [/shift\\+|s\\-/gi, 'S-'],\n    [/escape|esc/gi, 'Esc'],\n    [/backspace|bs/gi, 'BS'],\n    [/delete|del/gi, 'Del'],\n    [/home/gi, 'Home'],\n    [/end/gi, 'End'],\n    [/insert/gi, 'Insert'],\n    [/<space>/gi, ' '],\n    [/<cr>|<enter>|<return>/gi, '\\n'],\n  ];\n\n  private static shiftedLetterRegex = /<S-[a-zA-Z]>/;\n\n  /**\n   * Converts keystroke like <tab> to a single control character like \\t\n   */\n  public static ToControlCharacter(key: string) {\n    if (key === '<tab>') {\n      return '\\t';\n    }\n\n    return key;\n  }\n\n  public static IsControlKey(key: string): boolean {\n    key = key.toLocaleUpperCase();\n    return (\n      this.isSurroundedByAngleBrackets(key) && key !== '<BS>' && key !== '<S-BS>' && key !== '<TAB>'\n    );\n  }\n\n  /**\n   * Normalizes key to AngleBracketNotation\n   * (e.g. <ctrl+x>, Ctrl+x, <c-x> normalized to <C-x>)\n   * and converts the characters to their literals\n   * (e.g. <space>, <cr>, <leader>)\n   */\n  public static NormalizeKey(key: string, leaderKey: string): string {\n    if (typeof key !== 'string') {\n      return key;\n    }\n\n    if (key.length === 1) {\n      return key;\n    }\n\n    key = key.toLocaleLowerCase();\n\n    if (!this.isSurroundedByAngleBrackets(key)) {\n      key = `<${key}>`;\n    }\n\n    if (key === '<leader>') {\n      return leaderKey;\n    }\n\n    if (['<up>', '<down>', '<left>', '<right>'].includes(key)) {\n      return key;\n    }\n\n    for (const [regex, standardNotation] of this.notationMap) {\n      key = key.replace(regex, standardNotation);\n    }\n\n    if (this.shiftedLetterRegex.test(key)) {\n      key = key[3].toUpperCase();\n    }\n\n    return key;\n  }\n\n  /**\n   * Converts a key to a form which will look nice when logged, etc.\n   */\n  public static printableKey(key: string, leaderKey: string) {\n    const normalized = this.NormalizeKey(key, leaderKey);\n    return normalized === ' ' ? '<space>' : normalized === '\\n' ? '<enter>' : normalized;\n  }\n\n  private static isSurroundedByAngleBrackets(key: string): boolean {\n    return key.startsWith('<') && key.endsWith('>');\n  }\n}\n","import * as vscode from 'vscode';\nimport { IKeyRemapping } from './iconfiguration';\nimport { Logger } from '../util/logger';\nimport { ModeHandler } from '../mode/modeHandler';\nimport { Mode } from '../mode/mode';\nimport { commandLine } from '../cmd_line/commandLine';\nimport { configuration } from '../configuration/configuration';\nimport { StatusBar } from '../statusBar';\nimport { VimError, ErrorCode, ForceStopRemappingError } from '../error';\nimport { SpecialKeys } from '../util/specialKeys';\n\ninterface IRemapper {\n  /**\n   * Send keys to remapper\n   */\n  sendKey(keys: string[], modeHandler: ModeHandler): Promise<boolean>;\n\n  /**\n   * Given keys pressed thus far, denotes if it is a potential remap\n   */\n  readonly isPotentialRemap: boolean;\n}\n\nexport class Remappers implements IRemapper {\n  private readonly remappers = [\n    new InsertModeRemapper(),\n    new NormalModeRemapper(),\n    new VisualModeRemapper(),\n    new CommandLineModeRemapper(),\n    new OperatorPendingModeRemapper(),\n  ];\n\n  get isPotentialRemap(): boolean {\n    return this.remappers.some((r) => r.isPotentialRemap);\n  }\n\n  public async sendKey(keys: string[], modeHandler: ModeHandler): Promise<boolean> {\n    for (const remapper of this.remappers) {\n      if (await remapper.sendKey(keys, modeHandler)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexport class Remapper implements IRemapper {\n  private readonly configKey: string;\n  private readonly remappedModes: Mode[];\n  private readonly logger = Logger.get('Remapper');\n\n  /**\n   * Checks if the current commandList is a potential remap.\n   */\n  private _isPotentialRemap = false;\n\n  /**\n   * If the commandList has a remap but there is still another potential remap we\n   * call it an Ambiguous Remap and we store it here. If later we need to handle it\n   * we don't need to go looking for it.\n   */\n  private hasAmbiguousRemap: IKeyRemapping | undefined;\n\n  /**\n   * If the commandList is a potential remap but has no ambiguous remap\n   * yet, we say that it has a Potential Remap.\n   *\n   * This is to distinguish the commands with ambiguous remaps and the\n   * ones without.\n   *\n   * Example 1: if 'aaaa' is mapped and so is 'aa', when the user has pressed\n   * 'aaa' we say it has an Ambiguous Remap which is 'aa', because if the\n   * user presses other key than 'a' next or waits for the timeout to finish\n   * we need to now that there was a remap to run so we first run the 'aa'\n   * remap and then handle the remaining keys.\n   *\n   * Example 2: if only 'aaaa' is mapped, when the user has pressed 'aaa'\n   * we say it has a Potential Remap, because if the user presses other key\n   * than 'a' next or waits for the timeout to finish we need to now that\n   * there was a potential remap that never came or was broken, so we can\n   * resend the keys again without allowing for a potential remap on the first\n   * key, which means we won't get to the same state because the first key\n   * will be handled as an action (in this case a 'CommandInsertAfterCursor')\n   */\n  private hasPotentialRemap = false;\n\n  get isPotentialRemap(): boolean {\n    return this._isPotentialRemap;\n  }\n\n  constructor(configKey: string, remappedModes: Mode[]) {\n    this.configKey = configKey;\n    this.remappedModes = remappedModes;\n  }\n\n  public async sendKey(keys: string[], modeHandler: ModeHandler): Promise<boolean> {\n    const { vimState, remapState } = modeHandler;\n\n    this._isPotentialRemap = false;\n    const allowPotentialRemapOnFirstKey = vimState.recordedState.allowPotentialRemapOnFirstKey;\n    let remainingKeys: string[] = [];\n\n    /**\n     * Means that the timeout finished so we now can't allow the keys to be buffered again\n     * because the user already waited for timeout.\n     */\n    let allowBufferingKeys = true;\n\n    if (!this.remappedModes.includes(vimState.currentModeIncludingPseudoModes)) {\n      return false;\n    }\n\n    const userDefinedRemappings = configuration[this.configKey] as Map<string, IKeyRemapping>;\n\n    if (keys[keys.length - 1] === SpecialKeys.TimeoutFinished) {\n      // Timeout finished. Don't let an ambiguous or potential remap start another timeout again\n      keys = keys.slice(0, keys.length - 1);\n      allowBufferingKeys = false;\n    }\n\n    if (keys.length === 0) {\n      return true;\n    }\n\n    this.logger.debug(\n      `trying to find matching remap. keys=${keys}. mode=${\n        Mode[vimState.currentMode]\n      }. keybindings=${this.configKey}.`\n    );\n\n    let remapping: IKeyRemapping | undefined = this.findMatchingRemap(\n      userDefinedRemappings,\n      keys,\n      vimState.currentMode\n    );\n\n    // Check to see if a remapping could potentially be applied when more keys are received\n    let isPotentialRemap = Remapper.hasPotentialRemap(keys, userDefinedRemappings);\n\n    this._isPotentialRemap =\n      isPotentialRemap && allowBufferingKeys && allowPotentialRemapOnFirstKey;\n\n    /**\n     * Handle a broken potential or ambiguous remap\n     * 1. If this Remapper doesn't have a remapping AND\n     * 2. (It previously had an AmbiguousRemap OR a PotentialRemap) AND\n     * 3. (It doesn't have a potential remap anymore OR timeout finished) AND\n     * 4. keys length is more than 1\n     *\n     * Points 1-3: If we no longer have a remapping but previously had one or a potential one\n     * and there is no longer potential remappings because of another pressed key or because the\n     * timeout has passed we need to handle those situations by resending the keys or handling the\n     * ambiguous remap and resending any remaining keys.\n     * Point 4: if there is only one key there is no point in resending it without allowing remaps\n     * on first key, we can let the remapper go to the end because since either there was no potential\n     * remap anymore or the timeout finished so this means that the next two checks (the 'Buffer keys\n     * and create timeout' and 'Handle remapping and remaining keys') will never be hit, so it reaches\n     * the end without doing anything which means that this key will be handled as an action as intended.\n     */\n    if (\n      !remapping &&\n      (this.hasAmbiguousRemap || this.hasPotentialRemap) &&\n      (!isPotentialRemap || !allowBufferingKeys) &&\n      keys.length > 1\n    ) {\n      if (this.hasAmbiguousRemap) {\n        remapping = this.hasAmbiguousRemap;\n        isPotentialRemap = false;\n        this._isPotentialRemap = false;\n\n        // Use the commandList to get the remaining keys so that it includes any existing\n        // '<TimeoutFinished>' key\n        remainingKeys = vimState.recordedState.commandList.slice(remapping.before.length);\n        this.hasAmbiguousRemap = undefined;\n      }\n      if (!remapping) {\n        // if there is still no remapping, handle all the keys without allowing\n        // a potential remap on the first key so that we don't repeat everything\n        // again, but still allow for other ambiguous remaps after the first key.\n        //\n        // Example: if 'iiii' is mapped in normal and 'ii' is mapped in insert mode,\n        // and the user presses 'iiia' in normal mode or presses 'iii' and waits\n        // for the timeout to finish, we want the first 'i' to be handled without\n        // allowing potential remaps, which means it will go into insert mode,\n        // but then the next 'ii' should be remapped in insert mode and after the\n        // remap the 'a' should be handled.\n        if (!allowBufferingKeys) {\n          // Timeout finished and there is no remapping, so handle the buffered\n          // keys but resend the '<TimeoutFinished>' key as well so we don't wait\n          // for the timeout again but can still handle potential remaps.\n          //\n          // Example 1: if 'ccc' is mapped in normal mode and user presses 'cc' and\n          // waits for the timeout to finish, this will resend the 'cc<TimeoutFinished>'\n          // keys without allowing a potential remap on first key, which makes the\n          // first 'c' be handled as a 'ChangeOperator' and the second 'c' which has\n          // potential remaps (the 'ccc' remap) is buffered and the timeout started\n          // but then the '<TimeoutFinished>' key comes straight away that clears the\n          // timeout without waiting again, and makes the second 'c' be handled normally\n          // as another 'ChangeOperator'.\n          //\n          // Example 2: if 'iiii' is mapped in normal and 'ii' is mapped in insert\n          // mode, and the user presses 'iii' in normal mode and waits for the timeout\n          // to finish, this will resend the 'iii<TimeoutFinished>' keys without allowing\n          // a potential remap on first key, which makes the first 'i' be handled as\n          // an 'CommandInsertAtCursor' and goes to insert mode, next the second 'i'\n          // is buffered, then the third 'i' finds the insert mode remapping of 'ii'\n          // and handles that remap, after the remapping being handled the '<TimeoutFinished>'\n          // key comes that clears the timeout and since the commandList will be empty\n          // we return true as we finished handling this sequence of keys.\n\n          keys.push(SpecialKeys.TimeoutFinished); // include the '<TimeoutFinished>' key\n\n          this.logger.debug(\n            `${this.configKey}. timeout finished, handling timed out buffer keys without allowing a new timeout.`\n          );\n        }\n        this.logger.debug(\n          `${this.configKey}. potential remap broken. resending keys without allowing a potential remap on first key. keys=${keys}`\n        );\n        this.hasPotentialRemap = false;\n        vimState.recordedState.allowPotentialRemapOnFirstKey = false;\n        vimState.recordedState.resetCommandList();\n\n        if (remapState.wasPerformingRemapThatFinishedWaitingForTimeout) {\n          // Some keys that broke the possible remap were typed by the user so handle them seperatly\n          const lastRemapLength =\n            remapState.wasPerformingRemapThatFinishedWaitingForTimeout.after!.length;\n          const keysPressedByUser = keys.slice(lastRemapLength);\n          keys = keys.slice(0, lastRemapLength);\n\n          try {\n            remapState.isCurrentlyPerformingRecursiveRemapping = true;\n            await modeHandler.handleMultipleKeyEvents(keys);\n          } catch (e) {\n            if (e instanceof ForceStopRemappingError) {\n              this.logger.debug(\n                `${this.configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`\n              );\n            }\n          } finally {\n            remapState.isCurrentlyPerformingRecursiveRemapping = false;\n            remapState.wasPerformingRemapThatFinishedWaitingForTimeout = false;\n            await modeHandler.handleMultipleKeyEvents(keysPressedByUser);\n          }\n        } else {\n          await modeHandler.handleMultipleKeyEvents(keys);\n        }\n        return true;\n      }\n    }\n\n    /**\n     * Buffer keys and create timeout\n     * 1. If the current keys have a potential remap AND\n     * 2. The timeout hasn't finished yet so we allow buffering keys AND\n     * 3. We allow potential remap on first key (check the note on RecordedState. TLDR: this will only\n     * be false for one key, the first one, when we resend keys that had a potential remap but no longer\n     * have it or the timeout finished)\n     *\n     * Points 1-3: If the current keys still have a potential remap and the timeout hasn't finished yet\n     * and we are not preventing a potential remap on the first key then we need to buffer this keys\n     * and wait for another key or the timeout to finish.\n     */\n    if (isPotentialRemap && allowBufferingKeys && allowPotentialRemapOnFirstKey) {\n      if (remapping) {\n        // There are other potential remaps (ambiguous remaps), wait for other key or for the timeout\n        // to finish. Also store this current ambiguous remap on '_hasAmbiguousRemap' so that if later\n        // this ambiguous remap is broken or the user waits for timeout we don't need to go looking for\n        // it again.\n        this.hasAmbiguousRemap = remapping;\n\n        this.logger.debug(\n          `${this.configKey}. ambiguous match found. before=${remapping.before}. after=${remapping.after}. command=${remapping.commands}. waiting for other key or timeout to finish.`\n        );\n      } else {\n        this.hasPotentialRemap = true;\n        this.logger.debug(\n          `${this.configKey}. potential remap found. waiting for other key or timeout to finish.`\n        );\n      }\n\n      // Store BufferedKeys\n      vimState.recordedState.bufferedKeys = [...keys];\n\n      // Create Timeout\n      vimState.recordedState.bufferedKeysTimeoutObj = setTimeout(() => {\n        modeHandler.handleKeyEvent(SpecialKeys.TimeoutFinished);\n      }, configuration.timeout);\n      return true;\n    }\n\n    /**\n     * Handle Remapping and any remaining keys\n     * If we get here with a remapping that means we need to handle it.\n     */\n    if (remapping) {\n      if (!allowBufferingKeys) {\n        // If the user already waited for the timeout to finish, prevent the\n        // remapping from waiting for the timeout again by making a clone of\n        // remapping and change 'after' to send the '<TimeoutFinished>' key at\n        // the end.\n        const newRemapping = { ...remapping };\n        newRemapping.after = remapping.after?.slice(0);\n        newRemapping.after?.push(SpecialKeys.TimeoutFinished);\n        remapping = newRemapping;\n      }\n\n      this.hasAmbiguousRemap = undefined;\n      this.hasPotentialRemap = false;\n\n      let skipFirstCharacter = false;\n\n      // If we were performing a remapping already, it means this remapping has a parent remapping\n      const hasParentRemapping = remapState.isCurrentlyPerformingRemapping;\n      if (!hasParentRemapping) {\n        remapState.mapDepth = 0;\n      }\n\n      if (!remapping.recursive) {\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = true;\n      } else {\n        remapState.isCurrentlyPerformingRecursiveRemapping = true;\n\n        // As per the Vim documentation: (:help recursive)\n        // If the {rhs} starts with {lhs}, the first character is not mapped\n        // again (this is Vi compatible).\n        // For example:\n        // map ab abcd\n        // will execute the \"a\" command and insert \"bcd\" in the text. The \"ab\"\n        // in the {rhs} will not be mapped again.\n        if (remapping.after?.join('').startsWith(remapping.before.join(''))) {\n          skipFirstCharacter = true;\n        }\n      }\n\n      // Increase mapDepth\n      remapState.mapDepth++;\n\n      this.logger.debug(\n        `${this.configKey}. match found. before=${remapping.before}. after=${remapping.after}. command=${remapping.commands}. remainingKeys=${remainingKeys}. mapDepth=${remapState.mapDepth}.`\n      );\n\n      let remapFailed = false;\n\n      try {\n        // Check maxMapDepth\n        if (remapState.mapDepth >= configuration.maxmapdepth) {\n          const vimError = VimError.fromCode(ErrorCode.RecursiveMapping);\n          StatusBar.displayError(vimState, vimError);\n          throw ForceStopRemappingError.fromVimError(vimError);\n        }\n\n        // Hacky code incoming!!! If someone has a better way to do this please change it\n        if (remapState.mapDepth % 10 === 0) {\n          // Allow the user to press <C-c> or <Esc> key when inside an infinite looping remap.\n          // When inside an infinite looping recursive mapping it would block the editor until it reached\n          // the maxmapdepth. This 0ms wait allows the extension to handle any key typed by the user which\n          // means it allows the user to press <C-c> or <Esc> to force stop the looping remap.\n          // This shouldn't impact the normal use case because we're only running this every 10 nested\n          // remaps. Also when the logs are set to Error only, a looping recursive remap takes around 1.5s\n          // to reach 1000 mapDepth and give back control to the user, but when logs are set to debug it\n          // can take as long as 7 seconds.\n          const wait = (ms: number) => new Promise((res) => setTimeout(res, ms));\n          await wait(0);\n        }\n\n        remapState.remapUsedACharacter = false;\n\n        await this.handleRemapping(remapping, modeHandler, skipFirstCharacter);\n      } catch (e) {\n        if (e instanceof ForceStopRemappingError) {\n          // If a motion fails or a VimError happens during any kind of remapping or if the user presses the\n          // force stop remapping key (<C-c> or <Esc>) during a recursive remapping it should stop handling\n          // the remap and all its parent remaps if we are on a chain of recursive remaps.\n          // (Vim documentation :help map-error)\n          remapFailed = true;\n\n          // keep throwing until we reach the first parent\n          if (hasParentRemapping) {\n            throw e;\n          }\n\n          this.logger.debug(\n            `${this.configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`\n          );\n        } else {\n          // If some other error happens during the remapping handling it should stop the remap and rethrow\n          this.logger.debug(\n            `${this.configKey}. error found in the middle of remapping, ignoring the rest of the remap. error: ${e}`\n          );\n          throw e;\n        }\n      } finally {\n        // Check if we are still inside a recursive remap\n        if (!hasParentRemapping && remapState.isCurrentlyPerformingRecursiveRemapping) {\n          // no more recursive remappings being handled\n          if (vimState.recordedState.bufferedKeysTimeoutObj !== undefined) {\n            // In order to be able to receive other keys and at the same time wait for timeout, we need\n            // to create a timeout and return from the remapper so that modeHandler can be free to receive\n            // more keys. This means that if we are inside a recursive remapping, when we return on the\n            // last key of that remapping it will think that it is finished and set the currently\n            // performing recursive remapping flag to false, which would result in the current bufferedKeys\n            // not knowing they had a parent remapping. So we store that remapping here.\n            remapState.wasPerformingRemapThatFinishedWaitingForTimeout = { ...remapping };\n          }\n          remapState.isCurrentlyPerformingRecursiveRemapping = false;\n          remapState.forceStopRecursiveRemapping = false;\n        }\n\n        if (!hasParentRemapping) {\n          // Last remapping finished handling. Set undo step.\n          vimState.historyTracker.finishCurrentStep();\n        }\n\n        // NonRecursive remappings can't have nested remaps so after a finished remap we always set this to\n        // false, because either we were performing a non recursive remap and now we finish or we weren't\n        // performing a non recursive remapping and this was false anyway.\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = false;\n\n        // if there were other remaining keys on the buffered keys that weren't part of the remapping\n        // handle them now, except if the remap failed and the remaining keys weren't typed by the user.\n        // (we know that if this remapping has a parent remapping then the remaining keys weren't typed\n        // by the user, but instead were sent by the parent remapping handler)\n        if (remainingKeys.length > 0 && !(remapFailed && hasParentRemapping)) {\n          if (remapState.wasPerformingRemapThatFinishedWaitingForTimeout) {\n            // If there was a performing remap that finished waiting for timeout then only the remaining keys\n            // that are not part of that remap were typed by the user.\n            let specialKey: string | undefined = '';\n            if (remainingKeys[remainingKeys.length - 1] === SpecialKeys.TimeoutFinished) {\n              specialKey = remainingKeys.pop();\n            }\n            const lastRemap = remapState.wasPerformingRemapThatFinishedWaitingForTimeout.after!;\n            const lastRemapWithoutAmbiguousRemap = lastRemap.slice(remapping.before.length);\n            const keysPressedByUser = remainingKeys.slice(lastRemapWithoutAmbiguousRemap.length);\n            remainingKeys = remainingKeys.slice(0, remainingKeys.length - keysPressedByUser.length);\n            if (specialKey) {\n              remainingKeys.push(specialKey);\n              if (keysPressedByUser.length !== 0) {\n                keysPressedByUser.push(specialKey);\n              }\n            }\n            try {\n              remapState.isCurrentlyPerformingRecursiveRemapping = true;\n              await modeHandler.handleMultipleKeyEvents(remainingKeys);\n            } catch (e) {\n              this.logger.debug(\n                `${this.configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`\n              );\n            } finally {\n              remapState.isCurrentlyPerformingRecursiveRemapping = false;\n              remapState.wasPerformingRemapThatFinishedWaitingForTimeout = false;\n              if (keysPressedByUser.length > 0) {\n                await modeHandler.handleMultipleKeyEvents(keysPressedByUser);\n              }\n            }\n          } else {\n            await modeHandler.handleMultipleKeyEvents(remainingKeys);\n          }\n        }\n      }\n\n      return true;\n    }\n\n    this.hasPotentialRemap = false;\n    this.hasAmbiguousRemap = undefined;\n    return false;\n  }\n\n  private async handleRemapping(\n    remapping: IKeyRemapping,\n    modeHandler: ModeHandler,\n    skipFirstCharacter: boolean\n  ) {\n    const { vimState, remapState } = modeHandler;\n\n    vimState.recordedState.resetCommandList();\n    if (remapping.after) {\n      if (skipFirstCharacter) {\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = true;\n        await modeHandler.handleKeyEvent(remapping.after[0]);\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = false;\n        await modeHandler.handleMultipleKeyEvents(remapping.after.slice(1));\n      } else {\n        await modeHandler.handleMultipleKeyEvents(remapping.after);\n      }\n    }\n\n    if (remapping.commands) {\n      const count = vimState.recordedState.count || 1;\n      vimState.recordedState.count = 0;\n      for (let i = 0; i < count; i++) {\n        for (const command of remapping.commands) {\n          let commandString: string;\n          let commandArgs: string[];\n          if (typeof command === 'string') {\n            commandString = command;\n            commandArgs = [];\n          } else {\n            commandString = command.command;\n            commandArgs = command.args;\n          }\n\n          if (commandString.slice(0, 1) === ':') {\n            // Check if this is a vim command by looking for :\n            await commandLine.Run(\n              commandString.slice(1, commandString.length),\n              modeHandler.vimState\n            );\n            await modeHandler.updateView();\n          } else if (commandArgs) {\n            await vscode.commands.executeCommand(commandString, commandArgs);\n          } else {\n            await vscode.commands.executeCommand(commandString);\n          }\n\n          StatusBar.setText(vimState, `${commandString} ${commandArgs ?? ''}`);\n        }\n      }\n    }\n  }\n\n  protected findMatchingRemap(\n    userDefinedRemappings: Map<string, IKeyRemapping>,\n    inputtedKeys: string[],\n    currentMode: Mode\n  ): IKeyRemapping | undefined {\n    if (userDefinedRemappings.size === 0) {\n      return undefined;\n    }\n\n    const range = Remapper.getRemappedKeysLengthRange(userDefinedRemappings);\n    const startingSliceLength = inputtedKeys.length;\n    const inputtedString = inputtedKeys.join('');\n    for (let sliceLength = startingSliceLength; sliceLength >= range[0]; sliceLength--) {\n      const keySlice = inputtedKeys.slice(-sliceLength).join('');\n\n      this.logger.verbose(`key=${inputtedKeys}. keySlice=${keySlice}.`);\n      if (userDefinedRemappings.has(keySlice)) {\n        const precedingKeys = inputtedString.slice(0, inputtedString.length - keySlice.length);\n        if (precedingKeys.length > 0 && !/^[0-9]+$/.test(precedingKeys)) {\n          this.logger.verbose(\n            `key sequences need to match precisely. precedingKeys=${precedingKeys}.`\n          );\n          break;\n        }\n\n        return userDefinedRemappings.get(keySlice);\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Given list of remappings, returns the length of the shortest and longest remapped keys\n   * @param remappings\n   */\n  protected static getRemappedKeysLengthRange(\n    remappings: ReadonlyMap<string, IKeyRemapping>\n  ): [number, number] {\n    if (remappings.size === 0) {\n      return [0, 0];\n    }\n    const keyLengths = Array.from(remappings.values()).map((remap) => remap.before.length);\n    return [Math.min(...keyLengths), Math.max(...keyLengths)];\n  }\n\n  /**\n   * Given list of keys and list of remappings, returns true if the keys are a potential remap\n   * @param keys the list of keys to be checked for potential remaps\n   * @param remappings The remappings Map\n   * @param countRemapAsPotential If the current keys are themselves a remap should they be considered a potential remap as well?\n   */\n  protected static hasPotentialRemap(\n    keys: string[],\n    remappings: ReadonlyMap<string, IKeyRemapping>,\n    countRemapAsPotential: boolean = false\n  ): boolean {\n    const keysAsString = keys.join('');\n    const re = /^<([^>]+)>/;\n    if (keysAsString !== '') {\n      for (const remap of remappings.keys()) {\n        if (remap.startsWith(keysAsString) && (remap !== keysAsString || countRemapAsPotential)) {\n          // Don't confuse a key combination starting with '<' that is not a special key like '<C-a>'\n          // with a remap that starts with a special key.\n          if (keysAsString.startsWith('<') && !re.test(keysAsString) && re.test(remap)) {\n            continue;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\nfunction keyBindingsConfigKey(mode: string): string {\n  return `${mode}ModeKeyBindingsMap`;\n}\n\nclass InsertModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('insert'), [Mode.Insert, Mode.Replace]);\n  }\n}\n\nclass NormalModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('normal'), [Mode.Normal]);\n  }\n}\n\nclass OperatorPendingModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('operatorPending'), [Mode.OperatorPendingMode]);\n  }\n}\n\nclass VisualModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('visual'), [Mode.Visual, Mode.VisualLine, Mode.VisualBlock]);\n  }\n}\n\nclass CommandLineModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('commandLine'), [\n      Mode.CommandlineInProgress,\n      Mode.SearchInProgressMode,\n    ]);\n  }\n}\n","import { IConfigurationValidator, ValidatorResults } from '../iconfigurationValidator';\nimport { IConfiguration } from '../iconfiguration';\nimport { existsAsync } from 'platform/fs';\nimport { Globals } from '../../globals';\nimport { configurationValidator } from '../configurationValidator';\n\nexport class InputMethodSwitcherConfigurationValidator implements IConfigurationValidator {\n  async validate(config: IConfiguration): Promise<ValidatorResults> {\n    const result = new ValidatorResults();\n\n    const inputMethodConfig = config.autoSwitchInputMethod;\n\n    if (!inputMethodConfig.enable || Globals.isTesting) {\n      return Promise.resolve(result);\n    }\n\n    if (!inputMethodConfig.switchIMCmd.includes('{im}')) {\n      result.append({\n        level: 'error',\n        message:\n          'vim.autoSwitchInputMethod.switchIMCmd is incorrect, it should contain the placeholder {im}.',\n      });\n    }\n\n    if (inputMethodConfig.obtainIMCmd === undefined || inputMethodConfig.obtainIMCmd === '') {\n      result.append({\n        level: 'error',\n        message: 'vim.autoSwitchInputMethod.obtainIMCmd is empty.',\n      });\n    } else if (!(await existsAsync(this.getRawCmd(inputMethodConfig.obtainIMCmd)))) {\n      result.append({\n        level: 'error',\n        message: `Unable to find ${inputMethodConfig.obtainIMCmd}. Check your 'vim.autoSwitchInputMethod.obtainIMCmd' in VSCode setting.`,\n      });\n    }\n\n    if (inputMethodConfig.defaultIM === undefined || inputMethodConfig.defaultIM === '') {\n      result.append({\n        level: 'error',\n        message: 'vim.autoSwitchInputMethod.defaultIM is empty.',\n      });\n    } else if (!(await existsAsync(this.getRawCmd(inputMethodConfig.switchIMCmd)))) {\n      result.append({\n        level: 'error',\n        message: `Unable to find ${inputMethodConfig.switchIMCmd}. Check your 'vim.autoSwitchInputMethod.switchIMCmd' in VSCode setting.`,\n      });\n    }\n\n    return Promise.resolve(result);\n  }\n\n  disable(config: IConfiguration) {\n    config.autoSwitchInputMethod.enable = false;\n  }\n\n  private getRawCmd(cmd: string): string {\n    return cmd.split(' ')[0];\n  }\n}\n\nconfigurationValidator.registerValidator(new InputMethodSwitcherConfigurationValidator());\n","import * as vscode from 'vscode';\nimport { IConfiguration, IKeyRemapping } from '../iconfiguration';\nimport { Notation } from '../notation';\nimport { IConfigurationValidator, ValidatorResults } from '../iconfigurationValidator';\nimport { configurationValidator } from '../configurationValidator';\nimport { PluginDefaultMappings } from '../../actions/plugins/pluginDefaultMappings';\n\nexport class RemappingValidator implements IConfigurationValidator {\n  private commandMap!: Map<string, boolean>;\n\n  async validate(config: IConfiguration): Promise<ValidatorResults> {\n    const result = new ValidatorResults();\n    const modeKeyBindingsKeys = [\n      'insertModeKeyBindings',\n      'insertModeKeyBindingsNonRecursive',\n      'normalModeKeyBindings',\n      'normalModeKeyBindingsNonRecursive',\n      'operatorPendingModeKeyBindings',\n      'operatorPendingModeKeyBindingsNonRecursive',\n      'visualModeKeyBindings',\n      'visualModeKeyBindingsNonRecursive',\n      'commandLineModeKeyBindings',\n      'commandLineModeKeyBindingsNonRecursive',\n    ];\n    for (const modeKeyBindingsKey of modeKeyBindingsKeys) {\n      const keybindings = config[modeKeyBindingsKey];\n      // add default mappings for activated plugins\n      // because we process keybindings backwards in next loop, user mapping will override\n      for (const pluginMapping of PluginDefaultMappings.getPluginDefaultMappings(\n        modeKeyBindingsKey,\n        config\n      )) {\n        // note concat(all mappings) does not work somehow\n        keybindings.push(pluginMapping);\n      }\n\n      const isRecursive = modeKeyBindingsKey.indexOf('NonRecursive') === -1;\n\n      const modeMapName = modeKeyBindingsKey.replace('NonRecursive', '');\n      let modeKeyBindingsMap = config[modeMapName + 'Map'] as Map<string, IKeyRemapping>;\n      if (!modeKeyBindingsMap) {\n        modeKeyBindingsMap = new Map<string, IKeyRemapping>();\n      }\n      for (let i = keybindings.length - 1; i >= 0; i--) {\n        const remapping = keybindings[i] as IKeyRemapping;\n\n        // set 'recursive' of the remapping according to where it was stored\n        remapping.recursive = isRecursive;\n\n        // validate\n        const remappingError = await this.isRemappingValid(remapping);\n        result.concat(remappingError);\n        if (remappingError.hasError) {\n          // errors with remapping, skip\n          keybindings.splice(i, 1);\n          continue;\n        }\n\n        // normalize\n        if (remapping.before) {\n          remapping.before.forEach(\n            (key, idx) => (remapping.before[idx] = Notation.NormalizeKey(key, config.leader))\n          );\n        }\n\n        if (remapping.after) {\n          remapping.after.forEach(\n            (key, idx) => (remapping.after![idx] = Notation.NormalizeKey(key, config.leader))\n          );\n        }\n\n        // check for duplicates\n        const beforeKeys = remapping.before.join('');\n        if (modeKeyBindingsMap.has(beforeKeys)) {\n          result.append({\n            level: 'warning',\n            message: `${remapping.before}. Duplicate remapped key for ${beforeKeys}.`,\n          });\n          continue;\n        }\n\n        // add to map\n        modeKeyBindingsMap.set(beforeKeys, remapping);\n      }\n\n      config[modeMapName + 'Map'] = modeKeyBindingsMap;\n    }\n\n    return result;\n  }\n\n  disable(config: IConfiguration) {\n    // no-op\n  }\n\n  private async isRemappingValid(remapping: IKeyRemapping): Promise<ValidatorResults> {\n    const result = new ValidatorResults();\n\n    if (!remapping.after && !remapping.commands) {\n      result.append({\n        level: 'error',\n        message: `${remapping.before} missing 'after' key or 'command'.`,\n      });\n    }\n\n    if (!(remapping.before instanceof Array)) {\n      result.append({\n        level: 'error',\n        message: `Remapping of '${remapping.before}' should be a string array.`,\n      });\n    }\n\n    if (remapping.recursive === undefined) {\n      result.append({\n        level: 'error',\n        message: `Remapping of '${remapping.before}' missing 'recursive' info.`,\n      });\n    }\n\n    if (remapping.after && !(remapping.after instanceof Array)) {\n      result.append({\n        level: 'error',\n        message: `Remapping of '${remapping.after}' should be a string array.`,\n      });\n    }\n\n    if (remapping.commands) {\n      for (const command of remapping.commands) {\n        let cmd: string;\n\n        if (typeof command === 'string') {\n          cmd = command;\n        } else if (command.command) {\n          cmd = command.command;\n\n          if (!(await this.isCommandValid(cmd))) {\n            result.append({ level: 'warning', message: `${cmd} does not exist.` });\n          }\n        } else {\n          result.append({\n            level: 'error',\n            message: `Remapping of '${remapping.before}' has wrong \"commands\" structure. Should be 'string[] | { \"command\": string, \"args\": any[] }[]'.`,\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private async isCommandValid(command: string): Promise<boolean> {\n    if (command.startsWith(':')) {\n      return true;\n    }\n\n    return (await this.getCommandMap()).has(command);\n  }\n\n  private async getCommandMap(): Promise<Map<string, boolean>> {\n    if (this.commandMap == null) {\n      this.commandMap = new Map(\n        (await vscode.commands.getCommands(true)).map((x) => [x, true] as [string, boolean])\n      );\n    }\n    return this.commandMap;\n  }\n}\n\nconfigurationValidator.registerValidator(new RemappingValidator());\n","import * as vscode from 'vscode';\n\n/**\n * We consider two editors to be the same iff their EditorIdentities are the same\n */\nexport class EditorIdentity {\n  public readonly fileName: string;\n\n  public static fromEditor(textEditor: vscode.TextEditor | undefined) {\n    return new EditorIdentity(textEditor?.document?.fileName ?? '');\n  }\n\n  public constructor(fileName: string) {\n    this.fileName = fileName;\n  }\n\n  public isEqual(other: EditorIdentity): boolean {\n    return this.fileName === other.fileName;\n  }\n\n  public toString() {\n    return this.fileName;\n  }\n}\n","interface IErrorMessage {\n  [index: number]: string;\n}\n\nexport enum ErrorCode {\n  InvalidAddress = 14,\n  InvalidRange = 16,\n  MarkNotSet = 20,\n  NoAlternateFile = 23,\n  NoInsertedTextYet = 29,\n  NoFileName = 32,\n  NoPreviousSubstituteRegularExpression = 33,\n  NoPreviousCommand = 34,\n  NoPreviousRegularExpression = 35,\n  NoWriteSinceLastChange = 37,\n  ErrorWritingToFile = 208,\n  RecursiveMapping = 223,\n  NoStringUnderCursor = 348,\n  NothingInRegister = 353,\n  InvalidRegisterName = 354,\n  SearchHitTop = 384,\n  SearchHitBottom = 385,\n  CannotCloseLastWindow = 444,\n  ArgumentRequired = 471,\n  InvalidArgument = 474,\n  NoRangeAllowed = 481,\n  PatternNotFound = 486,\n  TrailingCharacters = 488,\n  NotAnEditorCommand = 492,\n  NoBuffersDeleted = 516,\n  UnknownOption = 518,\n  AtStartOfChangeList = 662,\n  AtEndOfChangeList = 663,\n  ChangeListIsEmpty = 664,\n  NoPreviouslyUsedRegister = 748,\n}\n\nexport const ErrorMessage: IErrorMessage = {\n  14: 'Invalid address',\n  16: 'Invalid range',\n  20: 'Mark not set',\n  23: 'No alternate file',\n  29: 'No inserted text yet',\n  32: 'No file name',\n  33: 'No previous substitute regular expression',\n  34: 'No previous command',\n  35: 'No previous regular expression',\n  37: 'No write since last change (add ! to override)',\n  208: 'Error writing to file',\n  223: 'Recursive mapping',\n  348: 'No string under cursor',\n  353: 'Nothing in register',\n  354: 'Invalid register name',\n  384: 'Search hit TOP without match for',\n  385: 'Search hit BOTTOM without match for',\n  444: 'Cannot close last window',\n  471: 'Argument required',\n  474: 'Invalid argument',\n  481: 'No range allowed',\n  486: 'Pattern not found',\n  488: 'Trailing characters',\n  492: 'Not an editor command',\n  516: 'No buffers were deleted',\n  518: 'Unknown option',\n  662: 'At start of changelist',\n  663: 'At end of changelist',\n  664: 'changelist is empty',\n  748: 'No previously used register',\n};\n\nexport class VimError extends Error {\n  public readonly code: number;\n  public override readonly message: string;\n\n  private constructor(code: number, message: string) {\n    super();\n    this.code = code;\n    this.message = message;\n  }\n\n  static fromCode(code: ErrorCode, extraValue?: string): VimError {\n    if (ErrorMessage[code]) {\n      if (extraValue) {\n        if (code === ErrorCode.NothingInRegister) {\n          extraValue = ` ${extraValue}`;\n        } else {\n          extraValue = `: ${extraValue}`;\n        }\n      }\n      return new VimError(code, ErrorMessage[code] + (extraValue ?? ''));\n    }\n\n    throw new Error('unknown error code: ' + code);\n  }\n\n  override toString(): string {\n    return `E${this.code}: ${this.message}`;\n  }\n}\n\n/**\n * Used to stop a remapping or a chain of nested remappings after a VimError, a failed action\n * or the force stop recursive mapping key (<C-c> or <Esc>). (Vim doc :help map-error)\n */\nexport class ForceStopRemappingError extends Error {\n  constructor(reason: string = 'StopRemapping') {\n    super(reason);\n  }\n\n  static fromVimError(vimError: VimError): ForceStopRemappingError {\n    return new ForceStopRemappingError(vimError.toString());\n  }\n}\n","import { IConfiguration } from './configuration/iconfiguration';\n\n/**\n * Global variables shared throughout extension\n */\nexport class Globals {\n  /**\n   * This is where we put files like HistoryFile. The path is given to us by VSCode.\n   */\n  static extensionStoragePath: string;\n\n  /**\n   * Used for testing.\n   */\n  static isTesting = false;\n  static mockConfiguration: IConfiguration;\n}\n","import { ExtensionContext } from 'vscode';\nimport { Logger } from '../util/logger';\nimport { configuration } from '../configuration/configuration';\nimport { Globals } from '../globals';\nimport { HistoryBase } from 'platform/history';\n\nexport class HistoryFile {\n  private readonly logger = Logger.get('HistoryFile');\n  private base: HistoryBase;\n\n  get historyFilePath(): string {\n    return this.base.historyKey;\n  }\n\n  constructor(context: ExtensionContext, historyFileName: string) {\n    this.base = new HistoryBase(\n      context,\n      historyFileName,\n      Globals.extensionStoragePath,\n      this.logger\n    );\n  }\n\n  public async add(value: string | undefined): Promise<void> {\n    return this.base.add(value, configuration.history);\n  }\n\n  public get(): string[] {\n    return this.base.get(configuration.history);\n  }\n\n  public clear() {\n    this.base.clear();\n  }\n\n  public async load(): Promise<void> {\n    await this.base.load();\n  }\n}\n\nexport class SearchHistory extends HistoryFile {\n  constructor(context: ExtensionContext) {\n    super(context, '.search_history');\n  }\n}\n\nexport class CommandLineHistory extends HistoryFile {\n  constructor(context: ExtensionContext) {\n    super(context, '.cmdline_history');\n  }\n}\n","/**\n * HistoryTracker is a handrolled undo/redo tracker for VSC. We currently\n * track history as a list of \"steps\", each of which consists of 1 or more\n * \"changes\".\n *\n * A Change is something like adding or deleting a few letters.\n *\n * A Step is multiple Changes.\n *\n * Undo/Redo will advance forward or backwards through Steps.\n */\nimport DiffMatchPatch = require('diff-match-patch');\nimport * as vscode from 'vscode';\n\nimport { VimState } from './../state/vimState';\nimport { TextEditor } from './../textEditor';\nimport { StatusBar } from '../statusBar';\nimport { Position } from 'vscode';\nimport { Jump } from '../jumps/jump';\nimport { globalState } from '../state/globalState';\nimport { Mode } from '../mode/mode';\nimport { ErrorCode, VimError } from '../error';\nimport { Logger } from '../util/logger';\nimport { earlierOf } from '../common/motion/position';\n\nconst diffEngine = new DiffMatchPatch.diff_match_patch();\ndiffEngine.Diff_Timeout = 1; // 1 second\n\nconst logger = Logger.get('HistoryTracker');\n\nclass DocumentChange {\n  /**\n   * The Position at which this change starts\n   */\n  public readonly start: Position;\n\n  /**\n   * The text that existed before this change\n   */\n  public readonly before: string;\n\n  /**\n   * The text that exists after this change\n   */\n  public readonly after: string;\n\n  public static insert(start: Position, text: string) {\n    return new DocumentChange(start, '', text);\n  }\n\n  public static delete(start: Position, text: string) {\n    return new DocumentChange(start, text, '');\n  }\n\n  public static replace(start: Position, before: string, after: string) {\n    return new DocumentChange(start, before, after);\n  }\n\n  /**\n   * @returns A new DocumentChange that represents undoing this change\n   */\n  public reversed() {\n    return DocumentChange.replace(this.start, this.after, this.before);\n  }\n\n  private constructor(start: Position, before: string, after: string) {\n    this.start = start;\n    this.before = before;\n    this.after = after;\n  }\n\n  /**\n   * Run this change.\n   */\n  public async do(editor: vscode.TextEditor): Promise<void> {\n    await TextEditor.replace(editor, this.beforeRange, this.after);\n  }\n\n  /**\n   * Run this change in reverse.\n   */\n  public async undo(editor: vscode.TextEditor): Promise<void> {\n    await TextEditor.replace(editor, this.afterRange, this.before);\n  }\n\n  /**\n   * The Range that the before text occupied\n   */\n  public get beforeRange(): vscode.Range {\n    return new vscode.Range(this.start, this.start.advancePositionByText(this.before));\n  }\n\n  /**\n   * The Range that the after text occupies\n   */\n  public get afterRange(): vscode.Range {\n    return new vscode.Range(this.start, this.start.advancePositionByText(this.after));\n  }\n}\n\nexport interface IMark {\n  name: string;\n  position: Position;\n  isUppercaseMark: boolean;\n  document?: vscode.TextDocument; // only required when using global marks (isUppercaseMark is true)\n}\n\n/**\n * An undo's worth of changes; generally corresponds to a single action.\n */\nclass HistoryStep {\n  /**\n   * The insertions and deletions that occured in this history step.\n   */\n  public changes: DocumentChange[];\n\n  /**\n   * Whether the user is still inserting or deleting for this history step.\n   */\n  public isFinished = false;\n\n  /**\n   * When this step was finished.\n   * // TODO: we currently set it to the current time upon creation to cover some edge cases, but this is messy.\n   */\n  public timestamp: Date;\n\n  /**\n   * The cursor position at the start of this history step.\n   * Restored by `u`. Currently, only one cursor is remembered.\n   */\n  public cursorStart: Position | undefined;\n\n  /**\n   * The position of every mark at the start of this history step.\n   */\n  public marks: IMark[] = [];\n\n  /**\n   * HACK: true if this step came from `U`.\n   * In `UU`, the second `U` should undo the first, and no more.\n   */\n  public readonly cameFromU: boolean;\n\n  /**\n   * \"global\" marks which operate across files. (when IMark.name is uppercase)\n   */\n  static globalMarks: IMark[] = [];\n\n  constructor(init: { marks: IMark[]; changes?: DocumentChange[]; cameFromU?: boolean }) {\n    this.changes = init.changes ?? [];\n    this.marks = init.marks ?? [];\n    this.cameFromU = init.cameFromU ?? false;\n\n    // This will usually be overwritten when the HistoryStep is finished\n    this.timestamp = new Date();\n  }\n\n  /**\n   * Collapse individual character changes into larger blocks of changes\n   */\n  public merge(document: vscode.TextDocument): void {\n    if (this.changes.length < 2) {\n      return;\n    }\n\n    // merged will replace this.changes\n    const merged: DocumentChange[] = [];\n    // manually reduce() this.changes with variables `current` and `next`\n    // we can't use reduce() directly because the loop can emit multiple elements\n    let current = this.changes[0];\n    for (const next of this.changes.slice(1)) {\n      if (current.before.length + current.after.length === 0) {\n        // current is eliminated, replace it with top of merged, or adopt next as current\n        // see also add+del case\n        if (merged.length > 0) {\n          current = merged.pop()!;\n        } else {\n          current = next;\n          continue;\n        }\n      }\n\n      const intersect = current.afterRange.intersection(next.beforeRange);\n      if (intersect) {\n        const [first, second] = current.start.isBeforeOrEqual(next.start)\n          ? [current, next]\n          : [next, current];\n        const intersectLength =\n          document.offsetAt(intersect.end) - document.offsetAt(intersect.start);\n        current = DocumentChange.replace(\n          first.start,\n          first.before + second.before.slice(intersectLength),\n          first.after.slice(0, first.after.length - intersectLength) + second.after\n        );\n      } else {\n        merged.push(current);\n        current = next;\n      }\n    }\n    merged.push(current);\n    this.changes = merged;\n  }\n\n  /**\n   * Returns, as a string, the time that has passed since this step took place.\n   */\n  public howLongAgo(): string {\n    const now = new Date();\n    const timeDiffMillis = now.getTime() - this.timestamp.getTime();\n    const timeDiffSeconds = Math.floor(timeDiffMillis / 1000);\n    if (timeDiffSeconds === 1) {\n      return `1 second ago`;\n    } else if (timeDiffSeconds >= 100) {\n      const hours = this.timestamp.getHours();\n      const minutes = this.timestamp.getMinutes().toString().padStart(2, '0');\n      const seconds = this.timestamp.getSeconds().toString().padStart(2, '0');\n      return `${hours}:${minutes}:${seconds}`;\n    } else {\n      return `${timeDiffSeconds} seconds ago`;\n    }\n  }\n}\n\n/**\n * A simple wrapper around a list of HistorySteps, for sanity's sake\n */\nclass UndoStack {\n  private historySteps: HistoryStep[] = [];\n  private currentStepIndex = -1;\n\n  // The marks as they existed before the first HistoryStep\n  private initialMarks: IMark[] = [];\n\n  public getHistoryStepAtIndex(idx: number): HistoryStep | undefined {\n    return this.historySteps[idx];\n  }\n\n  public getCurrentHistoryStepIndex(): number {\n    return this.currentStepIndex;\n  }\n\n  public getStackDepth(): number {\n    return this.historySteps.length;\n  }\n\n  /**\n   * @returns the current HistoryStep, or undefined if nothing's been done yet\n   */\n  public getCurrentHistoryStep(): HistoryStep | undefined {\n    if (this.currentStepIndex === -1) {\n      return undefined;\n    }\n\n    return this.historySteps[this.currentStepIndex];\n  }\n\n  /**\n   * Goes forward in time (redo), if possible\n   *\n   * @returns the new current HistoryStep, or undefined if none exists\n   */\n  public stepForward(): HistoryStep | undefined {\n    if (this.currentStepIndex === this.historySteps.length - 1) {\n      return undefined;\n    }\n\n    this.currentStepIndex++;\n    return this.getCurrentHistoryStep();\n  }\n\n  /**\n   * Goes backward in time (undo), if possible\n   *\n   * @returns the old HistoryStep, or undefined if there was none\n   */\n  public stepBackward(): HistoryStep | undefined {\n    const step = this.getCurrentHistoryStep();\n    if (step) {\n      this.currentStepIndex--;\n    }\n    return step;\n  }\n\n  /**\n   * Adds a change to the current unfinished step if there is one, or a new step if there isn't\n   */\n  public pushChange(change: DocumentChange): void {\n    let step = this.getCurrentHistoryStep();\n    if (step === undefined || step.isFinished) {\n      this.currentStepIndex++;\n      this.historySteps.splice(this.currentStepIndex);\n      step = new HistoryStep({\n        marks: step?.marks ?? this.initialMarks,\n      });\n      this.historySteps.push(step);\n    }\n\n    step.changes.push(change);\n  }\n\n  /**\n   * You probably don't want to use this.\n   * @see pushChange\n   */\n  public pushHistoryStep(step: HistoryStep) {\n    this.currentStepIndex++;\n    this.historySteps.splice(this.currentStepIndex + 1);\n    this.historySteps.push(step);\n  }\n\n  public getCurrentMarkList(): IMark[] {\n    const step = this.getCurrentHistoryStep();\n    return step?.marks ?? this.initialMarks;\n  }\n\n  public removeMarks(marks?: string[]): void {\n    const step = this.getCurrentHistoryStep();\n    if (marks === undefined) {\n      if (step) {\n        step.marks = [];\n      } else {\n        this.initialMarks = [];\n      }\n    } else {\n      if (step) {\n        step.marks = step.marks.filter((m) => !marks.includes(m.name));\n      } else {\n        this.initialMarks = this.initialMarks.filter((m) => !marks.includes(m.name));\n      }\n    }\n  }\n}\n\nclass ChangeList {\n  private readonly changeLocations: Position[] = [];\n  private index: number | undefined;\n\n  public addChangePosition(position: Position) {\n    if (\n      this.changeLocations.length > 0 &&\n      this.changeLocations[this.changeLocations.length - 1].line === position.line\n    ) {\n      this.changeLocations[this.changeLocations.length - 1] = position;\n    } else {\n      this.changeLocations.push(position);\n    }\n\n    this.index = undefined;\n  }\n\n  public nextChangePosition(): Position | VimError {\n    if (this.index === undefined) {\n      if (this.changeLocations.length === 0) {\n        return VimError.fromCode(ErrorCode.ChangeListIsEmpty);\n      }\n      this.index = this.changeLocations.length - 1;\n      return this.changeLocations[this.index];\n    } else if (this.index < this.changeLocations.length - 1) {\n      this.index++;\n      return this.changeLocations[this.index];\n    } else {\n      return VimError.fromCode(ErrorCode.AtEndOfChangeList);\n    }\n  }\n\n  public prevChangePosition(): Position | VimError {\n    if (this.index === undefined) {\n      if (this.changeLocations.length === 0) {\n        return VimError.fromCode(ErrorCode.ChangeListIsEmpty);\n      }\n      this.index = this.changeLocations.length - 1;\n      return this.changeLocations[this.index];\n    } else if (this.index > 0) {\n      this.index--;\n      return this.changeLocations[this.index];\n    } else {\n      return VimError.fromCode(ErrorCode.AtStartOfChangeList);\n    }\n  }\n}\n\nexport class HistoryTracker {\n  public lastContentChanges: vscode.TextDocumentContentChangeEvent[];\n  public currentContentChanges: vscode.TextDocumentContentChangeEvent[];\n\n  private nextStepStartPosition: Position | undefined;\n\n  private readonly undoStack: UndoStack;\n\n  private readonly changeList: ChangeList;\n\n  /**\n   * The state of the document the last time HistoryTracker.addChange() or HistoryTracker.ignoreChange() was called.\n   * This is used to avoid retrieiving the document text and doing a full diff when it isn't necessary.\n   */\n  private previousDocumentState: {\n    text: string;\n    versionNumber: number;\n  };\n\n  private readonly vimState: VimState;\n\n  constructor(vimState: VimState) {\n    this.vimState = vimState;\n    this.undoStack = new UndoStack();\n    this.changeList = new ChangeList();\n    this.previousDocumentState = {\n      text: this.getDocumentText(),\n      versionNumber: this.getDocumentVersion(),\n    };\n    this.lastContentChanges = [];\n    this.currentContentChanges = [];\n  }\n\n  private getDocumentText(): string {\n    // vimState.editor can be undefined in some unit tests\n    return this.vimState.editor?.document.getText() ?? '';\n  }\n\n  private getDocumentVersion(): number {\n    // vimState.editor can be undefined in some unit tests\n    return this.vimState.editor?.document.version ?? -1;\n  }\n\n  /**\n   * Marks refer to relative locations in the document, rather than absolute ones.\n   *\n   * This big gnarly method updates our marks such that they continue to mark\n   * the same character when the user does a document edit that would move the\n   * text that was marked.\n   */\n  private updateAndReturnMarks(): IMark[] {\n    const previousMarks = this.getAllCurrentDocumentMarks();\n    const newMarks: IMark[] = [];\n\n    // clone old marks into new marks\n    for (const mark of previousMarks) {\n      newMarks.push({ ...mark });\n    }\n\n    for (const change of this.undoStack.getCurrentHistoryStep()?.changes ?? []) {\n      for (const newMark of newMarks) {\n        // Run through each character added/deleted, and see if it could have\n        // affected the position of this mark.\n\n        let pos = change.start;\n\n        // Pull mark back with deleted text\n        for (const ch of change.before.replace(/\\r/g, '')) {\n          if (pos.isBefore(newMark.position)) {\n            if (ch === '\\n') {\n              newMark.position = new Position(\n                Math.max(newMark.position.line - 1, 0),\n                newMark.position.character\n              );\n            } else if (pos.line === newMark.position.line) {\n              newMark.position = new Position(\n                newMark.position.line,\n                Math.max(newMark.position.character - 1, 0)\n              );\n            }\n          }\n\n          if (ch === '\\n') {\n            // The 99999 is a bit of a hack here. It's very difficult and\n            // completely unnecessary to get the correct position, so we\n            // just fake it.\n            pos = new Position(Math.max(pos.line - 1, 0), 99999);\n          } else {\n            pos = new Position(pos.line, Math.max(pos.character - 1, 0));\n          }\n        }\n\n        pos = change.start;\n\n        // Push mark forward with added text\n        for (const ch of change.after.replace(/\\r/g, '')) {\n          if (pos.isBeforeOrEqual(newMark.position)) {\n            if (ch === '\\n') {\n              newMark.position = new Position(\n                newMark.position.line + 1,\n                newMark.position.character\n              );\n            } else if (pos.line === newMark.position.line) {\n              newMark.position = new Position(\n                newMark.position.line,\n                newMark.position.character + 1\n              );\n            }\n          }\n\n          if (ch === '\\n') {\n            pos = new Position(pos.line + 1, 0);\n          } else {\n            pos = new Position(pos.line, pos.character + 1);\n          }\n        }\n      }\n    }\n\n    // Ensure the position of every mark is within the range of the document.\n\n    const docEnd = TextEditor.getDocumentEnd(this.vimState.document);\n    for (const mark of newMarks) {\n      if (mark.position.isAfter(docEnd)) {\n        mark.position = docEnd;\n      }\n    }\n\n    return newMarks;\n  }\n\n  /**\n   * @returns the shared static list if isFileMark is true, otherwise returns the currentHistoryStep.marks.\n   */\n  private getMarkList(isFileMark: boolean): IMark[] {\n    return isFileMark ? HistoryStep.globalMarks : this.undoStack.getCurrentMarkList();\n  }\n\n  /**\n   * @returns all local and global marks in this editor\n   */\n  private getAllCurrentDocumentMarks(): IMark[] {\n    const globalMarks = HistoryStep.globalMarks.filter(\n      (mark) => mark.document === vscode.window.activeTextEditor?.document\n    );\n    return [...this.getLocalMarks(), ...globalMarks];\n  }\n\n  /**\n   * Adds a mark.\n   */\n  public addMark(position: Position, markName: string): void {\n    // Sets previous context mark (adds current position to jump list).\n\n    if (markName === \"'\" || markName === '`') {\n      return globalState.jumpTracker.recordJump(Jump.fromStateNow(this.vimState));\n    }\n\n    const isUppercaseMark = markName.toUpperCase() === markName;\n    const newMark: IMark = {\n      position,\n      name: markName,\n      isUppercaseMark,\n      document: isUppercaseMark ? vscode.window.activeTextEditor?.document : undefined,\n    };\n    this.putMarkInList(newMark);\n  }\n\n  /**\n   * Puts the mark into either the global or local marks array depending on mark.isUppercaseMark.\n   */\n  private putMarkInList(mark: IMark): void {\n    const marks = this.getMarkList(mark.isUppercaseMark);\n    const previousIndex = marks.findIndex((existingMark) => existingMark.name === mark.name);\n    if (previousIndex !== -1) {\n      marks[previousIndex] = mark;\n    } else {\n      marks.push(mark);\n    }\n  }\n\n  /**\n   * Retrieves a mark from either the global or local array depending on mark.isUppercaseMark.\n   */\n  public getMark(name: string): IMark | undefined {\n    // First, handle \"special\" marks\n    let position: Position | undefined;\n    if (name === '<') {\n      const linewise = this.vimState.lastVisualSelection?.mode === Mode.VisualLine;\n      position = linewise\n        ? this.vimState.lastVisualSelection?.start.with({ character: 0 })\n        : this.vimState.lastVisualSelection?.start;\n    } else if (name === '>') {\n      const linewise = this.vimState.lastVisualSelection?.mode === Mode.VisualLine;\n      position = linewise\n        ? this.vimState.lastVisualSelection?.end.getLineEnd()\n        : this.vimState.lastVisualSelection?.end.getLeft();\n    } else if (name === '[') {\n      position = this.getLastChangeStartPosition();\n    } else if (name === ']') {\n      position = this.getLastChangeEndPosition();\n    } else if (name === '.') {\n      position = this.getLastHistoryStartPosition();\n    } else if (name === \"'\" || name === '`') {\n      position = globalState.jumpTracker.end?.position;\n    }\n    if (position) {\n      return {\n        name,\n        position,\n        isUppercaseMark: false,\n      };\n    }\n\n    const marks = this.getMarkList(name.toUpperCase() === name);\n    return marks.find((mark) => mark.name === name);\n  }\n\n  /**\n   * Removes all local marks.\n   */\n  public removeLocalMarks(): void {\n    this.undoStack.removeMarks();\n  }\n\n  /**\n   * Removes all marks matching from either the global or local array.\n   */\n  public removeMarks(markNames: string[]): void {\n    if (markNames.length === 0) {\n      return;\n    }\n\n    this.undoStack.removeMarks(markNames);\n\n    HistoryStep.globalMarks = HistoryStep.globalMarks.filter(\n      (mark) => mark.name === '' || !markNames.includes(mark.name)\n    );\n  }\n\n  /**\n   * Gets all local marks.  I.e., marks that are specific for the current\n   * editor.\n   */\n  public getLocalMarks(): IMark[] {\n    return [...this.undoStack.getCurrentMarkList()];\n  }\n\n  /**\n   * Gets all global marks.  I.e., marks that are shared among all editors.\n   */\n  public getGlobalMarks(): IMark[] {\n    return [...HistoryStep.globalMarks];\n  }\n\n  public getMarks(): IMark[] {\n    return [...this.getLocalMarks(), ...HistoryStep.globalMarks];\n  }\n\n  /**\n   * Adds an individual Change to the current Step.\n   *\n   * Determines what changed by diffing the document against what it used to look like.\n   */\n  public addChange(force: boolean = false): void {\n    if (this.getDocumentVersion() === this.previousDocumentState.versionNumber) {\n      return;\n    }\n\n    if (this.nextStepStartPosition === undefined) {\n      const cursor = this.vimState.cursorsInitialState[0];\n      this.nextStepStartPosition = earlierOf(cursor.start, cursor.stop);\n      logger.debug(`Set nextStepStartPosition to ${this.nextStepStartPosition}`);\n    }\n\n    if (\n      !force &&\n      (this.vimState.currentMode === Mode.Insert || this.vimState.currentMode === Mode.Replace)\n    ) {\n      // We can ignore changes while we're in insert/replace mode, since we can't interact with them (via undo, etc.) until we're back to normal mode\n      // This allows us to avoid a little bit of work per keystroke, but more importantly, it means we'll get bigger contiguous edit chunks to merge.\n      // This is particularly impactful when there are multiple cursors, which are otherwise difficult to optimize.\n      return;\n    }\n\n    const newText = this.getDocumentText();\n    if (newText === this.previousDocumentState.text) {\n      return;\n    }\n\n    // TODO: This is actually pretty stupid! Since we already have the cursorPosition,\n    // and most diffs are just +/- a few characters, we can just do a direct comparison rather\n    // than using jsdiff.\n\n    // The difficulty is with a few rare commands like :%s/one/two/g that make\n    // multiple changes in different places simultaneously. For those, we could require\n    // them to call addChange manually, I guess...\n\n    const diffs = diffEngine.diff_main(this.previousDocumentState.text, newText);\n    diffEngine.diff_cleanupEfficiency(diffs);\n\n    let currentPosition = new Position(0, 0);\n\n    for (const diff of diffs) {\n      const [whatHappened, text] = diff;\n      const added = whatHappened === DiffMatchPatch.DIFF_INSERT;\n      const removed = whatHappened === DiffMatchPatch.DIFF_DELETE;\n\n      if (added || removed) {\n        this.undoStack.pushChange(\n          added\n            ? DocumentChange.insert(currentPosition, text)\n            : DocumentChange.delete(currentPosition, text)\n        );\n      }\n\n      if (!removed) {\n        currentPosition = currentPosition.advancePositionByText(text);\n      }\n    }\n\n    this.previousDocumentState = {\n      text: newText,\n      versionNumber: this.getDocumentVersion(),\n    };\n  }\n\n  /**\n   * Tells the HistoryTracker that although the document has changed, we should simply\n   * ignore that change. Most often used when the change was itself triggered by\n   * the HistoryTracker.\n   */\n  public ignoreChange(): void {\n    this.previousDocumentState = {\n      text: this.getDocumentText(),\n      versionNumber: this.getDocumentVersion(),\n    };\n  }\n\n  /**\n   * Until we mark it as finished, the active Step will\n   * accrue multiple changes. This function will mark it as finished,\n   * and the next time we add a change, it'll be added to a new Step.\n   */\n  public finishCurrentStep(): void {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep && !currentHistoryStep.isFinished) {\n      currentHistoryStep.isFinished = true;\n      currentHistoryStep.timestamp = new Date();\n\n      currentHistoryStep.cursorStart ??= this.nextStepStartPosition;\n      this.nextStepStartPosition = undefined;\n\n      currentHistoryStep.merge(this.vimState.document);\n\n      currentHistoryStep.marks = this.updateAndReturnMarks();\n\n      const changes = currentHistoryStep.changes;\n      if (changes) {\n        const changePos = changes[0].after ? changes[0].afterRange.end.getLeft() : changes[0].start;\n        this.changeList.addChangePosition(changePos);\n      }\n\n      logger.debug(`Finished history step with ${changes.length} change(s)`);\n    }\n  }\n\n  /**\n   * Undo the current HistoryStep, if there is one\n   *\n   * @returns the new cursor positions, or undefined if there are no steps to undo\n   */\n  public async goBackHistoryStep(): Promise<Position | undefined> {\n    const step = this.undoStack.stepBackward();\n    if (step === undefined) {\n      return undefined;\n    }\n\n    for (const change of step.changes.slice(0).reverse()) {\n      await change.undo(this.vimState.editor);\n    }\n\n    this.ignoreChange();\n\n    // TODO: if there are more/fewer lines after undoing the change, it should say so\n    const changes = step.changes.length === 1 ? `1 change` : `${step.changes.length} changes`;\n    StatusBar.setText(\n      this.vimState,\n      `${changes}; before #${this.undoStack.getCurrentHistoryStepIndex() + 1}  ${step.howLongAgo()}`\n    );\n\n    return step.cursorStart;\n  }\n\n  /**\n   * Redo the next HistoryStep, if there is one\n   *\n   * @returns the new cursor positions, or undefined if there are no steps to redo\n   */\n  public async goForwardHistoryStep(): Promise<Position | undefined> {\n    const step = this.undoStack.stepForward();\n    if (step === undefined) {\n      return undefined;\n    }\n\n    // TODO: do these transformations in a batch\n    for (const change of step.changes) {\n      await change.do(this.vimState.editor);\n    }\n\n    this.ignoreChange();\n\n    const changes = step.changes.length === 1 ? `1 change` : `${step.changes.length} changes`;\n    StatusBar.setText(\n      this.vimState,\n      `${changes}; after #${this.undoStack.getCurrentHistoryStepIndex()}  ${step.howLongAgo()}`\n    );\n\n    return step.cursorStart;\n  }\n\n  /**\n   * Logic for command U.\n   *\n   * Performs an undo action for all changes which occurred on\n   * the same line as the most recent change.\n   * Returns undefined if there's no more steps back to go.\n   * Only acts upon consecutive changes on the most-recently-changed line.\n   * U itself is a change, so all the changes are reversed and added back\n   * to the history.\n   *\n   * This method contains a significant amount of extra logic to account for\n   * the difficult scenario where a newline is embedded in a change (ex: '\\nhello'), which\n   * is created by the 'o' command. Vim behavior for the 'U' command does\n   * not undo newlines, so the change text needs to be checked & trimmed.\n   * This worst-case scenario tends to offset line values and make it harder to\n   * determine the line of the change, so this behavior is also compensated.\n   */\n  public async goBackHistoryStepsOnLine(): Promise<Position | undefined> {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep === undefined) {\n      return undefined;\n    }\n\n    let done: boolean = false;\n    const changesToUndo: DocumentChange[] = [];\n\n    let lastChange = currentHistoryStep.changes[currentHistoryStep.changes.length - 1];\n    const undoLine = lastChange.afterRange.end.line;\n\n    for (let stepIdx = this.undoStack.getCurrentHistoryStepIndex(); stepIdx >= 0; stepIdx--) {\n      const step = this.undoStack.getHistoryStepAtIndex(stepIdx)!;\n      for (let change of [...step.changes].reverse()) {\n        /*\n         * This conditional accounts for the behavior where the change is a newline\n         * followed by text to undo. Note the line offset behavior that must be compensated.\n         */\n        const newlines = [...change.after.matchAll(/\\n/g)];\n        if (newlines.length > 0 && change.start.line + newlines.length === undoLine) {\n          // Modify & replace the change to avoid undoing the newline embedded in the change\n          change = DocumentChange.insert(\n            new Position(change.start.line + 1, 0),\n            change.after.slice(change.after.lastIndexOf('\\n'))\n          );\n          done = true;\n        } else if (newlines.length > 0 || change.start.line !== undoLine) {\n          done = true;\n          break;\n        }\n\n        changesToUndo.push(change);\n        lastChange = change;\n        if (done) {\n          break;\n        }\n      }\n      if (step.cameFromU) {\n        done = true;\n      }\n      if (done) {\n        break;\n      }\n    }\n\n    if (changesToUndo.length > 0) {\n      for (const change of changesToUndo) {\n        await change.undo(this.vimState.editor);\n      }\n\n      const newStep = new HistoryStep({\n        marks: this.undoStack.getCurrentMarkList(),\n        changes: changesToUndo.map((change) => change.reversed()).reverse(),\n        cameFromU: true,\n      });\n      this.nextStepStartPosition = lastChange.start;\n      this.undoStack.pushHistoryStep(newStep);\n\n      this.finishCurrentStep();\n    }\n\n    this.ignoreChange();\n\n    /*\n     * Unlike the goBackHistoryStep() function, this function does not trust the\n     * HistoryStep.cursorStart property. This can lead to invalid cursor position errors.\n     * Since this function reverses change-by-change, rather than step-by-step,\n     * the cursor position is based on the start of the last change that is undone.\n     */\n    return lastChange?.start;\n  }\n\n  /**\n   * Gets the ending cursor position of the last Change of the last Step.\n   *\n   * In practice, this sets the cursor position to the end of\n   * the most recent text change.\n   */\n  public getLastChangeEndPosition(): Position | undefined {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep === undefined) {\n      return undefined;\n    }\n\n    const lastChangeIndex = currentHistoryStep.changes.length;\n    if (lastChangeIndex === 0) {\n      return undefined;\n    }\n\n    const lastChange = currentHistoryStep.changes[lastChangeIndex - 1];\n    return lastChange.afterRange.end;\n  }\n\n  public getLastHistoryStartPosition(): Position | undefined {\n    return this.undoStack.getCurrentHistoryStep()?.cursorStart;\n  }\n\n  private getLastChangeStartPosition(): Position | undefined {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep === undefined) {\n      return undefined;\n    }\n\n    const changes = currentHistoryStep.changes;\n    if (changes.length === 0) {\n      return undefined;\n    }\n\n    return changes[changes.length - 1].start;\n  }\n\n  /**\n   * Logic for `g,` command\n   */\n  public nextChangeInChangeList(): Position | VimError {\n    return this.changeList.nextChangePosition();\n  }\n\n  /**\n   * Logic for `g;` command\n   */\n  public prevChangeInChangeList(): Position | VimError {\n    return this.changeList.prevChangePosition();\n  }\n\n  /**\n   * Handy for debugging the undo/redo stack. + means our current position, check means active.\n   */\n  public toString(): string {\n    let result = '';\n\n    for (let i = 0; i < this.undoStack.getStackDepth(); i++) {\n      const step = this.undoStack.getHistoryStepAtIndex(i)!;\n\n      result += step.changes\n        .map((x) => `${x.before.replace(/\\n/g, '\\\\n')} => ${x.after.replace(/\\n/g, '\\\\n')}`)\n        .join('');\n      if (i === this.undoStack.getCurrentHistoryStepIndex()) {\n        result += '+';\n      }\n      if (step.isFinished) {\n        result += '✓';\n      }\n      result += '| ';\n    }\n\n    return result;\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\n\nimport { VimState } from '../state/vimState';\n\n/**\n * Represents a Jump in the JumpTracker.\n * Includes information necessary to determine jump actions,\n * and to be able to open the related file.\n */\nexport class Jump {\n  public readonly document: vscode.TextDocument;\n  public readonly position: Position;\n\n  /**\n   *\n   * @param options\n   * @param options.editor - The editor associated with the jump.\n   * @param options.position - The line and column number information.\n   */\n  constructor({ document, position }: { document: vscode.TextDocument; position: Position }) {\n    this.document = document;\n    this.position = position;\n  }\n\n  public get fileName() {\n    return this.document.fileName;\n  }\n\n  /**\n   * Factory method for creating a Jump from a VimState's current cursor position.\n   * @param vimState - State that contains the fileName and position for the jump\n   */\n  public static fromStateNow(vimState: VimState) {\n    return new Jump({\n      document: vimState.document,\n      position: vimState.cursorStopPosition,\n    });\n  }\n\n  /**\n   * Factory method for creating a Jump from a VimState's cursor position,\n   * before any actions or commands were performed.\n   * @param vimState - State that contains the fileName and prior position for the jump\n   */\n  public static fromStateBefore(vimState: VimState) {\n    return new Jump({\n      document: vimState.document,\n      position: vimState.cursorsInitialState[0].stop,\n    });\n  }\n\n  /**\n   * Determine whether another jump matches the same file path, line number, and character column.\n   * @param other - Another Jump to compare against\n   */\n  public isSamePosition(other: Jump): boolean {\n    return this.fileName === other.fileName && this.position.isEqual(other.position);\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { FileCommand } from './../cmd_line/commands/file';\nimport { VimState } from '../state/vimState';\n\nimport { Jump } from './jump';\nimport { existsAsync } from 'platform/fs';\nimport { Position } from 'vscode';\n\nconst MAX_JUMPS = 100;\n\n/**\n * JumpTracker is a handrolled version of VSCode's TextEditorState\n * in relation to the 'workbench.action.navigateBack' command.\n */\nexport class JumpTracker {\n  private _jumps: Jump[] = [];\n  private _currentJumpNumber = 0;\n\n  /**\n   * When receiving vscode.window.onDidChangeActiveTextEditor messages,\n   * don't record the jump if we initiated the command.\n   *\n   * Either the jump was added, or it was traversing jump history\n   * and shouldn't count as a new jump.\n   */\n  public isJumpingThroughHistory = false;\n\n  /**\n   * All recorded jumps, in the order of occurrence.\n   */\n  public get jumps(): Jump[] {\n    return this._jumps;\n  }\n\n  /**\n   * Current position in the list of jumps.\n   * This will be past last index if not traveling through history.\n   */\n  public get currentJumpNumber(): number {\n    return this._currentJumpNumber;\n  }\n\n  /**\n   * Current jump in the list of jumps.\n   */\n  public get currentJump(): Jump {\n    return this._jumps[this._currentJumpNumber] || null;\n  }\n\n  /**\n   * Current jump in the list of jumps.\n   */\n  public get hasJumps(): boolean {\n    return this._jumps.length > 0;\n  }\n\n  /**\n   * Last jump in list of jumps.\n   */\n  public get end(): Jump | null {\n    return this._jumps[this._jumps.length - 1];\n  }\n\n  /**\n   * Record that a jump occurred.\n   *\n   * If the current position is back in history,\n   * jumps after this position will be removed.\n   *\n   * @param from - File/position jumped from\n   * @param to - File/position jumped to\n   */\n  public recordJump(from: Jump, to?: Jump) {\n    if (to && from.isSamePosition(to)) {\n      return;\n    }\n\n    this.pushJump(from, to);\n  }\n\n  /**\n   * Record that a jump occurred from one file to another.\n   * This is likely only needed on a handler for\n   * vscode.window.onDidChangeActiveTextEditor.\n   *\n   * File jumps have extra checks in place, keeping in mind\n   * whether this plugin initiated the jump, whether the new file is\n   * a legitimate file.\n   *\n   * @param from - File/position jumped from\n   * @param to - File/position jumped to\n   */\n  public handleFileJump(from: Jump | null, to: Jump) {\n    if (this.isJumpingThroughHistory) {\n      this.isJumpingThroughHistory = false;\n      return;\n    }\n\n    if (to.document.isClosed) {\n      // Wallaby.js seemed to be adding an extra file jump, named e.g. extension-output-#4\n      // It was marked closed when jumping to it. Hopefully we can rely on checking isClosed\n      // when extensions get all weird on us.\n      return;\n    }\n\n    this.pushJump(from, to);\n  }\n\n  private async performFileJump(jump: Jump, vimState: VimState): Promise<void> {\n    this.isJumpingThroughHistory = true;\n\n    if (jump.document) {\n      // Open jump file from stored editor\n      await vscode.window.showTextDocument(jump.document);\n    } else if (await existsAsync(jump.fileName)) {\n      // Open jump file from disk\n      await new FileCommand({\n        name: jump.fileName,\n        lineNumber: jump.position.line,\n        createFileIfNotExists: false,\n      }).execute(vimState);\n    } else {\n      // Get jump file from visible editors\n      const editor: vscode.TextEditor = vscode.window.visibleTextEditors.filter(\n        (e) => e.document.fileName === jump.fileName\n      )[0];\n\n      if (editor) {\n        await vscode.window.showTextDocument(editor.document, jump.position.character, false);\n      }\n    }\n  }\n\n  /**\n   * Jump forward, possibly resulting in a file jump\n   */\n  public async jumpForward(position: Position, vimState: VimState): Promise<void> {\n    await this.jumpThroughHistory(this.recordJumpForward.bind(this), position, vimState);\n  }\n\n  /**\n   * Jump back, possibly resulting in a file jump\n   */\n  public async jumpBack(position: Position, vimState: VimState): Promise<void> {\n    await this.jumpThroughHistory(this.recordJumpBack.bind(this), position, vimState);\n  }\n\n  private async jumpThroughHistory(\n    getJump: (j: Jump) => Jump,\n    position: Position,\n    vimState: VimState\n  ): Promise<void> {\n    let jump = new Jump({\n      document: vimState.document,\n      position,\n    });\n\n    const iterations = vimState.recordedState.count || 1;\n    for (let i = 0; i < iterations; i++) {\n      jump = getJump(Jump.fromStateNow(vimState));\n    }\n\n    if (!jump) {\n      return;\n    }\n\n    const jumpedFiles = jump.fileName !== vimState.document.fileName;\n\n    if (jumpedFiles) {\n      await this.performFileJump(jump, vimState);\n    } else {\n      vimState.cursorStopPosition = jump.position;\n    }\n  }\n\n  /**\n   * Get the previous jump in history.\n   * Continues further back if the current line is on the same line.\n   *\n   * @param from - File/position jumped from\n   */\n  public recordJumpBack(from: Jump): Jump {\n    if (!this.hasJumps) {\n      return from;\n    }\n\n    if (this._currentJumpNumber <= 0) {\n      return this._jumps[0];\n    }\n\n    const to: Jump = this._jumps[this._currentJumpNumber - 1];\n\n    if (this._currentJumpNumber === this._jumps.length) {\n      this.recordJump(from, to);\n      this._currentJumpNumber = this._currentJumpNumber - 2;\n    } else {\n      this._currentJumpNumber = this._currentJumpNumber - 1;\n    }\n\n    return to;\n  }\n\n  /**\n   * Get the next jump in history.\n   * Continues further ahead if the current line is on the same line.\n   *\n   * @param from - File/position jumped from\n   */\n  public recordJumpForward(from: Jump): Jump {\n    if (!this.hasJumps) {\n      return from;\n    }\n\n    if (this._currentJumpNumber >= this._jumps.length) {\n      return from;\n    }\n\n    this._currentJumpNumber = Math.min(this._currentJumpNumber + 1, this._jumps.length - 1);\n    return this._jumps[this._currentJumpNumber];\n  }\n\n  /**\n   * Update existing jumps when lines were added to a document.\n   *\n   * @param document - Document that was changed, typically a vscode.TextDocument.\n   * @param range - Location where the text was added.\n   * @param text - Text containing one or more newline characters.\n   */\n  public handleTextAdded(document: { fileName: string }, range: vscode.Range, text: string): void {\n    // Get distance from newlines in the text added.\n    // Unlike handleTextDeleted, the range parameter distance between start/end is generally zero,\n    // just showing where the text was added.\n    const distance = text.split('').filter((c) => c === '\\n').length;\n\n    this._jumps.forEach((jump, i) => {\n      const jumpIsAfterAddedText =\n        jump.fileName === document.fileName && jump.position.line > range.start.line;\n\n      if (jumpIsAfterAddedText) {\n        const newPosition = new Position(jump.position.line + distance, jump.position.character);\n\n        this.changePositionForJumpNumber(i, jump, newPosition);\n      }\n    });\n  }\n\n  /**\n   * Update existing jumps when lines were removed from a document.\n   *\n   * Vim doesn't actually remove deleted lines. Instead, it seems to shift line numbers down\n   * for any jumps after the deleted text, and preserves position for jumps on deleted lines or\n   * lines above the deleted lines. After lines are shifted, if there are multiple jumps on a line,\n   * the duplicates are removed, preserving the newest jumps (preserving latest column number).\n   *\n   * Lines are shifted based on number of lines deleted before the jump. So if e.g. the jump is on\n   * a middle line #6, where the jump above and below it were also deleted, the jump position would\n   * move down just one so it is now line #5, based on the line above it being deleted.\n   *\n   * @param document - Document that was changed, typically a vscode.TextDocument.\n   * @param range - Location where the text was removed.\n   */\n  public handleTextDeleted(document: { fileName: string }, range: vscode.Range): void {\n    // Note that this is like Array.slice, such that range.end.line is one line AFTER a deleted line,\n    // so distance is expected to be at least 1.\n    const distance = range.end.line - range.start.line;\n\n    for (let i = this._jumps.length - 1; i >= 0; i--) {\n      const jump = this._jumps[i];\n\n      if (jump.fileName !== document.fileName) {\n        continue;\n      }\n\n      const jumpIsAfterDeletedText = jump.position.line > range.start.line;\n\n      if (jumpIsAfterDeletedText) {\n        const newLineShiftedUp =\n          jump.position.line - Math.min(jump.position.line - range.start.line, distance);\n        const newPosition = new Position(newLineShiftedUp, jump.position.character);\n\n        this.changePositionForJumpNumber(i, jump, newPosition);\n      }\n    }\n\n    this.removeDuplicateJumps();\n  }\n\n  /**\n   * Clear existing jumps and reset jump position.\n   */\n  public clearJumps(): void {\n    this._jumps.splice(0, this._jumps.length);\n    this._currentJumpNumber = 0;\n  }\n\n  private pushJump(from: Jump | null, to?: Jump) {\n    if (from) {\n      this.clearJumpsOnSameLine(from);\n    }\n\n    if (from && (!to || !from.isSamePosition(to))) {\n      if (this._jumps.length === MAX_JUMPS) {\n        this._jumps.splice(0, 1);\n      }\n\n      this._jumps.push(from);\n    }\n\n    this._currentJumpNumber = this._jumps.length;\n  }\n\n  private changePositionForJumpNumber(index: number, jump: Jump, newPosition: Position) {\n    this._jumps.splice(\n      index,\n      1,\n      new Jump({\n        document: jump.document,\n        position: newPosition,\n      })\n    );\n  }\n\n  private clearJumpsOnSameLine(jump: Jump): void {\n    this._jumps = this._jumps.filter(\n      (j) => j === jump || !(j.fileName === jump.fileName && j.position.line === jump.position.line)\n    );\n  }\n\n  private removeDuplicateJumps() {\n    const linesSeenPerFile = {};\n    for (let i = this._jumps.length - 1; i >= 0; i--) {\n      const jump = this._jumps[i];\n\n      if (!linesSeenPerFile[jump.fileName]) {\n        linesSeenPerFile[jump.fileName] = [];\n      }\n\n      if (linesSeenPerFile[jump.fileName].includes(jump.position.line)) {\n        this._jumps.splice(i, 1);\n      } else {\n        linesSeenPerFile[jump.fileName].push(jump.position.line);\n      }\n    }\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\n\nexport enum Mode {\n  Normal,\n  Insert,\n  Visual,\n  VisualBlock,\n  VisualLine,\n  SearchInProgressMode,\n  CommandlineInProgress,\n  Replace,\n  EasyMotionMode,\n  EasyMotionInputMode,\n  SurroundInputMode,\n  OperatorPendingMode, // Pseudo-Mode, used only when remapping. DON'T SET TO THIS MODE\n  Disabled,\n}\n\nexport enum VSCodeVimCursorType {\n  Block,\n  Line,\n  LineThin,\n  Underline,\n  TextDecoration,\n  Native,\n  UnderlineThin,\n}\n\n/**\n * Is the given mode visual, visual line, or visual block?\n */\nexport function isVisualMode(mode: Mode): mode is Mode.Visual | Mode.VisualLine | Mode.VisualBlock {\n  return [Mode.Visual, Mode.VisualLine, Mode.VisualBlock].includes(mode);\n}\n\n/**\n * Is the given mode one where the cursor is on the status bar?\n * This means SearchInProgess and CommandlineInProgress modes.\n */\nexport function isStatusBarMode(mode: Mode): boolean {\n  return [Mode.SearchInProgressMode, Mode.CommandlineInProgress].includes(mode);\n}\n\nexport function getCursorStyle(cursorType: VSCodeVimCursorType) {\n  switch (cursorType) {\n    case VSCodeVimCursorType.Block:\n      return vscode.TextEditorCursorStyle.Block;\n    case VSCodeVimCursorType.Line:\n      return vscode.TextEditorCursorStyle.Line;\n    case VSCodeVimCursorType.LineThin:\n      return vscode.TextEditorCursorStyle.LineThin;\n    case VSCodeVimCursorType.Underline:\n      return vscode.TextEditorCursorStyle.Underline;\n    case VSCodeVimCursorType.UnderlineThin:\n      return vscode.TextEditorCursorStyle.UnderlineThin;\n    case VSCodeVimCursorType.TextDecoration:\n      return vscode.TextEditorCursorStyle.LineThin;\n    case VSCodeVimCursorType.Native:\n    default:\n      return vscode.TextEditorCursorStyle.Block;\n  }\n}\n\nexport function visualBlockGetTopLeftPosition(start: Position, stop: Position): Position {\n  return new Position(Math.min(start.line, stop.line), Math.min(start.character, stop.character));\n}\n\nexport function visualBlockGetBottomRightPosition(start: Position, stop: Position): Position {\n  return new Position(Math.max(start.line, stop.line), Math.max(start.character, stop.character));\n}\n","import * as vscode from 'vscode';\n\nimport { BaseAction, KeypressState, BaseCommand, getRelevantAction } from './../actions/base';\nimport { BaseMovement } from '../actions/baseMotion';\nimport {\n  CommandBackspaceInInsertMode,\n  CommandEscInsertMode,\n  CommandInsertInInsertMode,\n  CommandInsertPreviousText,\n  InsertCharAbove,\n  InsertCharBelow,\n} from './../actions/commands/insert';\nimport { Jump } from '../jumps/jump';\nimport { Logger } from '../util/logger';\nimport { Mode, VSCodeVimCursorType, isVisualMode, getCursorStyle, isStatusBarMode } from './mode';\nimport { PairMatcher } from './../common/matching/matcher';\nimport { laterOf } from './../common/motion/position';\nimport { Cursor } from '../common/motion/cursor';\nimport { IBaseAction, RecordedState } from './../state/recordedState';\nimport { Register, RegisterMode } from './../register/register';\nimport { Remappers } from '../configuration/remapper';\nimport { StatusBar } from '../statusBar';\nimport { TextEditor } from './../textEditor';\nimport { VimError, ForceStopRemappingError } from './../error';\nimport { VimState } from './../state/vimState';\nimport { VSCodeContext } from '../util/vscodeContext';\nimport { commandLine } from '../cmd_line/commandLine';\nimport { configuration } from '../configuration/configuration';\nimport { decoration } from '../configuration/decoration';\nimport { scrollView } from '../util/util';\nimport {\n  CommandQuitRecordMacro,\n  DocumentContentChangeAction,\n  ActionOverrideCmdD,\n  CommandNumber,\n} from './../actions/commands/actions';\nimport { isTextTransformation } from '../transformations/transformations';\nimport { executeTransformations, IModeHandler } from '../transformations/execute';\nimport { globalState } from '../state/globalState';\nimport { Notation } from '../configuration/notation';\nimport { EditorIdentity } from '../editorIdentity';\nimport { SpecialKeys } from '../util/specialKeys';\nimport { BaseOperator } from '../actions/operator';\nimport { SearchByNCharCommand } from '../actions/plugins/easymotion/easymotion.cmd';\nimport { Position } from 'vscode';\nimport { RemapState } from '../state/remapState';\nimport * as process from 'process';\nimport { EasyMotion } from '../actions/plugins/easymotion/easymotion';\n\ninterface IModeHandlerMap {\n  get(editorId: EditorIdentity): ModeHandler | undefined;\n}\n\n/**\n * ModeHandler is the extension's backbone. It listens to events and updates the VimState.\n * One of these exists for each editor - see ModeHandlerMap\n *\n * See:  https://github.com/VSCodeVim/Vim/blob/master/.github/CONTRIBUTING.md#the-vim-state-machine\n */\nexport class ModeHandler implements vscode.Disposable, IModeHandler {\n  public readonly vimState: VimState;\n  public readonly remapState: RemapState;\n\n  public focusChanged = false;\n\n  private readonly disposables: vscode.Disposable[] = [];\n  private readonly handlerMap: IModeHandlerMap;\n  private readonly remappers: Remappers;\n  private static readonly logger = Logger.get('ModeHandler');\n\n  // TODO: clarify the difference between ModeHandler.currentMode and VimState.currentMode\n  private _currentMode!: Mode;\n\n  get currentMode(): Mode {\n    return this._currentMode;\n  }\n\n  private async setCurrentMode(modeName: Mode): Promise<void> {\n    await this.vimState.setCurrentMode(modeName);\n    this._currentMode = modeName;\n  }\n\n  public static async create(\n    handlerMap: IModeHandlerMap,\n    textEditor = vscode.window.activeTextEditor!\n  ): Promise<ModeHandler> {\n    const modeHandler = new ModeHandler(handlerMap, textEditor);\n    await modeHandler.vimState.load();\n    await modeHandler.setCurrentMode(configuration.startInInsertMode ? Mode.Insert : Mode.Normal);\n    modeHandler.syncCursors();\n    return modeHandler;\n  }\n\n  private constructor(handlerMap: IModeHandlerMap, textEditor: vscode.TextEditor) {\n    this.handlerMap = handlerMap;\n    this.remappers = new Remappers();\n\n    this.vimState = new VimState(textEditor, new EasyMotion());\n    this.remapState = new RemapState();\n    this.disposables.push(this.vimState);\n  }\n\n  /**\n   * Updates VSCodeVim's internal representation of cursors to match VSCode's selections.\n   * This loses some information, so it should only be done when necessary.\n   */\n  public syncCursors() {\n    // TODO: getCursorsAfterSync() is basically this, but stupider\n    if (this.vimState.editor) {\n      const { selections } = this.vimState.editor;\n      if (\n        !this.vimState.cursorStartPosition.isEqual(selections[0].anchor) ||\n        !this.vimState.cursorStopPosition.isEqual(selections[0].active)\n      ) {\n        this.vimState.desiredColumn = selections[0].active.character;\n      }\n\n      this.vimState.cursors = selections.map(({ active, anchor }) =>\n        active.isBefore(anchor) ? new Cursor(anchor.getLeft(), active) : new Cursor(anchor, active)\n      );\n    }\n  }\n\n  /**\n   * This is easily the worst function in VSCodeVim.\n   *\n   * We need to know when VSCode has updated our selection, so that we can sync\n   * that internally. Unfortunately, VSCode has a habit of calling this\n   * function at weird times, or or with incomplete information, so we have to\n   * do a lot of voodoo to make sure we're updating the cursors correctly.\n   *\n   * Even worse, we don't even know how to test this stuff.\n   *\n   * Anyone who wants to change the behavior of this method should make sure\n   * all selection related test cases pass. Follow this spec\n   * https://gist.github.com/rebornix/d21d1cc060c009d4430d3904030bd4c1 to\n   * perform the manual testing. Besides this testing you should still test\n   * commands like 'editor.action.smartSelect.grow' and you should test moving\n   * continuously up/down or left/right with and without remapped movement keys\n   * because sometimes vscode lags behind and calls this function with information\n   * that is not up to date with our selections yet and we need to make sure we don't\n   * change our cursors to previous information (this usally is only an issue in visual\n   * mode because of our different ways of handling selections and in those cases\n   * updating our cursors with not up to date info might result in us changing our\n   * cursor start position).\n   */\n  public async handleSelectionChange(e: vscode.TextEditorSelectionChangeEvent): Promise<void> {\n    if (\n      vscode.window.activeTextEditor === undefined ||\n      e.textEditor.document !== vscode.window.activeTextEditor.document\n    ) {\n      // we don't care if there is no active editor\n      // or user selection changed in a paneled window (e.g debug console/terminal)\n      // This check is made before enqueuing this selection change, but sometimes\n      // between the enqueueing and the actual calling of this function the editor\n      // might close or change to other document\n      return;\n    }\n    const selection = e.selections[0];\n    ModeHandler.logger.debug(\n      `Selections: Handling Selection Change! Selection: ${selection.anchor.toString()}, ${\n        selection.active\n      }, SelectionsLength: ${e.selections.length}`\n    );\n\n    // If our previous cursors are not included on any of the current selections, then a snippet\n    // must have been inserted.\n    const isSnippetSelectionChange = () => {\n      return e.selections.every((s) => {\n        return this.vimState.cursors.every((c) => !s.contains(new vscode.Range(c.start, c.stop)));\n      });\n    };\n\n    if (\n      (e.selections.length !== this.vimState.cursors.length || this.vimState.isMultiCursor) &&\n      this.vimState.currentMode !== Mode.VisualBlock\n    ) {\n      const allowedModes = [Mode.Normal];\n      if (!isSnippetSelectionChange()) {\n        allowedModes.push(...[Mode.Insert, Mode.Replace]);\n      }\n      // Number of selections changed, make sure we know about all of them still\n      this.vimState.cursors = e.textEditor.selections.map(\n        (sel) =>\n          new Cursor(\n            // Adjust the cursor positions because cursors & selections don't match exactly\n            sel.anchor.isAfter(sel.active) ? sel.anchor.getLeft() : sel.anchor,\n            sel.active\n          )\n      );\n      if (\n        e.selections.some((s) => !s.anchor.isEqual(s.active)) &&\n        allowedModes.includes(this.vimState.currentMode)\n      ) {\n        // If we got a visual selection and we are on normal, insert or replace mode, enter visual mode.\n        // We shouldn't go to visual mode on any other mode, because the other visual modes are handled\n        // very differently than vscode so only our extension will create them. And the other modes\n        // like the plugin modes shouldn't be changed or else it might mess up the plugins actions.\n        await this.setCurrentMode(Mode.Visual);\n      }\n      return this.updateView({ drawSelection: false, revealRange: false });\n    }\n\n    /**\n     * We only trigger our view updating process if it's a mouse selection.\n     * Otherwise we only update our internal cursor positions accordingly.\n     */\n    if (e.kind !== vscode.TextEditorSelectionChangeKind.Mouse) {\n      if (selection) {\n        if (e.kind === vscode.TextEditorSelectionChangeKind.Command) {\n          // This 'Command' kind is triggered when using a command like 'editor.action.smartSelect.grow'\n          // but it is also triggered when we set the 'editor.selections' on 'updateView'.\n          const allowedModes = [Mode.Normal, Mode.Visual];\n          if (!isSnippetSelectionChange()) {\n            // if we just inserted a snippet then don't allow insert modes to go to visual mode\n            allowedModes.push(...[Mode.Insert, Mode.Replace]);\n          }\n          if (allowedModes.includes(this.vimState.currentMode)) {\n            // Since the selections weren't ignored then probably we got change of selection from\n            // a command, so we need to update our start and stop positions. This is where commands\n            // like 'editor.action.smartSelect.grow' are handled.\n            if (this.vimState.currentMode === Mode.Visual) {\n              ModeHandler.logger.debug('Selections: Updating Visual Selection!');\n              this.vimState.cursorStopPosition = selection.active;\n              this.vimState.cursorStartPosition = selection.anchor;\n              await this.updateView({ drawSelection: false, revealRange: false });\n              return;\n            } else if (!selection.active.isEqual(selection.anchor)) {\n              ModeHandler.logger.debug('Selections: Creating Visual Selection from command!');\n              this.vimState.cursorStopPosition = selection.active;\n              this.vimState.cursorStartPosition = selection.anchor;\n              await this.setCurrentMode(Mode.Visual);\n              await this.updateView({ drawSelection: false, revealRange: false });\n              return;\n            }\n          }\n        }\n        // Here we are on the selection changed of kind 'Keyboard' or 'undefined' which is triggered\n        // when pressing movement keys that are not caught on the 'type' override but also when using\n        // commands like 'cursorMove'.\n\n        if (isVisualMode(this.vimState.currentMode)) {\n          /**\n           * In Visual Mode, our `cursorPosition` and `cursorStartPosition` can not reflect `active`,\n           * `start`, `end` and `anchor` information in a selection.\n           * See `Fake block cursor with text decoration` section of `updateView` method.\n           * Besides this, sometimes on visual modes our start position is not the same has vscode\n           * anchor because we need to move vscode anchor one to the right of our start when our start\n           * is after our stop in order to include the start character on vscodes selection.\n           */\n          return;\n        }\n\n        const cursorEnd = laterOf(\n          this.vimState.cursorStartPosition,\n          this.vimState.cursorStopPosition\n        );\n        if (e.textEditor.document.validatePosition(cursorEnd).isBefore(cursorEnd)) {\n          // The document changed such that our cursor position is now out of bounds, possibly by\n          // another program. Let's just use VSCode's selection.\n          // TODO: if this is the case, but we're in visual mode, we never get here (because of branch above)\n        } else if (\n          e.kind === vscode.TextEditorSelectionChangeKind.Keyboard &&\n          this.vimState.cursorStopPosition.isEqual(this.vimState.cursorStartPosition) &&\n          this.vimState.cursorStopPosition.getRight().isLineEnd() &&\n          this.vimState.cursorStopPosition.getLineEnd().isEqual(selection.active)\n        ) {\n          // We get here when we use a 'cursorMove' command (that is considered a selection changed\n          // kind of 'Keyboard') that ends past the line break. But our cursors are already on last\n          // character which is what we want. Even though our cursors will be corrected again when\n          // checking if they are in bounds on 'runAction' there is no need to be changing them back\n          // and forth so we check for this situation here.\n          return;\n        }\n\n        // Here we allow other 'cursorMove' commands to update our cursors in case there is another\n        // extension making cursor changes that we need to catch.\n        //\n        // We still need to be careful with this because this here might be changing our cursors\n        // in ways we don't want to. So with future selection issues this is a good place to start\n        // looking.\n        ModeHandler.logger.debug(\n          `Selections: Changing Cursors from selection handler... ${selection.anchor.toString()}, ${\n            selection.active\n          }`\n        );\n        this.vimState.cursorStopPosition = selection.active;\n        this.vimState.cursorStartPosition = selection.anchor;\n        await this.updateView({ drawSelection: false, revealRange: false });\n      }\n      return;\n    }\n\n    if (isStatusBarMode(this.vimState.currentMode)) {\n      return;\n    }\n\n    let toDraw = false;\n\n    if (selection) {\n      let newPosition = selection.active;\n\n      // Only check on a click, not a full selection (to prevent clicking past EOL)\n      if (newPosition.character >= newPosition.getLineEnd().character && selection.isEmpty) {\n        if (this.vimState.currentMode !== Mode.Insert) {\n          this.vimState.lastClickWasPastEol = true;\n\n          // This prevents you from mouse clicking past the EOL\n          newPosition = newPosition.withColumn(Math.max(newPosition.getLineEnd().character - 1, 0));\n\n          // Switch back to normal mode since it was a click not a selection\n          await this.setCurrentMode(Mode.Normal);\n\n          toDraw = true;\n        }\n      } else if (selection.isEmpty) {\n        this.vimState.lastClickWasPastEol = false;\n      }\n\n      this.vimState.cursorStopPosition = newPosition;\n      this.vimState.cursorStartPosition = newPosition;\n      this.vimState.desiredColumn = newPosition.character;\n\n      // start visual mode?\n      if (\n        selection.anchor.line === selection.active.line &&\n        selection.anchor.character >= newPosition.getLineEnd().character - 1 &&\n        selection.active.character >= newPosition.getLineEnd().character - 1\n      ) {\n        // This prevents you from selecting EOL\n      } else if (!selection.anchor.isEqual(selection.active)) {\n        let selectionStart = new Position(selection.anchor.line, selection.anchor.character);\n\n        if (selectionStart.character > selectionStart.getLineEnd().character) {\n          selectionStart = new Position(selectionStart.line, selectionStart.getLineEnd().character);\n        }\n\n        this.vimState.cursorStartPosition = selectionStart;\n\n        if (selectionStart.isAfter(newPosition)) {\n          this.vimState.cursorStartPosition = this.vimState.cursorStartPosition.getLeft();\n        }\n\n        // If we prevented from clicking past eol but it is part of this selection, include the last char\n        if (this.vimState.lastClickWasPastEol) {\n          const newStart = new Position(selection.anchor.line, selection.anchor.character + 1);\n          this.vimState.editor.selection = new vscode.Selection(newStart, selection.end);\n          this.vimState.cursorStartPosition = selectionStart;\n          this.vimState.lastClickWasPastEol = false;\n        }\n\n        if (\n          configuration.mouseSelectionGoesIntoVisualMode &&\n          !isVisualMode(this.vimState.currentMode) &&\n          this.currentMode !== Mode.Insert\n        ) {\n          await this.setCurrentMode(Mode.Visual);\n\n          // double click mouse selection causes an extra character to be selected so take one less character\n        }\n      } else if (this.vimState.currentMode !== Mode.Insert) {\n        await this.setCurrentMode(Mode.Normal);\n      }\n\n      this.updateView({ drawSelection: toDraw, revealRange: false });\n    }\n  }\n\n  async handleMultipleKeyEvents(keys: string[]): Promise<void> {\n    for (const key of keys) {\n      await this.handleKeyEvent(key);\n    }\n  }\n\n  public async handleKeyEvent(key: string): Promise<void> {\n    const now = Number(new Date());\n    const printableKey = Notation.printableKey(key, configuration.leader);\n\n    // Check forceStopRemapping\n    if (this.remapState.forceStopRecursiveRemapping) {\n      return;\n    }\n\n    ModeHandler.logger.debug(`handling key=${printableKey}.`);\n\n    if (\n      (key === SpecialKeys.TimeoutFinished ||\n        this.vimState.recordedState.bufferedKeys.length > 0) &&\n      this.vimState.recordedState.bufferedKeysTimeoutObj\n    ) {\n      // Handle the bufferedKeys or append the new key to the previously bufferedKeys\n      clearTimeout(this.vimState.recordedState.bufferedKeysTimeoutObj);\n      this.vimState.recordedState.bufferedKeysTimeoutObj = undefined;\n      this.vimState.recordedState.commandList = [...this.vimState.recordedState.bufferedKeys];\n      this.vimState.recordedState.bufferedKeys = [];\n    }\n\n    // rewrite copy\n    if (configuration.overrideCopy) {\n      // The conditions when you trigger a \"copy\" rather than a ctrl-c are\n      // too sophisticated to be covered by the \"when\" condition in package.json\n      if (key === '<D-c>') {\n        key = '<copy>';\n      }\n\n      if (key === '<C-c>' && process.platform !== 'darwin') {\n        if (\n          !configuration.useCtrlKeys ||\n          this.vimState.currentMode === Mode.Visual ||\n          this.vimState.currentMode === Mode.VisualBlock ||\n          this.vimState.currentMode === Mode.VisualLine\n        ) {\n          key = '<copy>';\n        }\n      }\n    }\n\n    // <C-d> triggers \"add selection to next find match\" by default,\n    // unless users explicity make <C-d>: true\n    if (key === '<C-d>' && !(configuration.handleKeys['<C-d>'] === true)) {\n      key = '<D-d>';\n    }\n\n    this.vimState.cursorsInitialState = this.vimState.cursors;\n    this.vimState.recordedState.commandList.push(key);\n\n    const oldMode = this.vimState.currentMode;\n    const oldFullMode = this.vimState.currentModeIncludingPseudoModes;\n    const oldStatusBarText = StatusBar.getText();\n    const oldWaitingForAnotherActionKey = this.vimState.recordedState.waitingForAnotherActionKey;\n\n    let handledAsRemap = false;\n    let handledAsAction = false;\n    try {\n      // Handling special case for '0'. From Vim documentation (:help :map-modes)\n      // Special case: While typing a count for a command in Normal mode, mapping zero\n      // is disabled. This makes it possible to map zero without making it impossible\n      // to type a count with a zero.\n      const preventZeroRemap =\n        key === '0' &&\n        this.vimState.recordedState.actionsRun[\n          this.vimState.recordedState.actionsRun.length - 1\n        ] instanceof CommandNumber;\n\n      // Check for remapped keys if:\n      // 1. We are not currently performing a non-recursive remapping\n      // 2. We are not typing '0' after starting to type a count\n      // 3. We are not waiting for another action key\n      //    Example: jj should not remap the second 'j', if jj -> <Esc> in insert mode\n      //             0 should not be remapped if typed after another number, like 10\n      //             for actions with multiple keys like 'gg' or 'fx' the second character\n      //           shouldn't be mapped\n      if (\n        !this.remapState.isCurrentlyPerformingNonRecursiveRemapping &&\n        !preventZeroRemap &&\n        !this.vimState.recordedState.waitingForAnotherActionKey\n      ) {\n        handledAsRemap = await this.remappers.sendKey(\n          this.vimState.recordedState.commandList,\n          this\n        );\n      }\n\n      this.vimState.recordedState.allowPotentialRemapOnFirstKey = true;\n\n      if (!handledAsRemap) {\n        if (key === SpecialKeys.TimeoutFinished) {\n          // Remove the <TimeoutFinished> key and get the key before that. If the <TimeoutFinished>\n          // key was the last key, then 'key' will be undefined and won't be sent to handle action.\n          this.vimState.recordedState.commandList.pop();\n          key =\n            this.vimState.recordedState.commandList[\n              this.vimState.recordedState.commandList.length - 1\n            ];\n        }\n        if (key !== undefined) {\n          handledAsAction = await this.handleKeyAsAnAction(key);\n        }\n      }\n    } catch (e) {\n      this.vimState.selectionsChanged.ignoreIntermediateSelections = false;\n      if (e instanceof VimError) {\n        StatusBar.displayError(this.vimState, e);\n        this.vimState.recordedState = new RecordedState();\n        if (this.remapState.isCurrentlyPerformingRemapping) {\n          // If we are handling a remap and we got a VimError stop handling the remap\n          // and discard the rest of the keys. We throw an Exception here to stop any other\n          // remapping handling steps and go straight to the 'finally' step of the remapper.\n          throw ForceStopRemappingError.fromVimError(e);\n        }\n      } else if (e instanceof ForceStopRemappingError) {\n        // If this is a ForceStopRemappingError rethrow it until it gets to the remapper\n        throw e;\n      } else if (e instanceof Error) {\n        e.message = `Failed to handle key=${key}. ${e.message}`;\n        throw e;\n      } else {\n        throw new Error(`Failed to handle key=${key} due to an unknown error.`);\n      }\n    }\n\n    this.remapState.lastKeyPressedTimestamp = now;\n\n    StatusBar.updateShowCmd(this.vimState);\n\n    // We don't want to immediately erase any message that resulted from the action just performed\n    if (StatusBar.getText() === oldStatusBarText) {\n      // Clear the status bar of high priority messages if the mode has changed, the view has scrolled\n      // or it is recording a Macro\n      const forceClearStatusBar =\n        (this.vimState.currentMode !== oldMode && this.vimState.currentMode !== Mode.Normal) ||\n        this.vimState.macro !== undefined;\n      StatusBar.clear(this.vimState, forceClearStatusBar);\n    }\n\n    // We either already ran an action or we have a potential action to run but\n    // the key is already stored on 'actionKeys' in that case we don't need it\n    // anymore on commandList that is only used for the remapper and 'showCmd'\n    // and both had already been handled at this point.\n    // If we got here it means that there is no potential remap for the key\n    // either so we need to clear it from commandList so that it doesn't interfere\n    // with the next remapper check.\n    this.vimState.recordedState.resetCommandList();\n\n    ModeHandler.logger.debug(\n      `handleKeyEvent('${printableKey}') took ${Number(new Date()) - now}ms`\n    );\n\n    // If we are handling a remap and the last movement failed stop handling the remap\n    // and discard the rest of the keys. We throw an Exception here to stop any other\n    // remapping handling steps and go straight to the 'finally' step of the remapper.\n    if (this.remapState.isCurrentlyPerformingRemapping && this.vimState.lastMovementFailed) {\n      this.vimState.lastMovementFailed = false;\n      throw new ForceStopRemappingError('Last movement failed');\n    }\n\n    // Reset lastMovementFailed. Anyone who needed it has probably already handled it.\n    // And keeping it past this point would make any following remapping force stop.\n    this.vimState.lastMovementFailed = false;\n\n    if (!handledAsAction) {\n      // There was no action run yet but we still want to update the view to be able\n      // to show the potential remapping keys being pressed, the `\"` character when\n      // waiting on a register key or the `?` character and any following character\n      // when waiting on digraph keys. The 'oldWaitingForAnotherActionKey' is used\n      // to call the updateView after we are no longer waiting keys so that any\n      // existing overlapped key is removed.\n      if (\n        ((this.vimState.currentMode === Mode.Insert ||\n          this.vimState.currentMode === Mode.Replace) &&\n          (this.vimState.recordedState.bufferedKeys.length > 0 ||\n            this.vimState.recordedState.waitingForAnotherActionKey ||\n            this.vimState.recordedState.waitingForAnotherActionKey !==\n              oldWaitingForAnotherActionKey)) ||\n        this.vimState.currentModeIncludingPseudoModes !== oldFullMode\n      ) {\n        // TODO: this call to updateView is only used to update the virtualCharacter and halfBlock\n        // cursor decorations, if in the future we split up the updateView function there should\n        // be no need to call all of it.\n        await this.updateView({ drawSelection: false, revealRange: false });\n      }\n    }\n  }\n\n  private async handleKeyAsAnAction(key: string): Promise<boolean> {\n    if (vscode.window.activeTextEditor !== this.vimState.editor) {\n      ModeHandler.logger.warn('Current window is not active');\n      return false;\n    }\n\n    // Catch any text change not triggered by us (example: tab completion).\n    this.vimState.historyTracker.addChange();\n\n    const recordedState = this.vimState.recordedState;\n    recordedState.actionKeys.push(key);\n\n    const action = getRelevantAction(recordedState.actionKeys, this.vimState);\n    switch (action) {\n      case KeypressState.NoPossibleMatch:\n        if (this.vimState.currentMode === Mode.Insert) {\n          this.vimState.recordedState.actionKeys = [];\n        } else {\n          this.vimState.recordedState = new RecordedState();\n        }\n        // Since there is no possible action we are no longer waiting any action keys\n        this.vimState.recordedState.waitingForAnotherActionKey = false;\n\n        return false;\n      case KeypressState.WaitingOnKeys:\n        this.vimState.recordedState.waitingForAnotherActionKey = true;\n\n        return false;\n    }\n\n    if (\n      !this.remapState.remapUsedACharacter &&\n      this.remapState.isCurrentlyPerformingRecursiveRemapping\n    ) {\n      // Used a character inside a recursive remapping so we reset the mapDepth.\n      this.remapState.remapUsedACharacter = true;\n      this.remapState.mapDepth = 0;\n    }\n\n    // Since we got an action we are no longer waiting any action keys\n    this.vimState.recordedState.waitingForAnotherActionKey = false;\n\n    // Store action pressed keys for showCmd\n    recordedState.actionsRunPressedKeys.push(...recordedState.actionKeys);\n\n    let actionToRecord: BaseAction | undefined = action;\n    if (recordedState.actionsRun.length === 0) {\n      recordedState.actionsRun.push(action);\n    } else {\n      const lastAction = recordedState.actionsRun[recordedState.actionsRun.length - 1];\n\n      const actionCanBeMergedWithDocumentChange =\n        action instanceof CommandInsertInInsertMode ||\n        action instanceof CommandBackspaceInInsertMode ||\n        action instanceof CommandInsertPreviousText ||\n        action instanceof InsertCharAbove ||\n        action instanceof InsertCharBelow;\n\n      if (lastAction instanceof DocumentContentChangeAction) {\n        if (!(action instanceof CommandEscInsertMode)) {\n          // TODO: this includes things like <BS>, which it shouldn't\n          lastAction.keysPressed.push(key);\n        }\n\n        if (actionCanBeMergedWithDocumentChange) {\n          // delay the macro recording\n          actionToRecord = undefined;\n        } else {\n          // Push document content change to the stack\n          lastAction.addChanges(\n            this.vimState.historyTracker.currentContentChanges,\n            this.vimState.cursorStopPosition\n          );\n          this.vimState.historyTracker.currentContentChanges = [];\n          recordedState.actionsRun.push(action);\n        }\n      } else {\n        if (actionCanBeMergedWithDocumentChange) {\n          // This means we are already in Insert Mode but there is still not DocumentContentChangeAction in stack\n          this.vimState.historyTracker.currentContentChanges = [];\n          const newContentChange = new DocumentContentChangeAction(\n            this.vimState.cursorStopPosition\n          );\n          newContentChange.keysPressed.push(key);\n          recordedState.actionsRun.push(newContentChange);\n          actionToRecord = newContentChange;\n        } else {\n          recordedState.actionsRun.push(action);\n        }\n      }\n    }\n\n    if (\n      this.vimState.macro !== undefined &&\n      actionToRecord &&\n      !(actionToRecord instanceof CommandQuitRecordMacro)\n    ) {\n      this.vimState.macro.actionsRun.push(actionToRecord);\n    }\n\n    await this.runAction(recordedState, action);\n\n    if (this.vimState.currentMode === Mode.Insert) {\n      recordedState.isInsertion = true;\n    }\n\n    // Update view\n    await this.updateView();\n\n    if (action.isJump) {\n      globalState.jumpTracker.recordJump(\n        Jump.fromStateBefore(this.vimState),\n        Jump.fromStateNow(this.vimState)\n      );\n    }\n\n    return true;\n  }\n\n  private async runAction(recordedState: RecordedState, action: IBaseAction): Promise<void> {\n    this.vimState.selectionsChanged.ignoreIntermediateSelections = true;\n\n    // We handle the end of selections different to VSCode. In order for VSCode to select\n    // including the last character we will at the end of 'runAction' shift our stop position\n    // to the right. So here we shift it back by one so that our actions have our correct\n    // position instead of the position sent to VSCode.\n    if (this.vimState.currentMode === Mode.Visual) {\n      this.vimState.cursors = this.vimState.cursors.map((c) =>\n        c.start.isBefore(c.stop) ? c.withNewStop(c.stop.getLeftThroughLineBreaks(true)) : c\n      );\n    }\n\n    // Make sure all cursors are within the document's bounds before running any action\n    // It's not 100% clear to me that this is the correct place to do this, but it should solve a lot of issues\n    this.vimState.cursors = this.vimState.cursors.map(\n      (c) =>\n        new Cursor(\n          this.vimState.document.validatePosition(c.start),\n          this.vimState.document.validatePosition(c.stop)\n        )\n    );\n\n    let ranRepeatableAction = false;\n    let ranAction = false;\n\n    if (action instanceof BaseMovement) {\n      recordedState = await this.executeMovement(action);\n      ranAction = true;\n    } else if (action instanceof BaseCommand) {\n      await action.execCount(this.vimState.cursorStopPosition, this.vimState);\n\n      const transformer = this.vimState.recordedState.transformer;\n      await executeTransformations(this, transformer.transformations);\n\n      if (action.isCompleteAction) {\n        ranAction = true;\n      }\n\n      if (action.canBeRepeatedWithDot) {\n        ranRepeatableAction = true;\n      }\n    } else if (action instanceof BaseOperator) {\n      recordedState.operatorCount = recordedState.count;\n    } else {\n      throw new Error('Unknown action type');\n    }\n\n    // Update mode (note the ordering allows you to go into search mode,\n    // then return and have the motion immediately applied to an operator).\n    const prevMode = this.currentMode;\n    if (this.vimState.currentMode !== this.currentMode) {\n      await this.setCurrentMode(this.vimState.currentMode);\n\n      // We don't want to mark any searches as a repeatable action\n      if (\n        this.vimState.currentMode === Mode.Normal &&\n        prevMode !== Mode.SearchInProgressMode &&\n        prevMode !== Mode.EasyMotionInputMode &&\n        prevMode !== Mode.EasyMotionMode\n      ) {\n        ranRepeatableAction = true;\n      }\n    }\n\n    // If there's an operator pending and we have a motion or visual selection, run the operator\n    if (recordedState.getOperatorState(this.vimState.currentMode) === 'ready') {\n      const operator = this.vimState.recordedState.operator;\n      if (operator) {\n        await this.executeOperator();\n        this.vimState.recordedState.hasRunOperator = true;\n        ranRepeatableAction = operator.canBeRepeatedWithDot;\n        ranAction = true;\n      }\n    }\n\n    // And then we have to do it again because an operator could\n    // have changed it as well. (TODO: do you even decomposition bro)\n    if (this.vimState.currentMode !== this.currentMode) {\n      await this.setCurrentMode(this.vimState.currentMode);\n\n      if (this.vimState.currentMode === Mode.Normal) {\n        ranRepeatableAction = true;\n      }\n    }\n\n    ranRepeatableAction =\n      (ranRepeatableAction && this.vimState.currentMode === Mode.Normal) ||\n      this.createUndoPointForBrackets();\n\n    // Record down previous action and flush temporary state\n    if (ranRepeatableAction) {\n      globalState.previousFullAction = this.vimState.recordedState;\n\n      if (recordedState.isInsertion) {\n        Register.setReadonlyRegister('.', recordedState);\n      }\n    }\n\n    // Update desiredColumn\n    const preservesDesiredColumn =\n      action instanceof BaseOperator && !ranAction ? true : action.preservesDesiredColumn;\n    if (!preservesDesiredColumn) {\n      if (action instanceof BaseMovement) {\n        // We check !operator here because e.g. d$ should NOT set the desired column to EOL.\n        if (action.setsDesiredColumnToEOL && !recordedState.operator) {\n          this.vimState.desiredColumn = Number.POSITIVE_INFINITY;\n        } else {\n          this.vimState.desiredColumn = this.vimState.cursorStopPosition.character;\n        }\n      } else if (this.vimState.currentMode !== Mode.VisualBlock) {\n        // TODO: explain why not VisualBlock\n        this.vimState.desiredColumn = this.vimState.cursorStopPosition.character;\n      }\n    }\n\n    // Like previously stated we handle the end of selections different to VSCode. In order\n    // for VSCode to select including the last character we shift our stop position to the\n    // right now that all steps that need that position have already run. On the next action\n    // we will shift it back again on the start of 'runAction'.\n    if (this.vimState.currentMode === Mode.Visual) {\n      this.vimState.cursors = this.vimState.cursors.map((c) =>\n        c.start.isBeforeOrEqual(c.stop)\n          ? c.withNewStop(\n              c.stop.isLineEnd() ? c.stop.getRightThroughLineBreaks() : c.stop.getRight()\n            )\n          : c\n      );\n    }\n\n    // We've run a complete action sequence - wipe the slate clean with a new RecordedState\n    if (ranAction && this.vimState.currentMode === Mode.Normal) {\n      this.vimState.recordedState = new RecordedState();\n\n      // Return to insert mode after 1 command in this case for <C-o>\n      if (this.vimState.returnToInsertAfterCommand) {\n        if (this.vimState.actionCount > 0) {\n          await this.setCurrentMode(Mode.Insert);\n        } else {\n          this.vimState.actionCount++;\n        }\n      }\n    }\n\n    // track undo history\n    if (!this.focusChanged) {\n      // important to ensure that focus didn't change, otherwise\n      // we'll grab the text of the incorrect active window and assume the\n      // whole document changed!\n\n      this.vimState.historyTracker.addChange();\n    }\n\n    // Don't record an undo point for every action of a macro, only at the very end\n    if (\n      ranRepeatableAction &&\n      !this.vimState.isReplayingMacro &&\n      !this.remapState.isCurrentlyPerformingRemapping\n    ) {\n      this.vimState.historyTracker.finishCurrentStep();\n    }\n\n    recordedState.actionKeys = [];\n    this.vimState.currentRegisterMode = undefined;\n\n    // If we're in Normal mode, collapse each cursor down to one character\n    if (this.currentMode === Mode.Normal) {\n      this.vimState.cursors = this.vimState.cursors.map(\n        (cursor) => new Cursor(cursor.stop, cursor.stop)\n      );\n    }\n\n    // Ensure cursors are within bounds\n    if (\n      !this.vimState.document.isClosed &&\n      this.vimState.editor === vscode.window.activeTextEditor\n    ) {\n      const documentEndPosition = TextEditor.getDocumentEnd(this.vimState.document);\n      const documentLineCount = this.vimState.document.lineCount;\n\n      this.vimState.cursors = this.vimState.cursors.map((cursor: Cursor) => {\n        // adjust start/stop\n        if (cursor.start.line >= documentLineCount) {\n          cursor = cursor.withNewStart(documentEndPosition);\n        }\n        if (cursor.stop.line >= documentLineCount) {\n          cursor = cursor.withNewStop(documentEndPosition);\n        }\n\n        // adjust column\n        if (this.vimState.currentMode === Mode.Normal || isVisualMode(this.vimState.currentMode)) {\n          const currentLineLength = TextEditor.getLineLength(cursor.stop.line);\n          const currentStartLineLength = TextEditor.getLineLength(cursor.start.line);\n\n          // When in visual mode you can move the cursor past the last character in order\n          // to select that character. We use this offset to allow for that, otherwise\n          // we would consider the position invalid and change it to the left of the last\n          // character.\n          const offsetAllowed =\n            isVisualMode(this.vimState.currentMode) && currentLineLength > 0 ? 1 : 0;\n          if (cursor.start.character >= currentStartLineLength) {\n            cursor = cursor.withNewStart(\n              cursor.start.withColumn(Math.max(currentStartLineLength - 1, 0))\n            );\n          }\n\n          if (cursor.stop.character >= currentLineLength + offsetAllowed) {\n            cursor = cursor.withNewStop(cursor.stop.withColumn(Math.max(currentLineLength - 1, 0)));\n          }\n        }\n        return cursor;\n      });\n    }\n\n    if (isVisualMode(this.vimState.currentMode) && !this.vimState.isRunningDotCommand) {\n      // Store selection for commands like gv\n      this.vimState.lastVisualSelection = {\n        mode: this.vimState.currentMode,\n        start: this.vimState.cursorStartPosition,\n        end: this.vimState.cursorStopPosition,\n      };\n    }\n\n    this.vimState.selectionsChanged.ignoreIntermediateSelections = false;\n  }\n\n  private async executeMovement(movement: BaseMovement): Promise<RecordedState> {\n    this.vimState.lastMovementFailed = false;\n    const recordedState = this.vimState.recordedState;\n    const cursorsToRemove: number[] = [];\n\n    for (let i = 0; i < this.vimState.cursors.length; i++) {\n      /**\n       * Essentially what we're doing here is pretending like the\n       * current VimState only has one cursor (the cursor that we just\n       * iterated to).\n       *\n       * We set the cursor position to be equal to the iterated one,\n       * and then set it back immediately after we're done.\n       *\n       * The slightly more complicated logic here allows us to write\n       * Action definitions without having to think about multiple\n       * cursors in almost all cases.\n       */\n      const oldCursorPositionStart = this.vimState.cursorStartPosition;\n      const oldCursorPositionStop = this.vimState.cursorStopPosition;\n      movement.multicursorIndex = i;\n\n      this.vimState.cursorStartPosition = this.vimState.cursors[i].start;\n      const cursorPosition = this.vimState.cursors[i].stop;\n      this.vimState.cursorStopPosition = cursorPosition;\n\n      const result = await movement.execActionWithCount(\n        cursorPosition,\n        this.vimState,\n        recordedState.count\n      );\n\n      // We also need to update the specific cursor, in case the cursor position was modified inside\n      // the handling functions (e.g. 'it')\n      this.vimState.cursors[i] = new Cursor(\n        this.vimState.cursorStartPosition,\n        this.vimState.cursorStopPosition\n      );\n\n      this.vimState.cursorStartPosition = oldCursorPositionStart;\n      this.vimState.cursorStopPosition = oldCursorPositionStop;\n\n      if (result instanceof Position) {\n        this.vimState.cursors[i] = this.vimState.cursors[i].withNewStop(result);\n\n        if (!isVisualMode(this.currentMode) && !this.vimState.recordedState.operator) {\n          this.vimState.cursors[i] = this.vimState.cursors[i].withNewStart(result);\n        }\n      } else {\n        if (result.failed) {\n          this.vimState.recordedState = new RecordedState();\n          this.vimState.lastMovementFailed = true;\n        }\n\n        if (result.removed) {\n          cursorsToRemove.push(i);\n        } else {\n          this.vimState.cursors[i] = new Cursor(result.start, result.stop);\n        }\n      }\n    }\n\n    if (cursorsToRemove.length > 0) {\n      // Remove the cursors that no longer exist. Remove from the end to the start\n      // so that the index values don't change.\n      for (let i = cursorsToRemove.length - 1; i >= 0; i--) {\n        const idx = cursorsToRemove[i];\n        if (idx !== 0) {\n          // We should never remove the main selection! This shouldn't happen, but just\n          // in case it does, lets protect against it. Remember kids, always use protection!\n          this.vimState.cursors.splice(idx, 1);\n        }\n      }\n    }\n\n    this.vimState.recordedState.count = 0;\n\n    // Keep the cursor within bounds\n    if (this.vimState.currentMode !== Mode.Normal || recordedState.operator) {\n      const stop = this.vimState.cursorStopPosition;\n\n      // Vim does this weird thing where it allows you to select and delete\n      // the newline character, which it places 1 past the last character\n      // in the line. This is why we use > instead of >=.\n\n      if (stop.character > TextEditor.getLineLength(stop.line)) {\n        this.vimState.cursorStopPosition = stop.getLineEnd();\n      }\n    }\n\n    return recordedState;\n  }\n\n  private async executeOperator(): Promise<void> {\n    const recordedState = this.vimState.recordedState;\n    const operator = recordedState.operator!;\n\n    // TODO - if actions were more pure, this would be unnecessary.\n    const startingMode = this.vimState.currentMode;\n    const startingRegisterMode = this.vimState.currentRegisterMode;\n\n    const resultingCursors: Cursor[] = [];\n    for (let [i, { start, stop }] of this.vimState.cursors.entries()) {\n      operator.multicursorIndex = i;\n\n      if (start.isAfter(stop)) {\n        [start, stop] = [stop, start];\n      }\n\n      if (!isVisualMode(startingMode) && startingRegisterMode !== RegisterMode.LineWise) {\n        stop = stop.getLeftThroughLineBreaks(true);\n      }\n\n      if (this.currentMode === Mode.VisualLine) {\n        start = start.getLineBegin();\n        stop = stop.getLineEnd();\n\n        this.vimState.currentRegisterMode = RegisterMode.LineWise;\n      }\n\n      await this.vimState.setCurrentMode(startingMode);\n\n      // We run the repeat version of an operator if the last 2 operators are the same.\n      if (\n        recordedState.operators.length > 1 &&\n        recordedState.operators.reverse()[0].constructor ===\n          recordedState.operators.reverse()[1].constructor\n      ) {\n        await operator.runRepeat(this.vimState, start, recordedState.count);\n      } else {\n        await operator.run(this.vimState, start, stop);\n      }\n\n      for (const transformation of this.vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = operator.multicursorIndex;\n        }\n      }\n\n      const resultingCursor = new Cursor(\n        this.vimState.cursorStartPosition,\n        this.vimState.cursorStopPosition\n      );\n\n      resultingCursors.push(resultingCursor);\n    }\n\n    if (this.vimState.recordedState.transformer.transformations.length > 0) {\n      const transformer = this.vimState.recordedState.transformer;\n      await executeTransformations(this, transformer.transformations);\n    } else {\n      // Keep track of all cursors (in the case of multi-cursor).\n      this.vimState.cursors = resultingCursors;\n    }\n  }\n\n  public async rerunRecordedState(recordedState: RecordedState): Promise<void> {\n    const actions = [...recordedState.actionsRun];\n\n    this.vimState.isRunningDotCommand = true;\n\n    // If a previous visual selection exists, store it for use in replay of some commands\n    if (this.vimState.lastVisualSelection) {\n      this.vimState.dotCommandPreviousVisualSelection = new vscode.Selection(\n        this.vimState.lastVisualSelection.start,\n        this.vimState.lastVisualSelection.end\n      );\n    }\n\n    recordedState = new RecordedState();\n    this.vimState.recordedState = recordedState;\n\n    for (const [i, action] of actions.entries()) {\n      recordedState.actionsRun = actions.slice(0, i + 1);\n      await this.runAction(recordedState, action);\n\n      if (this.vimState.lastMovementFailed) {\n        // TODO: Shouldn't this be `break`? Can't this leave us in a very bad state?\n        return;\n      }\n\n      await this.updateView();\n    }\n    recordedState.actionsRun = actions;\n    this.vimState.isRunningDotCommand = false;\n  }\n\n  public async runMacro(recordedMacro: RecordedState): Promise<void> {\n    let recordedState = new RecordedState();\n    this.vimState.recordedState = recordedState;\n    this.vimState.isRunningDotCommand = true;\n\n    for (const action of recordedMacro.actionsRun) {\n      const originalLocation = Jump.fromStateNow(this.vimState);\n\n      this.vimState.cursorsInitialState = this.vimState.cursors;\n\n      recordedState.actionsRun.push(action);\n\n      await this.runAction(recordedState, action);\n\n      // We just finished a full action; let's clear out our current state.\n      if (this.vimState.recordedState.actionsRun.length === 0) {\n        recordedState = new RecordedState();\n        this.vimState.recordedState = recordedState;\n      }\n\n      if (this.vimState.lastMovementFailed) {\n        break;\n      }\n\n      await this.updateView();\n\n      if (action.isJump) {\n        globalState.jumpTracker.recordJump(originalLocation, Jump.fromStateNow(this.vimState));\n      }\n    }\n\n    this.vimState.isRunningDotCommand = false;\n    this.vimState.cursorsInitialState = this.vimState.cursors;\n  }\n\n  public updateSearchHighlights(showHighlights: boolean) {\n    let searchRanges: vscode.Range[] = [];\n    if (showHighlights) {\n      searchRanges = globalState.searchState?.getMatchRanges(this.vimState.editor) ?? [];\n    }\n    this.vimState.editor.setDecorations(decoration.searchHighlight, searchRanges);\n  }\n\n  public async updateView(\n    args: { drawSelection: boolean; revealRange: boolean } = {\n      drawSelection: true,\n      revealRange: true,\n    }\n  ): Promise<void> {\n    // Draw selection (or cursor)\n    if (args.drawSelection) {\n      let selectionMode: Mode = this.vimState.currentMode;\n      if (this.vimState.currentMode === Mode.SearchInProgressMode) {\n        selectionMode = globalState.searchState?.previousMode ?? Mode.Normal;\n      } else if (this.vimState.currentMode === Mode.CommandlineInProgress) {\n        selectionMode = commandLine.previousMode;\n      } else if (this.vimState.currentMode === Mode.SurroundInputMode) {\n        selectionMode = this.vimState.surround!.previousMode;\n      }\n\n      let selections = [] as vscode.Selection[];\n      for (const cursor of this.vimState.cursors) {\n        let { start, stop } = cursor;\n        switch (selectionMode) {\n          case Mode.Visual:\n            /**\n             * Always select the letter that we started visual mode on, no matter\n             * if we are in front or behind it. Imagine that we started visual mode\n             * with some text like this:\n             *\n             *   abc|def\n             *\n             * (The | represents the cursor.) If we now press w, we'll select def,\n             * but if we hit b we expect to select abcd, so we need to getRight() on the\n             * start of the selection when it precedes where we started visual mode.\n             */\n            if (start.isAfterOrEqual(stop)) {\n              start = start.getRight();\n            }\n\n            selections.push(new vscode.Selection(start, stop));\n            break;\n\n          case Mode.VisualLine:\n            if (start.isBeforeOrEqual(stop)) {\n              selections.push(new vscode.Selection(start.getLineBegin(), stop.getLineEnd()));\n            } else {\n              selections.push(new vscode.Selection(start.getLineEnd(), stop.getLineBegin()));\n            }\n            break;\n\n          case Mode.VisualBlock:\n            for (const line of TextEditor.iterateLinesInBlock(this.vimState, cursor)) {\n              selections.push(new vscode.Selection(line.start, line.end));\n            }\n            break;\n\n          default:\n            // Note that this collapses the selection onto one position\n            selections.push(new vscode.Selection(stop, stop));\n            break;\n        }\n      }\n\n      /**\n       * Combine instersected selections - When we have multiple cursors\n       * sometimes those cursors selections intersect and combine, we need\n       * to check that here so that we know if our currents cursors will\n       * trigger a selectionChangeEvent or not. If we didn't check for this\n       * vscode might already have the resulting combined selection selected\n       * but since that wouldn't be the same as our selections we would think\n       * there would be a selectionChangeEvent when there wouldn't be any.\n       */\n      const getSelectionsCombined = (sel: vscode.Selection[]) => {\n        const combinedSelections: vscode.Selection[] = [];\n        sel.forEach((s, i) => {\n          if (i > 0) {\n            const previousSelection = combinedSelections[combinedSelections.length - 1];\n            const overlap = s.intersection(previousSelection);\n            if (overlap) {\n              // If anchor is after active we have a backwards selection and in that case we want\n              // the anchor that is lower and/or to the right and the active that is up and/or to\n              // the left. Otherwise we want the anchor that is upper and/or to the left and the\n              // active that is lower and/or to the right.\n\n              let anchor: Position;\n              let active: Position;\n              if (s.anchor.isBeforeOrEqual(s.active)) {\n                // Forwards Selection\n\n                // Get min anchor\n                if (s.anchor.isBeforeOrEqual(previousSelection.anchor)) {\n                  anchor = s.anchor;\n                } else {\n                  anchor = previousSelection.anchor;\n                }\n\n                // Get max active\n                if (s.active.isAfterOrEqual(previousSelection.active)) {\n                  active = s.active;\n                } else {\n                  active = previousSelection.active;\n                }\n              } else {\n                // Backwards Selection\n\n                // Get max anchor\n                if (s.anchor.isAfterOrEqual(previousSelection.anchor)) {\n                  anchor = s.anchor;\n                } else {\n                  anchor = previousSelection.anchor;\n                }\n\n                // Get min active\n                if (s.active.isBeforeOrEqual(previousSelection.active)) {\n                  active = s.active;\n                } else {\n                  active = previousSelection.active;\n                }\n              }\n              combinedSelections[combinedSelections.length - 1] = new vscode.Selection(\n                anchor,\n                active\n              );\n            } else {\n              combinedSelections.push(s);\n            }\n          } else {\n            combinedSelections.push(s);\n          }\n        });\n        return combinedSelections;\n      };\n      selections = getSelectionsCombined(selections);\n\n      // Check if the selection we are going to set is different than the current one.\n      // If they are the same vscode won't trigger a selectionChangeEvent so we don't\n      // have to add it to the ignore selections.\n      const willTriggerChange =\n        selections.length !== this.vimState.editor.selections.length ||\n        selections.some(\n          (s, i) =>\n            !s.anchor.isEqual(this.vimState.editor.selections[i].anchor) ||\n            !s.active.isEqual(this.vimState.editor.selections[i].active)\n        );\n\n      if (willTriggerChange) {\n        const selectionsHash = selections.reduce(\n          (hash, s) =>\n            hash +\n            `[${s.anchor.line}, ${s.anchor.character}; ${s.active.line}, ${s.active.character}]`,\n          ''\n        );\n        this.vimState.selectionsChanged.ourSelections.push(selectionsHash);\n        ModeHandler.logger.debug(\n          `Selections: Adding Selection Change to be Ignored! Hash: ${selectionsHash}, Selections: ${selections[0].anchor.toString()}, ${selections[0].active.toString()}`\n        );\n      }\n\n      this.vimState.editor.selections = selections;\n    }\n\n    // Scroll to position of cursor\n    if (\n      this.vimState.editor.visibleRanges.length > 0 &&\n      !this.vimState.postponedCodeViewChanges.some((change) => change.command === 'editorScroll')\n    ) {\n      /**\n       * This variable decides to which cursor we scroll the view.\n       * It is meant as a patch to #880.\n       * Extend this condition if it is the desired behaviour for other actions as well.\n       */\n      const isLastCursorTracked =\n        this.vimState.recordedState.actionsRun[\n          this.vimState.recordedState.actionsRun.length - 1\n        ] instanceof ActionOverrideCmdD;\n\n      let cursorToTrack: Cursor;\n      if (isLastCursorTracked) {\n        cursorToTrack = this.vimState.cursors[this.vimState.cursors.length - 1];\n      } else {\n        cursorToTrack = this.vimState.cursors[0];\n      }\n\n      const isCursorAboveRange = (visibleRange: vscode.Range): boolean =>\n        visibleRange.start.line - cursorToTrack.stop.line >= 15;\n      const isCursorBelowRange = (visibleRange: vscode.Range): boolean =>\n        cursorToTrack.stop.line - visibleRange.end.line >= 15;\n\n      const { visibleRanges } = this.vimState.editor;\n      const centerViewportAroundCursor =\n        visibleRanges.every(isCursorAboveRange) || visibleRanges.every(isCursorBelowRange);\n\n      const revealType = centerViewportAroundCursor\n        ? vscode.TextEditorRevealType.InCenter\n        : vscode.TextEditorRevealType.Default;\n\n      if (\n        this.vimState.currentMode === Mode.SearchInProgressMode &&\n        globalState.searchState &&\n        configuration.incsearch\n      ) {\n        const nextMatch = globalState.searchState.getNextSearchMatchPosition(\n          this.vimState.editor,\n          this.vimState.cursorStopPosition\n        );\n\n        if (nextMatch) {\n          this.vimState.editor.revealRange(\n            new vscode.Range(nextMatch.pos, nextMatch.pos),\n            revealType\n          );\n        } else if (this.vimState.firstVisibleLineBeforeSearch !== undefined) {\n          const offset =\n            this.vimState.editor.visibleRanges[0].start.line -\n            this.vimState.firstVisibleLineBeforeSearch;\n          scrollView(this.vimState, offset);\n        }\n      } else if (args.revealRange) {\n        if (\n          !isLastCursorTracked ||\n          this.vimState.cursorsInitialState.length !== this.vimState.cursors.length\n        ) {\n          /**\n           * We scroll the view if either:\n           * 1. the cursor we want to keep in view is the main one (this is the \"standard\"\n           * (before this commit) situation)\n           * 2. if we track the last cursor, but no additional cursor was created in this step\n           * (in the Cmd+D situation this means that no other matches were found)\n           */\n          this.vimState.editor.revealRange(\n            new vscode.Range(cursorToTrack.stop, cursorToTrack.stop),\n            revealType\n          );\n        }\n      }\n    }\n\n    // cursor style\n    let cursorStyle = configuration.getCursorStyleForMode(Mode[this.currentMode]);\n    if (!cursorStyle) {\n      const cursorType = getCursorType(\n        this.vimState,\n        this.vimState.currentModeIncludingPseudoModes\n      );\n      cursorStyle = getCursorStyle(cursorType);\n      if (\n        cursorType === VSCodeVimCursorType.Native &&\n        configuration.editorCursorStyle !== undefined\n      ) {\n        cursorStyle = configuration.editorCursorStyle;\n      }\n    }\n    this.vimState.editor.options.cursorStyle = cursorStyle;\n\n    // cursor block\n    const cursorRange: vscode.Range[] = [];\n    if (\n      getCursorType(this.vimState, this.currentMode) === VSCodeVimCursorType.TextDecoration &&\n      this.currentMode !== Mode.Insert\n    ) {\n      // Fake block cursor with text decoration. Unfortunately we can't have a cursor\n      // in the middle of a selection natively, which is what we need for Visual Mode.\n      if (this.currentMode === Mode.Visual) {\n        for (const { start: cursorStart, stop: cursorStop } of this.vimState.cursors) {\n          if (cursorStart.isBefore(cursorStop)) {\n            cursorRange.push(new vscode.Range(cursorStop.getLeft(), cursorStop));\n          } else {\n            cursorRange.push(new vscode.Range(cursorStop, cursorStop.getRight()));\n          }\n        }\n      } else {\n        for (const { stop: cursorStop } of this.vimState.cursors) {\n          cursorRange.push(new vscode.Range(cursorStop, cursorStop.getRight()));\n        }\n      }\n    }\n\n    this.vimState.editor.setDecorations(decoration.default, cursorRange);\n\n    // Insert Mode virtual characters: used to temporarily show the remapping pressed keys on\n    // insert mode, to show the `\"` character after pressing `<C-r>`, and to show `?` and the\n    // first character when inserting digraphs with `<C-k>`.\n    const iModeVirtualCharDecorationOptions: vscode.DecorationOptions[] = [];\n    if (this.vimState.currentMode === Mode.Insert || this.vimState.currentMode === Mode.Replace) {\n      let virtualKey: string | undefined;\n      if (this.vimState.recordedState.bufferedKeys.length > 0) {\n        virtualKey =\n          this.vimState.recordedState.bufferedKeys[\n            this.vimState.recordedState.bufferedKeys.length - 1\n          ];\n      } else if (this.vimState.recordedState.waitingForAnotherActionKey) {\n        virtualKey =\n          this.vimState.recordedState.actionKeys[this.vimState.recordedState.actionKeys.length - 1];\n        if (virtualKey === '<C-r>') {\n          virtualKey = '\"';\n        } else if (virtualKey === '<C-k>') {\n          virtualKey = '?';\n        }\n      }\n      // Don't show keys with `<` like `<C-x>` but show everything else\n      virtualKey = virtualKey && /<[^>]+>/.test(virtualKey) ? undefined : virtualKey;\n\n      if (virtualKey) {\n        // Normal Render Options with the key to overlap on the next character\n        const renderOptions: vscode.ThemableDecorationRenderOptions = {\n          before: {\n            contentText: virtualKey,\n          },\n        };\n\n        /**\n         * EOL Render Options:\n         * Some times when at the end of line the `currentColor` won't work, or it might be\n         * transparent, so we set the color to 'editor.foreground' when at EOL to avoid the\n         * virtualKey character not showing up.\n         */\n        const eolRenderOptions: vscode.ThemableDecorationRenderOptions = {\n          before: {\n            contentText: virtualKey,\n            color: new vscode.ThemeColor('editor.foreground'),\n          },\n        };\n\n        for (const { stop: cursorStop } of this.vimState.cursors) {\n          if (cursorStop.isLineEnd()) {\n            iModeVirtualCharDecorationOptions.push({\n              range: new vscode.Range(cursorStop, cursorStop.getLineEndIncludingEOL()),\n              renderOptions: eolRenderOptions,\n            });\n          } else {\n            iModeVirtualCharDecorationOptions.push({\n              range: new vscode.Range(cursorStop, cursorStop.getRightThroughLineBreaks(true)),\n              renderOptions,\n            });\n          }\n        }\n      }\n    }\n\n    this.vimState.editor.setDecorations(\n      decoration.insertModeVirtualCharacter,\n      iModeVirtualCharDecorationOptions\n    );\n\n    // OperatorPendingMode half block cursor\n    const opCursorDecorations: vscode.DecorationOptions[] = [];\n    const opCursorCharDecorations: vscode.DecorationOptions[] = [];\n    if (this.vimState.currentModeIncludingPseudoModes === Mode.OperatorPendingMode) {\n      for (const { stop: cursorStop } of this.vimState.cursors) {\n        let text = TextEditor.getCharAt(this.vimState.document, cursorStop);\n        // the ' ' (<space>) needs to be changed to '&nbsp;'\n        text = text === ' ' ? '\\u00a0' : text;\n        const renderOptions: vscode.ThemableDecorationRenderOptions = {\n          before: {\n            contentText: text,\n          },\n        };\n        opCursorDecorations.push({\n          range: new vscode.Range(cursorStop, cursorStop.getRight()),\n          renderOptions,\n        });\n        opCursorCharDecorations.push({\n          range: new vscode.Range(cursorStop, cursorStop.getRight()),\n          renderOptions,\n        });\n      }\n    }\n\n    this.vimState.editor.setDecorations(decoration.operatorPendingModeCursor, opCursorDecorations);\n    this.vimState.editor.setDecorations(\n      decoration.operatorPendingModeCursorChar,\n      opCursorCharDecorations\n    );\n\n    for (const markDecoration of decoration.allMarkDecorations()) {\n      this.vimState.editor.setDecorations(markDecoration, []);\n    }\n\n    if (configuration.showMarksInGutter) {\n      for (const mark of this.vimState.historyTracker.getMarks()) {\n        if (mark.isUppercaseMark && mark.document !== this.vimState.document) {\n          continue;\n        }\n\n        const markDecoration = decoration.getOrCreateMarkDecoration(mark.name);\n        const markLine = mark.position.getLineBegin();\n        const markRange = new vscode.Range(markLine, markLine);\n\n        this.vimState.editor.setDecorations(markDecoration, [markRange]);\n      }\n    }\n\n    const showHighlights =\n      (configuration.incsearch && this.currentMode === Mode.SearchInProgressMode) ||\n      (configuration.hlsearch && globalState.hl);\n    for (const editor of vscode.window.visibleTextEditors) {\n      this.handlerMap\n        .get(EditorIdentity.fromEditor(editor))\n        ?.updateSearchHighlights(showHighlights);\n    }\n\n    const easyMotionDimRanges =\n      this.currentMode === Mode.EasyMotionInputMode &&\n      configuration.easymotionDimBackground &&\n      this.vimState.easyMotion.searchAction instanceof SearchByNCharCommand\n        ? [\n            new vscode.Range(\n              TextEditor.getDocumentBegin(),\n              TextEditor.getDocumentEnd(this.vimState.document)\n            ),\n          ]\n        : [];\n    const easyMotionHighlightRanges =\n      this.currentMode === Mode.EasyMotionInputMode &&\n      this.vimState.easyMotion.searchAction instanceof SearchByNCharCommand\n        ? this.vimState.easyMotion.searchAction\n            .getMatches(this.vimState.cursorStopPosition, this.vimState)\n            .map((match) => match.toRange())\n        : [];\n    this.vimState.editor.setDecorations(decoration.easyMotionDimIncSearch, easyMotionDimRanges);\n    this.vimState.editor.setDecorations(decoration.easyMotionIncSearch, easyMotionHighlightRanges);\n\n    for (const viewChange of this.vimState.postponedCodeViewChanges) {\n      vscode.commands.executeCommand(viewChange.command, viewChange.args);\n    }\n    this.vimState.postponedCodeViewChanges = [];\n\n    if (this.currentMode === Mode.EasyMotionMode) {\n      // Update all EasyMotion decorations\n      this.vimState.easyMotion.updateDecorations(this.vimState.editor);\n    }\n\n    StatusBar.clear(this.vimState, false);\n\n    // NOTE: this is not being awaited to save the 15-20ms block - I think this is fine\n    VSCodeContext.set('vim.mode', Mode[this.vimState.currentMode]);\n\n    // Tell VSCode that the cursor position changed, so it updates its highlights for `editor.occurrencesHighlight`.\n    const range = new vscode.Range(\n      this.vimState.cursorStartPosition,\n      this.vimState.cursorStopPosition\n    );\n    if (!/\\s+/.test(this.vimState.document.getText(range))) {\n      vscode.commands.executeCommand('editor.action.wordHighlight.trigger');\n    }\n  }\n\n  // Return true if a new undo point should be created based on brackets and parentheses\n  private createUndoPointForBrackets(): boolean {\n    // }])> keys all start a new undo state when directly next to an {[(< opening character\n    const key =\n      this.vimState.recordedState.actionKeys[this.vimState.recordedState.actionKeys.length - 1];\n\n    if (key === undefined) {\n      return false;\n    }\n\n    if (this.vimState.currentMode === Mode.Insert) {\n      // Check if the keypress is a closing bracket to a corresponding opening bracket right next to it\n      let result = PairMatcher.nextPairedChar(\n        this.vimState.cursorStopPosition,\n        key,\n        this.vimState,\n        false\n      );\n      if (result !== undefined) {\n        if (this.vimState.cursorStopPosition.isEqual(result)) {\n          return true;\n        }\n      }\n\n      result = PairMatcher.nextPairedChar(\n        this.vimState.cursorStopPosition.getLeft(),\n        key,\n        this.vimState,\n        false\n      );\n      if (result !== undefined) {\n        if (this.vimState.cursorStopPosition.getLeft(2).isEqual(result)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  dispose() {\n    this.disposables.map((d) => d.dispose());\n  }\n}\n\nfunction getCursorType(vimState: VimState, mode: Mode): VSCodeVimCursorType {\n  switch (mode) {\n    case Mode.Normal:\n      return VSCodeVimCursorType.Block;\n    case Mode.Insert:\n      return VSCodeVimCursorType.Native;\n    case Mode.Visual:\n      return VSCodeVimCursorType.TextDecoration;\n    case Mode.VisualBlock:\n      return VSCodeVimCursorType.TextDecoration;\n    case Mode.VisualLine:\n      return VSCodeVimCursorType.TextDecoration;\n    case Mode.SearchInProgressMode:\n      return VSCodeVimCursorType.UnderlineThin;\n    case Mode.CommandlineInProgress:\n      return VSCodeVimCursorType.UnderlineThin;\n    case Mode.Replace:\n      return VSCodeVimCursorType.Underline;\n    case Mode.EasyMotionMode:\n      return VSCodeVimCursorType.Block;\n    case Mode.EasyMotionInputMode:\n      return VSCodeVimCursorType.Block;\n    case Mode.SurroundInputMode:\n      return getCursorType(vimState, vimState.surround!.previousMode);\n    case Mode.OperatorPendingMode:\n      return VSCodeVimCursorType.UnderlineThin;\n    case Mode.Disabled:\n    default:\n      return VSCodeVimCursorType.Line;\n  }\n}\n","import { ModeHandler } from './modeHandler';\nimport { EditorIdentity } from '../editorIdentity';\n\n/**\n * Stores one ModeHandler (and therefore VimState) per editor.\n */\nclass ModeHandlerMapImpl {\n  private modeHandlerMap = new Map<EditorIdentity, ModeHandler>();\n\n  public async getOrCreate(editorId: EditorIdentity): Promise<[ModeHandler, boolean]> {\n    let isNew = false;\n    let modeHandler: ModeHandler | undefined = this.get(editorId);\n\n    if (!modeHandler) {\n      isNew = true;\n      modeHandler = await ModeHandler.create(this);\n      this.modeHandlerMap.set(editorId, modeHandler);\n    }\n    return [modeHandler, isNew];\n  }\n\n  public get(editorId: EditorIdentity): ModeHandler | undefined {\n    for (const [key, value] of this.modeHandlerMap.entries()) {\n      if (key.isEqual(editorId)) {\n        return value;\n      }\n    }\n    return undefined;\n  }\n\n  public getKeys(): EditorIdentity[] {\n    return [...this.modeHandlerMap.keys()];\n  }\n\n  public getAll(): ModeHandler[] {\n    return [...this.modeHandlerMap.values()];\n  }\n\n  public delete(editorId: EditorIdentity) {\n    const modeHandler = this.modeHandlerMap.get(editorId);\n    if (modeHandler) {\n      modeHandler.dispose();\n      this.modeHandlerMap.delete(editorId);\n    }\n  }\n\n  public clear() {\n    for (const key of this.modeHandlerMap.keys()) {\n      this.delete(key);\n    }\n  }\n}\n\nexport const ModeHandlerMap = new ModeHandlerMapImpl();\n","export const SUPPORT_VIMRC = false;\nexport const SUPPORT_NVIM = false;\nexport const SUPPORT_IME_SWITCHER = false;\nexport const SUPPORT_READ_COMMAND = false;\n","import * as vscode from 'vscode';\n\nexport const constants = {\n  UV_FS_SYMLINK_DIR: 1,\n  UV_FS_SYMLINK_JUNCTION: 2,\n  O_RDONLY: 0,\n  O_WRONLY: 1,\n  O_RDWR: 2,\n  UV_DIRENT_UNKNOWN: 0,\n  UV_DIRENT_FILE: 1,\n  UV_DIRENT_DIR: 2,\n  UV_DIRENT_LINK: 3,\n  UV_DIRENT_FIFO: 4,\n  UV_DIRENT_SOCKET: 5,\n  UV_DIRENT_CHAR: 6,\n  UV_DIRENT_BLOCK: 7,\n  S_IFMT: 61440,\n  S_IFREG: 32768,\n  S_IFDIR: 16384,\n  S_IFCHR: 8192,\n  S_IFBLK: 24576,\n  S_IFIFO: 4096,\n  S_IFLNK: 40960,\n  S_IFSOCK: 49152,\n  O_CREAT: 512,\n  O_EXCL: 2048,\n  UV_FS_O_FILEMAP: 0,\n  O_NOCTTY: 131072,\n  O_TRUNC: 1024,\n  O_APPEND: 8,\n  O_DIRECTORY: 1048576,\n  O_NOFOLLOW: 256,\n  O_SYNC: 128,\n  O_DSYNC: 4194304,\n  O_SYMLINK: 2097152,\n  O_NONBLOCK: 4,\n  S_IRWXU: 448,\n  S_IRUSR: 256,\n  S_IWUSR: 128,\n  S_IXUSR: 64,\n  S_IRWXG: 56,\n  S_IRGRP: 32,\n  S_IWGRP: 16,\n  S_IXGRP: 8,\n  S_IRWXO: 7,\n  S_IROTH: 4,\n  S_IWOTH: 2,\n  S_IXOTH: 1,\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1,\n  UV_FS_COPYFILE_EXCL: 1,\n  COPYFILE_EXCL: 1,\n  UV_FS_COPYFILE_FICLONE: 2,\n  COPYFILE_FICLONE: 2,\n  UV_FS_COPYFILE_FICLONE_FORCE: 4,\n  COPYFILE_FICLONE_FORCE: 4,\n};\n\nexport async function doesFileExist(fileUri: vscode.Uri) {\n  try {\n    await vscode.workspace.fs.stat(fileUri);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function existsAsync(path: string): Promise<boolean> {\n  try {\n    await vscode.workspace.fs.stat(vscode.Uri.parse(path));\n    return true;\n  } catch (_e) {\n    return false;\n  }\n}\n\nexport async function unlink(path: string): Promise<void> {\n  await vscode.workspace.fs.delete(vscode.Uri.parse(path));\n}\n\nexport async function readFileAsync(path: string, encoding: string): Promise<string> {\n  const ret = await vscode.workspace.fs.readFile(vscode.Uri.parse(path));\n  return ret.toString();\n}\n\nexport async function mkdirAsync(path: string, options: any): Promise<void> {\n  return vscode.workspace.fs.createDirectory(vscode.Uri.parse(path));\n}\n\nexport async function writeFileAsync(\n  path: string,\n  content: string,\n  encoding: string\n): Promise<void> {\n  return vscode.workspace.fs.writeFile(vscode.Uri.parse(path), Buffer.from(content));\n}\n\nexport async function accessAsync(path: string, mode: number) {\n  // no op in nodeless\n}\n\nexport async function chmodAsync(path: string, mode: string | number) {\n  // no op in nodeless\n}\n\nexport function unlinkSync(path: string) {\n  // no op in nodeless\n}\n","import * as vscode from 'vscode';\nimport { ILogger } from '../common/logger';\n\nexport class HistoryBase {\n  private readonly context: vscode.ExtensionContext;\n  private readonly historyFileName: string;\n  private history: string[] = [];\n\n  get historyKey(): string {\n    return `vim.${this.historyFileName}`;\n  }\n\n  constructor(\n    context: vscode.ExtensionContext,\n    historyFileName: string,\n    extensionStoragePath: string,\n    logger: ILogger\n  ) {\n    this.context = context;\n    this.historyFileName = historyFileName;\n  }\n\n  public async add(value: string | undefined, history: number): Promise<void> {\n    if (!value || value.length === 0) {\n      return;\n    }\n\n    // remove duplicates\n    const index: number = this.history.indexOf(value);\n    if (index !== -1) {\n      this.history.splice(index, 1);\n    }\n\n    // append to the end\n    this.history.push(value);\n\n    // resize array if necessary\n    if (this.history.length > history) {\n      this.history = this.history.slice(this.history.length - history);\n    }\n\n    return this.save();\n  }\n\n  public get(history: number): string[] {\n    // resize array if necessary\n    if (this.history.length > history) {\n      this.history = this.history.slice(this.history.length - history);\n    }\n\n    return this.history;\n  }\n\n  public async clear() {\n    this.context.workspaceState.update(this.historyKey, undefined);\n    this.history = [];\n  }\n\n  public async load(): Promise<void> {\n    const data = this.context.workspaceState.get<string>(this.historyKey) || '';\n    if (data.length === 0) {\n      return;\n    }\n\n    const parsedData = JSON.parse(data);\n    if (!Array.isArray(parsedData)) {\n      throw Error('Unexpected format in history. Expected JSON.');\n    }\n    this.history = parsedData;\n  }\n\n  async save(): Promise<void> {\n    this.context.workspaceState.update(this.historyKey, JSON.stringify(this.history));\n  }\n}\n","import { IConfiguration } from '../../configuration/iconfiguration';\nimport { ILogger } from 'src/platform/common/logger';\n\n/**\n * Displays VSCode message to user\n */\nexport class VsCodeMessage implements ILogger {\n  actionMessages = ['Dismiss', 'Suppress Errors'];\n  private prefix: string;\n  configuration?: IConfiguration;\n\n  constructor(prefix: string) {\n    this.prefix = prefix;\n  }\n\n  error(errorMessage: string): void {\n    this.log({ level: 'error', message: errorMessage });\n  }\n\n  debug(debugMessage: string): void {\n    this.log({ level: 'debug', message: debugMessage });\n  }\n\n  warn(warnMessage: string): void {\n    this.log({ level: 'warn', message: warnMessage });\n  }\n\n  verbose(verboseMessage: string): void {\n    this.log({ level: 'verbose', message: verboseMessage });\n  }\n\n  private async log(info: { level: string; message: string }) {\n    if (this.configuration && this.configuration.debug.silent) {\n      return;\n    }\n    let showMessage: (message: string, ...items: string[]) => void;\n    switch (info.level) {\n      case 'error':\n        showMessage = console.error;\n        break;\n      case 'warn':\n        showMessage = console.warn;\n        break;\n      case 'info':\n      case 'verbose':\n      case 'debug':\n        showMessage = console.log;\n        break;\n      default:\n        throw Error(`Unsupported log level ${info.level}`);\n    }\n\n    showMessage(`${this.prefix}: ${info.message}`, ...this.actionMessages);\n  }\n\n  public configChanged(configuration: IConfiguration): void {\n    this.configuration = configuration;\n  }\n}\n\nexport class LoggerImpl {\n  static get(prefix: string): ILogger {\n    return new VsCodeMessage(prefix);\n  }\n}\n","import { Clipboard } from './../util/clipboard';\nimport {\n  ActionDeleteChar,\n  ActionDeleteCharWithDeleteKey,\n  ActionDeleteLastChar,\n  CommandRegister,\n  CommandYankFullLine,\n} from './../actions/commands/actions';\nimport { DeleteOperator, YankOperator } from './../actions/operator';\nimport { RecordedState } from './../state/recordedState';\nimport { VimState } from './../state/vimState';\nimport { readFileAsync, writeFileAsync } from 'platform/fs';\nimport { Globals } from '../globals';\n\n/**\n * This is included in the register file.\n * Whenever the format saved to disk changes, so should this.\n */\nconst REGISTER_FORMAT_VERSION = '1.0';\n\n/**\n * There are two different modes of copy/paste in Vim - copy by character\n * and copy by line. Copy by line typically happens in Visual Line mode, but\n * also shows up in some other actions that work over lines (most notably dd,\n * yy).\n */\nexport enum RegisterMode {\n  CharacterWise,\n  LineWise,\n  BlockWise,\n}\n\nexport type RegisterContent = string | RecordedState;\n\nexport interface IRegisterContent {\n  text: RegisterContent;\n  registerMode: RegisterMode;\n}\n\nexport class Register {\n  private static readonly specialRegisters: readonly string[] = [\n    '\"', // Unnamed (default)\n    '*', // Clipboard\n    '+', // Clipboard\n    '.', // Last inserted text\n    '-', // Last deleted text less than a line\n    '/', // Most recently executed search\n    ':', // Most recently executed command\n    '%', // Current file path (relative to workspace root)\n    '#', // Previous file path (relative to workspace root)\n    '_', // Black hole (always empty)\n  ];\n\n  private static registers: Map<string, IRegisterContent[]>;\n\n  /**\n   * Puts given content in the currently selected register, using the current RegisterMode.\n   *\n   * @param copyToUnnamed: If true, set the unnamed register (\") as well\n   */\n  public static put(\n    vimState: VimState,\n    content: RegisterContent,\n    multicursorIndex?: number,\n    copyToUnnamed?: boolean\n  ): void {\n    const register = vimState.recordedState.registerName;\n\n    if (!Register.isValidRegister(register)) {\n      throw new Error(`Invalid register ${register}`);\n    }\n\n    if (Register.isBlackHoleRegister(register) || Register.isReadOnlyRegister(register)) {\n      return;\n    }\n\n    if (Register.isValidUppercaseRegister(register)) {\n      Register.appendToRegister(vimState, register.toLowerCase(), content, multicursorIndex ?? 0);\n    } else {\n      Register.overwriteRegister(vimState, register, content, multicursorIndex ?? 0);\n    }\n\n    if (copyToUnnamed && register !== '\"') {\n      Register.registers.set('\"', Register.registers.get(register)!);\n    }\n  }\n\n  public static isValidRegister(register: string): boolean {\n    return (\n      Register.isValidLowercaseRegister(register) ||\n      Register.isValidUppercaseRegister(register) ||\n      /^[0-9]$/.test(register) ||\n      this.specialRegisters.includes(register)\n    );\n  }\n\n  public static isValidRegisterForMacro(register: string): boolean {\n    return /^[a-zA-Z0-9:]$/.test(register);\n  }\n\n  private static isBlackHoleRegister(registerName: string): boolean {\n    return registerName === '_';\n  }\n\n  private static isClipboardRegister(registerName: string): boolean {\n    return registerName === '*' || registerName === '+';\n  }\n\n  private static isReadOnlyRegister(registerName: string): boolean {\n    return ['.', '%', ':', '#', '/'].includes(registerName);\n  }\n\n  private static isValidLowercaseRegister(register: string): boolean {\n    return /^[a-z]$/.test(register);\n  }\n\n  public static isValidUppercaseRegister(register: string): boolean {\n    return /^[A-Z]$/.test(register);\n  }\n\n  /**\n   * Puts the content at the specified index of the multicursor Register.\n   * If multicursorIndex === 0, the register will be completely overwritten. Otherwise, just that index will be.\n   */\n  private static overwriteRegister(\n    vimState: VimState,\n    register: string,\n    content: RegisterContent,\n    multicursorIndex: number\n  ): void {\n    if (multicursorIndex === 0 || !Register.registers.has(register)) {\n      Register.registers.set(register, []);\n    }\n\n    Register.registers.get(register)![multicursorIndex] = {\n      registerMode: vimState.currentRegisterMode,\n      text: content,\n    };\n\n    if (\n      multicursorIndex === 0 &&\n      this.isClipboardRegister(register) &&\n      !(content instanceof RecordedState)\n    ) {\n      Clipboard.Copy(content);\n    }\n\n    this.processNumberedRegisters(vimState, content);\n  }\n\n  /**\n   * Appends the content at the specified index of the multicursor Register.\n   */\n  private static appendToRegister(\n    vimState: VimState,\n    register: string,\n    content: RegisterContent,\n    multicursorIndex: number\n  ): void {\n    if (!Register.registers.has(register)) {\n      Register.registers.set(register, []);\n    }\n\n    const contentByCursor = Register.registers.get(register)!;\n    const oldContent = contentByCursor[multicursorIndex];\n    if (oldContent === undefined) {\n      contentByCursor[multicursorIndex] = {\n        registerMode: vimState.currentRegisterMode,\n        text: content,\n      };\n    } else {\n      // Line-wise trumps other RegisterModes\n      const registerMode =\n        vimState.currentRegisterMode === RegisterMode.LineWise\n          ? RegisterMode.LineWise\n          : oldContent.registerMode;\n      let newText: RegisterContent;\n      if (oldContent.text instanceof RecordedState || content instanceof RecordedState) {\n        newText = oldContent.text;\n      } else {\n        newText = oldContent.text + (registerMode === RegisterMode.LineWise ? '\\n' : '') + content;\n      }\n      contentByCursor[multicursorIndex] = {\n        registerMode,\n        text: newText,\n      };\n    }\n\n    if (multicursorIndex === 0 && this.isClipboardRegister(register)) {\n      const newContent = contentByCursor[multicursorIndex].text;\n      if (!(newContent instanceof RecordedState)) {\n        Clipboard.Copy(newContent);\n      }\n    }\n  }\n\n  /** @deprecated Currently used only by tests */\n  public static putByKey(\n    register: string,\n    content: RegisterContent,\n    registerMode = RegisterMode.CharacterWise\n  ): void {\n    if (!Register.isValidRegister(register)) {\n      throw new Error(`Invalid register ${register}`);\n    }\n\n    if (Register.isClipboardRegister(register)) {\n      Clipboard.Copy(content.toString());\n    }\n\n    if (Register.isBlackHoleRegister(register) || Register.isReadOnlyRegister(register)) {\n      return;\n    }\n\n    Register.registers.set(register, [\n      {\n        text: content,\n        registerMode,\n      },\n    ]);\n  }\n\n  /**\n   * Updates a readonly register's content. This is the only way to do so.\n   */\n  public static setReadonlyRegister(\n    register: '.' | '%' | ':' | '#' | '/',\n    content: RegisterContent\n  ) {\n    Register.registers.set(register, [\n      {\n        text: content,\n        registerMode: RegisterMode.CharacterWise,\n      },\n    ]);\n  }\n\n  /**\n   * Handles special cases for Yank- and DeleteOperator.\n   */\n  private static processNumberedRegisters(vimState: VimState, content: RegisterContent): void {\n    // Find the BaseOperator of the current actions\n    const baseOperator = vimState.recordedState.operator || vimState.recordedState.command;\n\n    if (baseOperator instanceof YankOperator || baseOperator instanceof CommandYankFullLine) {\n      // 'yank' to 0 only if no register was specified\n      const registerCommand = vimState.recordedState.actionsRun.find((value) => {\n        return value instanceof CommandRegister;\n      });\n\n      if (!registerCommand) {\n        Register.registers.set('0', [\n          {\n            text: content,\n            registerMode: vimState.currentRegisterMode,\n          },\n        ]);\n      }\n    } else if (\n      (baseOperator instanceof DeleteOperator ||\n        baseOperator instanceof ActionDeleteChar ||\n        baseOperator instanceof ActionDeleteLastChar ||\n        baseOperator instanceof ActionDeleteCharWithDeleteKey) &&\n      !(vimState.macro !== undefined || vimState.isReplayingMacro)\n    ) {\n      if (\n        !content.toString().match(/\\n/g) &&\n        vimState.currentRegisterMode !== RegisterMode.LineWise\n      ) {\n        Register.registers.set('-', [\n          {\n            text: content,\n            registerMode: RegisterMode.CharacterWise,\n          },\n        ]);\n      } else {\n        // shift 'delete-history' register\n        for (let index = 9; index > 1; index--) {\n          const previous = Register.registers.get(String(index - 1));\n          if (previous) {\n            Register.registers.set(String(index), { ...previous });\n          }\n        }\n\n        // Paste last delete into register '1'\n        Register.registers.set('1', [\n          {\n            text: content,\n            registerMode: vimState.currentRegisterMode,\n          },\n        ]);\n      }\n    }\n  }\n\n  /**\n   * Gets content from a register. If no register is specified, uses `vimState.recordedState.registerName`.\n   */\n  public static async get(\n    register: string,\n    multicursorIndex = 0\n  ): Promise<IRegisterContent | undefined> {\n    if (!Register.isValidRegister(register)) {\n      throw new Error(`Invalid register ${register}`);\n    }\n\n    register = register.toLowerCase();\n\n    const contentByCursor = Register.registers.get(register);\n\n    if (Register.isClipboardRegister(register)) {\n      const clipboardContent = (await Clipboard.Paste()).replace(/\\r\\n/g, '\\n');\n      const currentRegisterContent = (contentByCursor?.[0]?.text as string)?.replace(/\\r\\n/g, '\\n');\n      if (currentRegisterContent !== clipboardContent) {\n        // System clipboard seems to have changed\n        const registerContent = {\n          text: clipboardContent,\n          registerMode: RegisterMode.CharacterWise,\n        };\n        Register.registers.set(register, [registerContent]);\n        return registerContent;\n      }\n    }\n\n    // Default to the first cursor.\n    if (contentByCursor?.[multicursorIndex] === undefined) {\n      // If multicursorIndex is too high, try the first cursor\n      multicursorIndex = 0;\n    }\n\n    return contentByCursor?.[multicursorIndex];\n  }\n\n  public static has(register: string): boolean {\n    return Register.registers.has(register);\n  }\n\n  public static getKeys(): string[] {\n    return [...Register.registers.keys()];\n  }\n\n  public static clearAllRegisters(): void {\n    Register.registers.clear();\n  }\n\n  public static async saveToDisk(supportNode: boolean): Promise<void> {\n    if (supportNode) {\n      const serializableRegisters = new Array<[string, IRegisterContent[]]>();\n      for (const [key, contentByCursor] of Register.registers) {\n        if (!contentByCursor.some((content) => content instanceof RecordedState)) {\n          serializableRegisters.push([key, contentByCursor]);\n        }\n      }\n      return import('path').then((path) => {\n        return writeFileAsync(\n          path.join(Globals.extensionStoragePath, '.registers'),\n          JSON.stringify({\n            version: REGISTER_FORMAT_VERSION,\n            registers: serializableRegisters,\n          }),\n          'utf8'\n        );\n      });\n    }\n  }\n\n  public static loadFromDisk(supportNode: boolean): void {\n    if (supportNode) {\n      Register.registers = new Map();\n      import('path').then((path) => {\n        readFileAsync(path.join(Globals.extensionStoragePath, '.registers'), 'utf8').then(\n          (savedRegisters) => {\n            const parsed = JSON.parse(savedRegisters);\n            if (parsed.version === REGISTER_FORMAT_VERSION) {\n              Register.registers = new Map(parsed.registers);\n            }\n          }\n        );\n      });\n    } else {\n      Register.registers = new Map();\n    }\n  }\n}\n","export class CompositionState {\n  isInComposition: boolean = false;\n  insertedText: boolean = false;\n  composingText: string = '';\n\n  reset() {\n    this.isInComposition = false;\n    this.insertedText = false;\n    this.composingText = '';\n  }\n}\n","import * as vscode from 'vscode';\nimport { JumpTracker } from '../jumps/jumpTracker';\nimport { Mode } from '../mode/mode';\nimport { RecordedState } from './../state/recordedState';\nimport { SearchHistory } from '../history/historyFile';\nimport { SearchState, SearchDirection } from './searchState';\nimport { SubstituteState } from './substituteState';\nimport { configuration } from '../configuration/configuration';\nimport { Position } from 'vscode';\n\n/**\n * State which stores global state (across editors)\n */\nclass GlobalState {\n  /**\n   * Previous searches performed\n   */\n  private _searchStatePrevious: SearchState[] = [];\n\n  /**\n   * Track jumps, and traverse jump history\n   */\n  public readonly jumpTracker: JumpTracker = new JumpTracker();\n\n  /**\n   * Tracks search history\n   */\n  private searchHistory!: SearchHistory;\n\n  /**\n   * The keystroke sequence that made up our last complete action (that can be\n   * repeated with '.').\n   */\n  public previousFullAction: RecordedState | undefined = undefined;\n\n  /**\n   * Last substitute state for running :s by itself\n   */\n  public substituteState: SubstituteState | undefined = undefined;\n\n  /**\n   * Last search state for running n and N commands\n   */\n  public searchState: SearchState | undefined = undefined;\n\n  /**\n   *  Index used for navigating search history with <up> and <down> when searching\n   */\n  public searchStateIndex: number = 0;\n\n  /**\n   * Used internally for nohl.\n   */\n  public hl = true;\n\n  public async load(context: vscode.ExtensionContext) {\n    this.searchHistory = new SearchHistory(context);\n    this.searchHistory\n      .get()\n      .forEach((val) =>\n        this.searchStatePrevious.push(\n          new SearchState(SearchDirection.Forward, new Position(0, 0), val, undefined, Mode.Normal)\n        )\n      );\n  }\n\n  /**\n   * Getters and setters for changing global state\n   */\n  public get searchStatePrevious(): SearchState[] {\n    return this._searchStatePrevious;\n  }\n\n  public set searchStatePrevious(states: SearchState[]) {\n    this._searchStatePrevious = this._searchStatePrevious.concat(states);\n  }\n\n  public async addSearchStateToHistory(searchState: SearchState) {\n    const prevSearchString =\n      this.searchStatePrevious.length === 0\n        ? undefined\n        : this.searchStatePrevious[this.searchStatePrevious.length - 1].searchString;\n    // Store this search if different than previous\n    if (searchState.searchString !== prevSearchString) {\n      this.searchStatePrevious.push(searchState);\n      if (this.searchHistory !== undefined) {\n        await this.searchHistory.add(searchState.searchString);\n      }\n    }\n\n    // Make sure search history does not exceed configuration option\n    if (this.searchStatePrevious.length > configuration.history) {\n      this.searchStatePrevious.splice(0, 1);\n    }\n\n    // Update the index to the end of the search history\n    this.searchStateIndex = this.searchStatePrevious.length - 1;\n  }\n\n  /**\n   * Shows the search history as a QuickPick (popup list)\n   *\n   * @returns The SearchState that was selected by the user, if there was one.\n   */\n  public async showSearchHistory(): Promise<SearchState | undefined> {\n    const items = this._searchStatePrevious\n      .slice()\n      .reverse()\n      .map((searchState) => {\n        return {\n          label: searchState.searchString,\n          searchState,\n        };\n      });\n\n    const item = await vscode.window.showQuickPick(items, {\n      placeHolder: 'Vim search history',\n      ignoreFocusOut: false,\n    });\n\n    return item ? item.searchState : undefined;\n  }\n}\n\nexport const globalState = new GlobalState();\n","import { configuration } from '../configuration/configuration';\nimport { Mode, isVisualMode } from '../mode/mode';\nimport { PositionDiff } from './../common/motion/position';\nimport { Transformer } from './../transformations/transformer';\nimport { SpecialKeys } from '../util/specialKeys';\nimport type { VimState } from './vimState';\nimport { Position } from 'vscode';\n\n/**\n * Much of Vim's power comes from the composition of individual actions.\n *\n * RecordedState holds the state associated with a sequence of actions,\n * generally beginning and ending in Normal mode.\n *\n * For example, each of these action sequences would be combined into a single RecordedState:\n *   - 5\"xyw      (yank 5 words into the 'x' register)\n *   - Axyz<Esc>  (append 'xyz' to end of line)\n *   - Vjj~       (reverse case of next 3 lines)\n *\n * The last action (for dot-repeating), macros, and a few other things are RecordedStates.\n */\nexport class RecordedState {\n  constructor() {\n    this.registerName = configuration.useSystemClipboard ? '*' : '\"';\n  }\n\n  /**\n   * The keys the user has pressed that have not caused an action to be executed\n   * yet and have not been stored on action keys. Used for command remapping.\n   */\n  public commandList: string[] = [];\n\n  /**\n   * String representation of the exact keys that the user entered.\n   */\n  public get commandString(): string {\n    let result = '';\n\n    if (this.actionsRun.length > 0) {\n      result = this.actionsRunPressedKeys.join('');\n    }\n    if (this.actionKeys.length > 0) {\n      // if there are any actionKeys waiting for other key append them\n      result += this.actionKeys.join('');\n    }\n    if (this.bufferedKeys.length > 0) {\n      // if there are any bufferedKeys waiting for other key append them\n      result += this.bufferedKeys.join('');\n    }\n    if (\n      this.actionsRun.length === 0 &&\n      this.actionKeys.length === 0 &&\n      this.bufferedKeys.length === 0 &&\n      this.commandList.length > 0\n    ) {\n      // Used for the registers and macros that only record on commandList\n      result = this.commandList.join('');\n    }\n    const regexEscape = new RegExp(/[|\\\\{}()[\\]^$+*?.]/, 'g');\n    const regexLeader = new RegExp(configuration.leader.replace(regexEscape, '\\\\$&'), 'g');\n    const regexBufferedKeys = new RegExp(SpecialKeys.TimeoutFinished, 'g');\n    result = result.replace(regexLeader, '<leader>').replace(regexBufferedKeys, '');\n\n    return result;\n  }\n\n  /**\n   * String representation of the pending keys that the user entered.\n   */\n  public get pendingCommandString(): string {\n    let result = '';\n\n    if (this.actionKeys.length > 0) {\n      // if there are any actionKeys waiting for other key append them\n      result += this.actionKeys.join('');\n    }\n    if (this.bufferedKeys.length > 0) {\n      // if there are any bufferedKeys waiting for other key append them\n      result += this.bufferedKeys.join('');\n    }\n    const regexEscape = new RegExp(/[|\\\\{}()[\\]^$+*?.]/, 'g');\n    const regexLeader = new RegExp(configuration.leader.replace(regexEscape, '\\\\$&'), 'g');\n    const regexBufferedKeys = new RegExp(SpecialKeys.TimeoutFinished, 'g');\n    result = result.replace(regexLeader, '<leader>').replace(regexBufferedKeys, '');\n\n    return result;\n  }\n\n  /**\n   * Determines if the current command list is prefixed with a count\n   */\n  public get commandWithoutCountPrefix() {\n    return this.commandList.join('').replace(/^[0-9]+/g, '');\n  }\n\n  /**\n   * Reset the command list.\n   */\n  public resetCommandList() {\n    this.commandList = [];\n  }\n\n  /**\n   * Keeps track of keys pressed for the next action. Comes in handy when parsing\n   * multiple length movements, e.g. gg.\n   */\n  public actionKeys: string[] = [];\n\n  /**\n   * Waiting for another key for a potential action.\n   *\n   * Used to prevent the remapping of keys after a potential action key\n   * like @zZtTfF[]rm'`\"gq<C-r><C-w>. This is done to be able to use all\n   * the named registers and marks, even when the command with the same\n   * name has been mapped.\n   *\n   * Vim Documentation: (:help map-error)\n   * \"Note that the second character (argument) of the commands @zZtTfF[]rm'`\"v\n   * and CTRL-X is not mapped. This was done to be able to use all the named\n   * registers and marks, even when the command with the same name has been\n   * mapped.\"\n   *\n   * The documentation only specifies some keys, but from testing pretty much\n   * every key has this condition (keys like 'g', 'q', '<C-r>' and '<C-w>' all\n   * behave the same) so here we use 'waitingForAnotherActionKey' to prevent\n   * remapping on next keys. In the case of the 'v' key specified in the vim\n   * documentation, I don't really understand what they mean with that because\n   * it doesn't make much sense. The 'v' key puts you in Visual mode, it doesn't\n   * accept any character argument.\n   */\n  public waitingForAnotherActionKey: boolean = false;\n\n  /**\n   * Every action that has been run.\n   */\n  public actionsRun: IBaseAction[] = [];\n\n  /**\n   * Keeps track of keys pressed by the actionsRun. Used for the showCmd. If an action\n   * changes previous actions pressed keys it should change this list, like the <Del>\n   * key after a number key.\n   */\n  public actionsRunPressedKeys: string[] = [];\n\n  /**\n   * Every key that was buffered to wait for a new key or the timeout to finish\n   * in order to get another potential remap or to solve an ambiguous remap.\n   */\n  public bufferedKeys: string[] = [];\n  public bufferedKeysTimeoutObj: NodeJS.Timeout | undefined = undefined;\n\n  /**\n   * This is used when the remappers are resending the keys after a potential\n   * remap without an ambiguous remap is broken, either by a new key or by the\n   * timeout finishing.\n   *\n   * It will make it so the first key sent will not be considered as a potential\n   * remap by any of the remappers, even though it is, to prevent the remappers\n   * of doing the same thing again. This way the first key will be handled as an\n   * action but the next keys can still be remapped.\n   *\n   * Example: if you map `iiii -> i<C-A><Esc>` in normal mode and map `ii -> <Esc>`\n   * in insert mode, after pressing `iii` you want the first `i` to put you in\n   * insert mode and the next `ii` to escape to normal mode.\n   */\n  public allowPotentialRemapOnFirstKey = true;\n\n  public hasRunOperator = false;\n\n  /**\n   * This is kind of a hack and should be associated with something like this:\n   *\n   * https://github.com/VSCodeVim/Vim/issues/805\n   */\n  public operatorPositionDiff: PositionDiff | undefined;\n\n  public isInsertion = false;\n\n  /**\n   * The text transformations that we want to run. They will all be run after the action has been processed.\n   *\n   * Running an individual action will generally queue up to one of these, but if you're in\n   * multi-cursor mode, you'll queue one per cursor, or more.\n   *\n   * Note that the text transformations are run in parallel. This is useful in most cases,\n   * but will get you in trouble in others.\n   */\n  public transformer = new Transformer();\n\n  /**\n   * The operator (e.g. d, y, >) the user wants to run, if there is one.\n   */\n  public get operator(): IBaseOperator | undefined {\n    const operators = this.operators;\n    return operators.length > 0 ? operators[0] : undefined;\n  }\n\n  public get operators(): IBaseOperator[] {\n    return this.actionsRun.filter((a): a is IBaseOperator => a.isOperator).reverse();\n  }\n\n  /**\n   * The command (e.g. i, ., R, /) the user wants to run, if there is one.\n   */\n  public get command(): IBaseCommand {\n    const list = this.actionsRun.filter((a): a is IBaseCommand => a.isCommand).reverse();\n\n    // TODO - disregard <Esc>, then assert this is of length 1.\n\n    return list[0];\n  }\n\n  /**\n   * The number of times the user wants to repeat this action.\n   */\n  public count: number = 0;\n\n  /**\n   * The number of times the user wants to repeat the operator. If after the operator the user\n   * uses a motion with count that count will be multiplied by this count.\n   *\n   * Example: if user presses 2d3w it deletes 6 words.\n   */\n  public operatorCount: number = 0;\n\n  /**\n   * The register name for this action.\n   */\n  public registerName: string;\n\n  /**\n   * The key used to access the register with `registerName`\n   * Example: if 'q5' then key=5 and name=5\n   * Or:      if 'qA' then key=A and name=a\n   */\n  public registerKey: string = '';\n\n  public clone(): RecordedState {\n    const res = new RecordedState();\n\n    // TODO: Actual clone.\n\n    res.actionKeys = this.actionKeys.slice(0);\n    res.actionsRun = this.actionsRun.slice(0);\n    res.hasRunOperator = this.hasRunOperator;\n\n    return res;\n  }\n\n  public getOperatorState(mode: Mode): 'pending' | 'ready' | undefined {\n    // Do we have an operator that hasn't been run yet?\n    if (\n      this.operator === undefined ||\n      this.hasRunOperator ||\n      // TODO: Is this mode check necessary?\n      mode === Mode.SearchInProgressMode ||\n      mode === Mode.CommandlineInProgress\n    ) {\n      return undefined;\n    }\n\n    // We've got an operator - do we also have a motion or visual selection to operate on?\n    if (this.actionsRun.some((a) => a.isMotion) || isVisualMode(mode)) {\n      return 'ready';\n    }\n\n    // TODO: I don't think reversing is necessary - can't there only ever be two operators?\n    // This case is for a \"repeated\" operator (such as `dd` or `yy`)\n    if (\n      this.operators.length > 1 &&\n      this.operators.reverse()[0].constructor === this.operators.reverse()[1].constructor\n    ) {\n      return 'ready';\n    }\n\n    return 'pending';\n  }\n}\n\nexport interface IBaseAction {\n  readonly isMotion: boolean;\n  readonly isOperator: boolean;\n  readonly isCommand: boolean;\n  readonly isJump: boolean;\n  readonly canBeRepeatedWithDot: boolean;\n\n  keysPressed: string[];\n  multicursorIndex: number | undefined;\n\n  readonly preservesDesiredColumn: boolean;\n}\n\nexport interface IBaseCommand extends IBaseAction {\n  exec(position: Position, vimState: VimState): Promise<void>;\n}\n\nexport interface IBaseOperator extends IBaseAction {\n  run(vimState: VimState, start: Position, stop: Position): Promise<void>;\n  runRepeat(vimState: VimState, position: Position, count: number): Promise<void>;\n}\n","import { IKeyRemapping } from '../configuration/iconfiguration';\n\n/**\n * State related to key remapping. Held by ModeHandler.\n */\nexport class RemapState {\n  /**\n   * For timing out remapped keys like jj to esc.\n   */\n  public lastKeyPressedTimestamp = 0;\n\n  /**\n   * Used to indicate that a non-recursive remap is being handled.\n   * This is used to prevent non-recursive remappings from looping.\n   */\n  public isCurrentlyPerformingNonRecursiveRemapping = false;\n\n  /**\n   * Used to indicate that a recursive remap is being handled. This is used to prevent recursive remappings\n   * from looping farther then maxMapDepth and to stop recursive remappings when an action fails.\n   */\n  public isCurrentlyPerformingRecursiveRemapping = false;\n\n  /**\n   * Used to indicate that a remap is being handled and the keys sent to modeHandler were not typed\n   * by the user.\n   */\n  public get isCurrentlyPerformingRemapping() {\n    return (\n      this.isCurrentlyPerformingNonRecursiveRemapping ||\n      this.isCurrentlyPerformingRecursiveRemapping\n    );\n  }\n\n  /**\n   * When performing a recursive remapping that has no parent remappings and that finishes while\n   * still waiting for timeout or another key to come we store that remapping here. This is used\n   * to be able to handle those buffered keys and any other key that the user might press to brake\n   * the timeout seperatly. Because if an error happens in the middle of a remap, the remaining\n   * remap keys shouldn't be handled but the user pressed ones should, but if an error happens on\n   * a user typed key, the following typed keys will still be handled.\n   *\n   * Example: having the following remapings:\n   * * `nmap <leader>lf Lfill`\n   * * `nmap Lfillc 4I<space><esc>`\n   * * `nmap Lfillp 2I<space><esc>`\n   * When user presses `<leader>lf` it remaps that to `Lfill` but because that is an ambiguous remap\n   * it creates the timeout and returns from remapper setting the performing remapping flag to false.\n   * This allows the user to then press `c` or `p` and the corresponding remap would run. But if the\n   * user presses another key or the timeout finishes we need to handle the `Lfill` keys and they\n   * need to know they were sent by a remap and not by the user so that in case the find 'i' in\n   * `Lfill` fails the last two `l` shouldn't be executed and any keys typed by the user after the\n   * remap that brake the timeout need to be handled seperatly from `Lfill`.\n   * (Check the tests for this example to understand better).\n   *\n   * To prevent this, we stored the remapping that finished waiting for timeout so that, if the\n   * timeout finishes or the user presses some keys that brake the potential remap, we will know\n   * what was the remapping waiting for timeout. So in case the timeout finishes we set the\n   * currently performing recursive remapping flag to true manually, send the <TimeoutFinished> key\n   * and in the end we set the flag back to false again and clear the stored remapping. In case\n   * the user presses one or more keys that brake the potential timeout we set the flag to true\n   * manually, handle the keys from the remapping and then set the flag back to false, clear the\n   * stored remapping and handle the keys pressed by the user seperatly.\n   * We do this because any VimError or ForceStopRemappingError are thrown only when performing a\n   * remapping.\n   */\n  public wasPerformingRemapThatFinishedWaitingForTimeout: IKeyRemapping | false = false;\n\n  /**\n   * Holds the current map depth count (number of nested remaps without using a character). In recursive remaps\n   * every time we map a key when already performing a remapping this number increases by one. When a remapping\n   * handling uses a character this number resets to 0.\n   *\n   * When it reaches the maxMapDepth it throws the VimError E223.\n   * (check vim documentation :help maxmapdepth)\n   */\n  public mapDepth: number = 0;\n\n  /**\n   * Used to reset the mapDepth on nested recursive remaps. Is set to false every time we get a remapping and is set to\n   * true when a character is used. We consider a character as being used when we get an action.\n   * (check vim documentation :help maxmapdepth).\n   *\n   * Example 1: if we remap `x -> y` and `y -> x` if we press any of those keys we will continuously find a new\n   * remap and increase the mapDepth without ever using an action until we hit maxMapDepth and we get E223 stopping\n   * it all.\n   *\n   * Example 2: if we map `a -> x`, `x -> y`, `y -> b` and `b -> w` and we set maxMapDepth to 4 we get 'E223 Recursive\n   * Mapping', because we get to the fourth remap without ever executing an action, but if we change the 'y' map to\n   * `y -> wb`, now the max mapDepth we hit is 3 and then we execute the action 'w' that resets the mapDepth and then\n   * call another remap of `b -> w` that executes another 'w', meaning that after pressing 'a' the result would be 'ww'.\n   * Another option would be to increase the maxMapDepth to 5 or more and then we could use the initial remaps that would\n   * turn the pressing of 'a' into a single 'w'.\n   *\n   * Example 3 (possible use case): if we remap `<leader>cb -> 0i//<Space><Esc>j<leader>cb` that recursively calls itself,\n   * every time the`0` key is sent we set remapUsedACharacter to true and reset mapDepth to 0 on all nested remaps so even\n   * if it calls itself more than 1000 times (on a file with more than 1000 lines) the mapDepth will always be reset to 0,\n   * which allows the remap to keep calling itself to comment all the lines until either we get to the last line and the 'j'\n   * action fails stopping the entire remap chain or the user presses `<C-c>` or `<Esc>` to forcelly stop the recursive remaps.\n   *\n   * P.S. This behavior is weird, because we should reduce the mapDepth by one when the remapping finished handling\n   * or if it failed. But this is the way Vim does it. This allows the user to create infinite looping remaps\n   * that call themselves and only stop after an error or the user pressing a key (usually <C-c> but we also\n   * allow <Esc> because the user might not allow the use of ctrl keys).\n   *\n   * P.S.2 This is a complicated explanation for a seemingly simple feature, but I wrote this because when I first read the\n   * Vim documentation it wasn't very clear to me how this worked, I first thought that mapDepth was like a map count but that\n   * is not the case because we can have thousands of nested remaps without ever hitting maxMapDepth like in Example 3, and I\n   * only started to understand it better when I tried Example 2 in Vim and some variations of it.\n   */\n  public remapUsedACharacter: boolean = false;\n\n  /**\n   * This will force Stop a recursive remapping. Used by <C-c> or <Esc> key when there is a recursive remapping\n   */\n  public forceStopRecursiveRemapping: boolean = false;\n}\n","import { Position } from 'vscode';\nimport { VimState } from './vimState';\n\n/**\n * State involved with entering Replace mode (R).\n */\nexport class ReplaceState {\n  /**\n   * The cursor location where you began replacing characters.\n   */\n  public replaceCursorStartPosition: Position;\n\n  public readonly originalChars: readonly string[];\n\n  /**\n   * The characters the user inserted in replace mode. Useful for when\n   * we repeat a replace action with .\n   */\n  public readonly newChars: string[] = [];\n\n  /**\n   * Number of times we're going to repeat this replace action.\n   * Comes from the count applied to the `R` command.\n   */\n  public readonly timesToRepeat: number;\n\n  constructor(vimState: VimState, startPosition: Position, timesToRepeat: number = 1) {\n    this.replaceCursorStartPosition = startPosition;\n    this.timesToRepeat = timesToRepeat;\n\n    this.originalChars = vimState.document.lineAt(startPosition).text.split('');\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\n\nimport { configuration } from '../configuration/configuration';\nimport { PositionDiff } from './../common/motion/position';\nimport { Mode } from './../mode/mode';\n\nexport enum SearchDirection {\n  Forward = 1,\n  Backward = -1,\n}\n\n// Older browsers don't support lookbehind - in this case, use an inferior regex rather than crashing\nlet supportsLookbehind = true;\ntry {\n  // tslint:disable-next-line\n  new RegExp('(?<=x)');\n} catch {\n  supportsLookbehind = false;\n}\n\n/**\n * State involved with beginning a search (/).\n */\nexport class SearchState {\n  private static readonly MAX_SEARCH_RANGES = 1000;\n\n  private static readonly specialCharactersRegex = /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g;\n  // c or C with an odd number of preceding \\'s triggers \"case override\"\n  private static readonly caseOverrideRegex = supportsLookbehind\n    ? new RegExp('(?<=(?:^|[^\\\\\\\\])(?:\\\\\\\\\\\\\\\\)*)\\\\\\\\[Cc]', 'g')\n    : /\\\\[Cc]/g;\n  private static readonly notEscapedSlashRegex = supportsLookbehind\n    ? new RegExp('(?<=[^\\\\\\\\])\\\\/', 'g')\n    : /\\//g;\n  private static readonly notEscapedQuestionMarkRegex = supportsLookbehind\n    ? new RegExp('(?<=[^\\\\\\\\])\\\\?', 'g')\n    : /\\?/g;\n  private static readonly searchOffsetBeginRegex = /b(\\+-)?[0-9]*/;\n  private static readonly searchOffsetEndRegex = /e(\\+-)?[0-9]*/;\n\n  public readonly previousMode: Mode;\n  public readonly searchDirection: SearchDirection;\n  public readonly cursorStartPosition: Position;\n\n  /**\n   * Every range in the document that matches the search string.\n   */\n  public getMatchRanges(editor: vscode.TextEditor): vscode.Range[] {\n    return this.recalculateSearchRanges(editor);\n  }\n  private matchRanges: Map<string, { version: number; ranges: vscode.Range[] }> = new Map();\n\n  /**\n   * Whether the needle should be interpreted as a regular expression\n   */\n  private readonly isRegex: boolean;\n\n  /**\n   * If true, an all-lowercase needle will not be treated as case-insensitive, even if smartcase is enabled.\n   * This is used for [g]* and [g]#.\n   */\n  private readonly ignoreSmartcase: boolean;\n\n  /**\n   * The string being searched for\n   */\n  private needle = '';\n\n  // How to adjust the cursor's position after going to a match\n  // Some examples:\n  //   /abc/3 will jump to the third character after finding abc\n  //   /abc/b-2 will go 2 characters to the left after finding abc\n  //   /abc/e2 will go 2 characters to the right from the end of abc after finding it\n  // TODO: support the ; offset (see http://vimdoc.sourceforge.net/htmldoc/pattern.html)\n  private offset?: {\n    type: 'line' | 'beginning' | 'end';\n    num: number;\n  };\n\n  /**\n   * The raw string being searched for, including both the needle and search offset\n   */\n  private _searchString = '';\n  public get searchString(): string {\n    return this._searchString;\n  }\n\n  public set searchString(search: string) {\n    if (this._searchString !== search) {\n      this._searchString = search;\n\n      const oldNeedle = this.needle;\n      this.needle = search;\n      this.offset = undefined;\n\n      const needleSegments =\n        this.searchDirection === SearchDirection.Backward\n          ? search.split(SearchState.notEscapedQuestionMarkRegex)\n          : search.split(SearchState.notEscapedSlashRegex);\n      if (needleSegments.length > 1) {\n        this.needle = needleSegments[0];\n        const num = Number(needleSegments[1]);\n        if (isNaN(num)) {\n          if (SearchState.searchOffsetBeginRegex.test(needleSegments[1])) {\n            this.offset = {\n              type: 'beginning',\n              num: Number(needleSegments[1].slice(1)),\n            };\n          } else if (SearchState.searchOffsetEndRegex.test(needleSegments[1])) {\n            this.offset = {\n              type: 'end',\n              num: Number(needleSegments[1].slice(1)),\n            };\n          }\n        } else {\n          this.offset = {\n            type: 'line',\n            num,\n          };\n        }\n      }\n\n      if (this.needle !== oldNeedle) {\n        // Invalidate all cached results\n        this.matchRanges.clear();\n\n        this._needleRegex = undefined;\n      }\n    }\n  }\n\n  private _needleRegex: RegExp | undefined;\n  private get needleRegex(): RegExp {\n    if (this._needleRegex) {\n      return this._needleRegex;\n    }\n\n    /*\n     * Decide whether the search is case sensitive.\n     * If ignorecase is false, the search is case sensitive.\n     * If ignorecase is true, the search should be case insensitive.\n     * If both ignorecase and smartcase are true, the search is case sensitive only when the search string contains UpperCase character.\n     */\n    let ignorecase = configuration.ignorecase;\n    if (\n      ignorecase &&\n      configuration.smartcase &&\n      !this.ignoreSmartcase &&\n      /[A-Z]/.test(this.needle)\n    ) {\n      ignorecase = false;\n    }\n\n    let searchRE = this.needle;\n    const ignorecaseOverride = this.needle.match(SearchState.caseOverrideRegex);\n    if (ignorecaseOverride) {\n      // Vim strips all \\c's but uses the behavior of the first one.\n      searchRE = this.needle.replace(SearchState.caseOverrideRegex, '');\n      ignorecase = ignorecaseOverride[0][1] === 'c';\n    }\n\n    if (!this.isRegex) {\n      searchRE = this.needle.replace(SearchState.specialCharactersRegex, '\\\\$&');\n    }\n\n    const regexFlags = ignorecase ? 'gim' : 'gm';\n\n    try {\n      this._needleRegex = new RegExp(searchRE, regexFlags);\n    } catch (err) {\n      // Couldn't compile the regexp, try again with special characters escaped\n      searchRE = this.needle.replace(SearchState.specialCharactersRegex, '\\\\$&');\n      this._needleRegex = new RegExp(searchRE, regexFlags);\n    }\n\n    return this._needleRegex;\n  }\n\n  private recalculateSearchRanges(editor: vscode.TextEditor): vscode.Range[] {\n    if (this.needle === '') {\n      return [];\n    }\n\n    const document = editor.document;\n\n    const cached = this.matchRanges.get(document.fileName);\n    if (cached?.version === document.version) {\n      return cached.ranges;\n    }\n\n    // We store the entire text file as a string inside text, and run the\n    // regex against it many times to find all of our matches.\n    const text = document.getText();\n    const selection = editor.selection;\n    const startOffset = document.offsetAt(selection.active);\n    const regex = this.needleRegex;\n    regex.lastIndex = startOffset;\n\n    let result: RegExpExecArray | null;\n    let wrappedOver = false;\n    const matchRanges = [] as vscode.Range[];\n    while (true) {\n      result = regex.exec(text);\n\n      if (result) {\n        if (wrappedOver && result.index >= startOffset) {\n          // We've found our first match again\n          break;\n        }\n\n        matchRanges.push(\n          new vscode.Range(\n            document.positionAt(result.index),\n            document.positionAt(result.index + result[0].length)\n          )\n        );\n\n        if (matchRanges.length >= SearchState.MAX_SEARCH_RANGES) {\n          break;\n        }\n\n        // This happens when you find a zero-length match\n        if (result.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n      } else if (!wrappedOver) {\n        // We need to wrap around to the back if we reach the end.\n        regex.lastIndex = 0;\n        wrappedOver = true;\n      } else {\n        break;\n      }\n    }\n\n    // TODO: we know the order of matches; this sort is lazy and could become a bottleneck if we increase the max # of matches\n    matchRanges.sort((x, y) => (x.start.isBefore(y.start) ? -1 : 1));\n    this.matchRanges.set(document.fileName, {\n      version: document.version,\n      ranges: matchRanges,\n    });\n    return matchRanges;\n  }\n\n  /**\n   * The position of the next search.\n   * match == false if there is no match.\n   *\n   * Pass in -1 as direction to reverse the direction we search.\n   */\n  public getNextSearchMatchPosition(\n    editor: vscode.TextEditor,\n    startPosition: Position,\n    direction = SearchDirection.Forward\n  ): { pos: Position; index: number } | undefined {\n    const nextMatch = this.getNextSearchMatchRange(editor, startPosition, direction);\n    if (nextMatch === undefined) {\n      return undefined;\n    }\n    const { start, end, index } = nextMatch;\n\n    let pos = start;\n    if (this.offset) {\n      if (this.offset.type === 'line') {\n        pos = start.add(\n          editor.document,\n          PositionDiff.exactCharacter({ lineOffset: this.offset.num, character: 0 })\n        );\n      } else if (this.offset.type === 'beginning') {\n        pos = start.getOffsetThroughLineBreaks(this.offset.num);\n      } else if (this.offset.type === 'end') {\n        pos = end.getOffsetThroughLineBreaks(this.offset.num - 1);\n      }\n    }\n\n    return { pos, index };\n  }\n\n  /**\n   * The position of the next search.\n   * match == false if there is no match.\n   *\n   * Pass in -1 as direction to reverse the direction we search.\n   *\n   * end is exclusive; which means the index is start + matchedString.length\n   */\n  public getNextSearchMatchRange(\n    editor: vscode.TextEditor,\n    startPosition: Position,\n    direction = SearchDirection.Forward\n  ): { start: Position; end: Position; index: number } | undefined {\n    const matchRanges = this.recalculateSearchRanges(editor);\n\n    if (matchRanges.length === 0) {\n      return undefined;\n    }\n\n    const effectiveDirection = (direction * this.searchDirection) as SearchDirection;\n\n    if (effectiveDirection === SearchDirection.Forward) {\n      for (const [index, matchRange] of matchRanges.entries()) {\n        if (matchRange.start.isAfter(startPosition)) {\n          return {\n            start: matchRange.start,\n            end: matchRange.end,\n            index,\n          };\n        }\n      }\n      // We've hit the bottom of the file. Wrap around if configured to do so, or return undefined.\n      if (configuration.wrapscan) {\n        const range = matchRanges[0];\n        return {\n          start: range.start,\n          end: range.end,\n          index: 0,\n        };\n      } else {\n        return undefined;\n      }\n    } else {\n      for (const [index, matchRange] of matchRanges.slice(0).reverse().entries()) {\n        if (matchRange.end.isBeforeOrEqual(startPosition)) {\n          return {\n            start: matchRange.start,\n            end: matchRange.end,\n            index: matchRanges.length - index - 1,\n          };\n        }\n      }\n\n      // We've hit the top of the file. Wrap around if configured to do so, or return undefined.\n      if (configuration.wrapscan) {\n        const range = matchRanges[matchRanges.length - 1];\n        return {\n          start: range.start,\n          end: range.end,\n          index: matchRanges.length - 1,\n        };\n      } else {\n        return undefined;\n      }\n    }\n  }\n\n  public getSearchMatchRangeOf(\n    editor: vscode.TextEditor,\n    pos: Position\n  ): { start: Position; end: Position; index: number } | undefined {\n    const matchRanges = this.recalculateSearchRanges(editor);\n\n    if (matchRanges.length === 0) {\n      return undefined;\n    }\n\n    for (const [index, matchRange] of matchRanges.entries()) {\n      if (matchRange.start.isBeforeOrEqual(pos) && matchRange.end.isAfter(pos)) {\n        return {\n          start: matchRange.start,\n          end: matchRange.end,\n          index,\n        };\n      }\n    }\n\n    return undefined;\n  }\n\n  constructor(\n    direction: SearchDirection,\n    startPosition: Position,\n    searchString = '',\n    { isRegex = false, ignoreSmartcase = false } = {},\n    currentMode: Mode\n  ) {\n    this.searchDirection = direction;\n    this.cursorStartPosition = startPosition;\n    this.isRegex = isRegex;\n    this.ignoreSmartcase = ignoreSmartcase;\n    this.searchString = searchString;\n    this.previousMode = currentMode;\n  }\n}\n","/**\n * State involved with Substitution commands (:s).\n */\nexport class SubstituteState {\n  /**\n   * The last pattern searched for in the substitution\n   */\n  public searchPattern: string;\n\n  /**\n   * The last replacement string in the substitution\n   */\n  public replaceString: string;\n\n  constructor(searchPattern: string, replaceString: string) {\n    this.searchPattern = searchPattern;\n    this.replaceString = replaceString;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { IMovement } from '../actions/baseMotion';\nimport { configuration } from '../configuration/configuration';\nimport { IEasyMotion } from '../actions/plugins/easymotion/types';\nimport { EditorIdentity } from './../editorIdentity';\nimport { HistoryTracker } from './../history/historyTracker';\nimport { Logger } from '../util/logger';\nimport { Mode } from '../mode/mode';\nimport { Cursor } from '../common/motion/cursor';\nimport { RecordedState } from './recordedState';\nimport { RegisterMode } from './../register/register';\nimport { ReplaceState } from './../state/replaceState';\nimport { SurroundState } from '../actions/plugins/surround';\nimport { SUPPORT_NVIM, SUPPORT_IME_SWITCHER } from 'platform/constants';\nimport { Position } from 'vscode';\n\ninterface IInputMethodSwitcher {\n  switchInputMethod(prevMode: Mode, newMode: Mode): Promise<void>;\n}\n\ninterface IBaseMovement {\n  execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement>;\n}\n\ninterface INVim {\n  run(vimState: VimState, command: string): Promise<{ statusBarText: string; error: boolean }>;\n\n  dispose(): void;\n}\n\n/**\n * The VimState class holds permanent state that carries over from action\n * to action.\n *\n * Actions defined in actions.ts are only allowed to mutate a VimState in order to\n * indicate what they want to do.\n *\n * Each ModeHandler holds a VimState, so there is one for each open editor.\n */\nexport class VimState implements vscode.Disposable {\n  private static readonly logger = Logger.get('VimState');\n\n  /**\n   * The column the cursor wants to be at, or Number.POSITIVE_INFINITY if it should always\n   * be the rightmost column.\n   *\n   * Example: If you go to the end of a 20 character column, this value\n   * will be 20, even if you press j and the next column is only 5 characters.\n   * This is because if the third column is 25 characters, the cursor will go\n   * back to the 20th column.\n   */\n  public desiredColumn = 0;\n\n  public historyTracker: HistoryTracker;\n\n  public easyMotion: IEasyMotion;\n\n  public readonly identity: EditorIdentity;\n\n  public editor: vscode.TextEditor;\n\n  public get document(): vscode.TextDocument {\n    return this.editor.document;\n  }\n\n  /**\n   * Are multiple cursors currently present?\n   */\n  public get isMultiCursor(): boolean {\n    return this._cursors.length > 1;\n  }\n\n  /**\n   * Is the multicursor something like visual block \"multicursor\", where\n   * natively in vim there would only be one cursor whose changes were applied\n   * to all lines after edit.\n   */\n  public isFakeMultiCursor = false;\n\n  /**\n   * Tracks movements that can be repeated with ; (e.g. t, T, f, and F).\n   */\n  public lastSemicolonRepeatableMovement: IBaseMovement | undefined = undefined;\n\n  /**\n   * Tracks movements that can be repeated with , (e.g. t, T, f, and F).\n   */\n  public lastCommaRepeatableMovement: IBaseMovement | undefined = undefined;\n\n  // TODO: move into ModeHandler\n  public lastMovementFailed: boolean = false;\n\n  public isRunningDotCommand = false;\n  public isReplayingMacro: boolean = false;\n\n  /**\n   * The last visual selection before running the dot command\n   */\n  public dotCommandPreviousVisualSelection: vscode.Selection | undefined = undefined;\n\n  /**\n   * The first line number that was visible when SearchInProgressMode began (undefined if not searching)\n   */\n  public firstVisibleLineBeforeSearch: number | undefined = undefined;\n\n  public surround: SurroundState | undefined = undefined;\n\n  /**\n   * Used for `<C-o>` in insert mode, which allows you run one normal mode\n   * command, then go back to insert mode.\n   */\n  public returnToInsertAfterCommand = false;\n  public actionCount = 0;\n\n  /**\n   * Every time we invoke a VSCode command which might trigger a view update.\n   * We should postpone its view updating phase to avoid conflicting with our internal view updating mechanism.\n   * This array is used to cache every VSCode view updating event and they will be triggered once we run the inhouse `viewUpdate`.\n   */\n  public postponedCodeViewChanges: ViewChange[] = [];\n\n  /**\n   * The cursor position (start, stop) when this action finishes.\n   */\n  public get cursorStartPosition(): Position {\n    return this.cursors[0].start;\n  }\n  public set cursorStartPosition(value: Position) {\n    if (!value.isValid(this.editor)) {\n      VimState.logger.warn(`invalid cursor start position. ${value.toString()}.`);\n    }\n    this.cursors[0] = this.cursors[0].withNewStart(value);\n  }\n\n  public get cursorStopPosition(): Position {\n    return this.cursors[0].stop;\n  }\n  public set cursorStopPosition(value: Position) {\n    if (!value.isValid(this.editor)) {\n      VimState.logger.warn(`invalid cursor stop position. ${value.toString()}.`);\n    }\n    this.cursors[0] = this.cursors[0].withNewStop(value);\n  }\n\n  /**\n   * The position of every cursor. Will never be empty.\n   */\n  private _cursors: Cursor[] = [new Cursor(new Position(0, 0), new Position(0, 0))];\n\n  public get cursors(): Cursor[] {\n    return this._cursors;\n  }\n  public set cursors(value: Cursor[]) {\n    if (value.length === 0) {\n      VimState.logger.warn('Tried to set VimState.cursors to an empty array');\n      return;\n    }\n\n    const map = new Map<string, Cursor>();\n    for (const cursor of value) {\n      if (!cursor.isValid(this.editor)) {\n        VimState.logger.warn(`invalid cursor position. ${cursor.toString()}.`);\n      }\n\n      // use a map to ensure no two cursors are at the same location.\n      map.set(cursor.toString(), cursor);\n    }\n\n    this._cursors = [...map.values()];\n  }\n\n  /**\n   * Initial state of cursors prior to any action being performed\n   */\n  private _cursorsInitialState!: Cursor[];\n  public get cursorsInitialState(): Cursor[] {\n    return this._cursorsInitialState;\n  }\n  public set cursorsInitialState(cursors: Cursor[]) {\n    this._cursorsInitialState = [...cursors];\n  }\n\n  public replaceState: ReplaceState | undefined = undefined;\n\n  /**\n   * Stores last visual mode as well as what was selected for `gv`\n   */\n  public lastVisualSelection:\n    | {\n        mode: Mode.Visual | Mode.VisualLine | Mode.VisualBlock;\n        start: Position;\n        end: Position;\n      }\n    | undefined = undefined;\n\n  /**\n   * Was the previous mouse click past EOL\n   */\n  public lastClickWasPastEol: boolean = false;\n\n  /**\n   * Used internally to ignore selection changes that were performed by us.\n   * 'ignoreIntermediateSelections': set to true when running an action, during this time\n   * all selections change events will be ignored.\n   * 'ourSelections': keeps track of our selections that will trigger a selection change event\n   * so that we can ignore them.\n   */\n  public selectionsChanged = {\n    /**\n     * Set to true when running an action, during this time\n     * all selections change events will be ignored.\n     */\n    ignoreIntermediateSelections: false,\n    /**\n     * keeps track of our selections that will trigger a selection change event\n     * so that we can ignore them.\n     */\n    ourSelections: Array<string>(),\n  };\n\n  /**\n   * The mode Vim will be in once this action finishes.\n   */\n  private _currentMode: Mode = Mode.Normal;\n\n  public get currentMode(): Mode {\n    return this._currentMode;\n  }\n\n  private inputMethodSwitcher?: IInputMethodSwitcher;\n  /**\n   * The mode Vim is currently including pseudo-modes like OperatorPendingMode\n   * This is to be used only by the Remappers when getting the remappings so don't\n   * use it anywhere else.\n   */\n  public get currentModeIncludingPseudoModes(): Mode {\n    return this.recordedState.getOperatorState(this._currentMode) === 'pending'\n      ? Mode.OperatorPendingMode\n      : this._currentMode;\n  }\n\n  public async setCurrentMode(mode: Mode): Promise<void> {\n    if (mode === undefined) {\n      // TODO: remove this once we're sure this is no longer an issue (#6500, #6464)\n      throw new Error('Tried setting currentMode to undefined');\n    }\n\n    await this.inputMethodSwitcher?.switchInputMethod(this._currentMode, mode);\n    if (this.returnToInsertAfterCommand && mode === Mode.Insert) {\n      this.returnToInsertAfterCommand = false;\n    }\n    this._currentMode = mode;\n\n    if (configuration.smartRelativeLine) {\n      this.editor.options.lineNumbers =\n        mode === Mode.Insert\n          ? vscode.TextEditorLineNumbersStyle.On\n          : vscode.TextEditorLineNumbersStyle.Relative;\n    }\n\n    if (mode === Mode.SearchInProgressMode) {\n      this.firstVisibleLineBeforeSearch = this.editor.visibleRanges[0].start.line;\n    } else {\n      this.firstVisibleLineBeforeSearch = undefined;\n    }\n  }\n\n  /**\n   * The currently active `RegisterMode`.\n   *\n   * When setting, `undefined` means \"default for current `Mode`\".\n   */\n  public set currentRegisterMode(registerMode: RegisterMode | undefined) {\n    this._currentRegisterMode = registerMode;\n  }\n  public get currentRegisterMode(): RegisterMode {\n    if (this._currentRegisterMode) {\n      return this._currentRegisterMode;\n    }\n    switch (this.currentMode) {\n      case Mode.VisualLine:\n        return RegisterMode.LineWise;\n      case Mode.VisualBlock:\n        return RegisterMode.BlockWise;\n      default:\n        return RegisterMode.CharacterWise;\n    }\n  }\n  private _currentRegisterMode: RegisterMode | undefined;\n\n  public currentCommandlineText = '';\n  public statusBarCursorCharacterPos = 0;\n\n  public recordedState = new RecordedState();\n\n  /** The macro currently being recorded, if one exists. */\n  public macro: RecordedState | undefined;\n\n  public lastInvokedMacro: RecordedState | undefined;\n\n  public nvim?: INVim;\n\n  public constructor(editor: vscode.TextEditor, easyMotion: IEasyMotion) {\n    this.editor = editor;\n    this.identity = EditorIdentity.fromEditor(editor);\n    this.historyTracker = new HistoryTracker(this);\n    this.easyMotion = easyMotion;\n  }\n\n  async load() {\n    if (SUPPORT_NVIM) {\n      const m = await import('../neovim/neovim');\n      this.nvim = new m.NeovimWrapper();\n    }\n\n    if (SUPPORT_IME_SWITCHER) {\n      const ime = await import('../actions/plugins/imswitcher');\n      this.inputMethodSwitcher = new ime.InputMethodSwitcher();\n    }\n  }\n\n  dispose() {\n    this.nvim?.dispose();\n  }\n}\n\nexport interface ViewChange {\n  command: string;\n  args: any;\n}\n","import * as vscode from 'vscode';\nimport { Mode } from './mode/mode';\nimport { globalState } from './state/globalState';\nimport { SearchDirection } from './state/searchState';\nimport { configuration } from './configuration/configuration';\nimport { VimState } from './state/vimState';\nimport { Logger } from './util/logger';\nimport { VimError } from './error';\n\nclass StatusBarImpl implements vscode.Disposable {\n  // Displays the current state (mode, recording macro, etc.) and messages to the user\n  private readonly statusBarItem: vscode.StatusBarItem;\n\n  // Displays the keys you've typed so far when they haven't yet resolved to a command\n  private readonly recordedStateStatusBarItem: vscode.StatusBarItem;\n\n  private previousMode: Mode | undefined = undefined;\n  private showingDefaultMessage = true;\n\n  public lastMessageTime: Date | undefined;\n\n  constructor() {\n    this.statusBarItem = vscode.window.createStatusBarItem(\n      'primary',\n      vscode.StatusBarAlignment.Left,\n      Number.MIN_SAFE_INTEGER // Furthest right on the left\n    );\n    this.statusBarItem.name = 'Vim Command Line';\n    this.statusBarItem.show();\n\n    this.recordedStateStatusBarItem = vscode.window.createStatusBarItem(\n      'showcmd',\n      vscode.StatusBarAlignment.Right,\n      Number.MAX_SAFE_INTEGER // Furthest left on the right\n    );\n    this.recordedStateStatusBarItem.name = 'Vim Pending Command Keys';\n    this.recordedStateStatusBarItem.show();\n  }\n\n  dispose() {\n    this.statusBarItem.dispose();\n    this.recordedStateStatusBarItem.dispose();\n  }\n\n  public updateShowCmd(vimState: VimState) {\n    this.recordedStateStatusBarItem.text = configuration.showcmd\n      ? statusBarCommandText(vimState)\n      : '';\n  }\n\n  /**\n   * Updates the status bar text\n   * @param isError If true, text rendered in red\n   */\n  public setText(vimState: VimState, text: string, isError = false) {\n    const hasModeChanged = vimState.currentMode !== this.previousMode;\n\n    // Text\n    this.updateText(text);\n\n    // StatusBarItem color\n    if (!configuration.statusBarColorControl) {\n      this.statusBarItem.color = isError\n        ? new vscode.ThemeColor('statusBarItem.errorForeground')\n        : undefined;\n      this.statusBarItem.backgroundColor = isError\n        ? new vscode.ThemeColor('statusBarItem.errorBackground')\n        : undefined;\n    }\n\n    // StatusBar color\n    const shouldUpdateColor = configuration.statusBarColorControl && hasModeChanged;\n    if (shouldUpdateColor) {\n      this.updateColor(vimState.currentMode);\n    }\n\n    this.previousMode = vimState.currentMode;\n    this.showingDefaultMessage = false;\n    this.lastMessageTime = new Date();\n  }\n\n  public displayError(vimState: VimState, error: VimError) {\n    StatusBar.setText(vimState, error.toString(), true);\n  }\n\n  public getText() {\n    return this.statusBarItem.text.replace(/\\^M/g, '\\n');\n  }\n\n  /**\n   * Clears any messages from the status bar, leaving the default info, such as\n   * the current mode and macro being recorded.\n   * @param force If true, will clear even high priority messages like errors.\n   */\n  public clear(vimState: VimState, force = true) {\n    if (!this.showingDefaultMessage && !force) {\n      return;\n    }\n\n    const text: string[] = [];\n\n    if (\n      configuration.showmodename ||\n      vimState.currentMode === Mode.CommandlineInProgress ||\n      vimState.currentMode === Mode.SearchInProgressMode\n    ) {\n      text.push(statusBarText(vimState));\n      if (vimState.isMultiCursor) {\n        text.push(' MULTI CURSOR ');\n      }\n    }\n\n    if (vimState.macro) {\n      const macroText = 'Recording @' + vimState.macro.registerName;\n      text.push(macroText);\n    }\n\n    StatusBar.setText(vimState, text.join(' '));\n\n    this.showingDefaultMessage = true;\n  }\n\n  private updateText(text: string) {\n    const escaped = text.replace(/\\n/g, '^M');\n    this.statusBarItem.text = escaped || '';\n  }\n\n  private updateColor(mode: Mode) {\n    let foreground: string | undefined;\n    let background: string | undefined;\n\n    const colorToSet = configuration.statusBarColors[Mode[mode].toLowerCase()];\n\n    if (colorToSet !== undefined) {\n      if (typeof colorToSet === 'string') {\n        background = colorToSet;\n      } else {\n        [background, foreground] = colorToSet;\n      }\n    }\n\n    const workbenchConfiguration = configuration.getConfiguration('workbench');\n    const currentColorCustomizations: {\n      [index: string]: string;\n    } = workbenchConfiguration.get('colorCustomizations') ?? {};\n\n    const colorCustomizations = { ...currentColorCustomizations };\n\n    // If colors are undefined, return to VSCode defaults\n    if (background !== undefined) {\n      colorCustomizations['statusBar.background'] = background;\n      colorCustomizations['statusBar.noFolderBackground'] = background;\n      colorCustomizations['statusBar.debuggingBackground'] = background;\n    }\n\n    if (foreground !== undefined) {\n      colorCustomizations['statusBar.foreground'] = foreground;\n      colorCustomizations['statusBar.debuggingForeground'] = foreground;\n    }\n\n    if (currentColorCustomizations !== colorCustomizations) {\n      workbenchConfiguration.update('colorCustomizations', colorCustomizations, true);\n    }\n  }\n}\n\nexport const StatusBar = new StatusBarImpl();\n\nexport function statusBarText(vimState: VimState) {\n  const cursorChar =\n    vimState.recordedState.actionKeys[vimState.recordedState.actionKeys.length - 1] === '<C-r>'\n      ? '\"'\n      : '|';\n  switch (vimState.currentMode) {\n    case Mode.Normal:\n      return '-- NORMAL --';\n    case Mode.Insert:\n      return '-- INSERT --';\n    case Mode.Visual:\n      return '-- VISUAL --';\n    case Mode.VisualBlock:\n      return '-- VISUAL BLOCK --';\n    case Mode.VisualLine:\n      return '-- VISUAL LINE --';\n    case Mode.Replace:\n      return '-- REPLACE --';\n    case Mode.EasyMotionMode:\n      return '-- EASYMOTION --';\n    case Mode.EasyMotionInputMode:\n      return '-- EASYMOTION INPUT --';\n    case Mode.SurroundInputMode:\n      return '-- SURROUND INPUT --';\n    case Mode.Disabled:\n      return '-- VIM: DISABLED --';\n    case Mode.SearchInProgressMode:\n      if (globalState.searchState === undefined) {\n        const logger = Logger.get('StatusBar');\n        logger.warn(`globalState.searchState is undefined in SearchInProgressMode.`);\n        return '';\n      }\n      const leadingChar =\n        globalState.searchState.searchDirection === SearchDirection.Forward ? '/' : '?';\n\n      const searchWithCursor = globalState.searchState.searchString.split('');\n      searchWithCursor.splice(vimState.statusBarCursorCharacterPos, 0, cursorChar);\n\n      return `${leadingChar}${searchWithCursor.join('')}`;\n    case Mode.CommandlineInProgress:\n      const commandWithCursor = vimState.currentCommandlineText.split('');\n      commandWithCursor.splice(vimState.statusBarCursorCharacterPos, 0, cursorChar);\n\n      return `:${commandWithCursor.join('')}`;\n    default:\n      return '';\n  }\n}\n\nexport function statusBarCommandText(vimState: VimState): string {\n  switch (vimState.currentMode) {\n    case Mode.SurroundInputMode:\n      return vimState.surround && vimState.surround.replacement\n        ? vimState.surround.replacement\n        : '';\n    case Mode.EasyMotionMode:\n      return `Target key: ${vimState.easyMotion.accumulation}`;\n    case Mode.EasyMotionInputMode:\n      if (!vimState.easyMotion) {\n        return '';\n      }\n\n      const searchCharCount = vimState.easyMotion.searchAction.searchCharCount;\n      const message =\n        searchCharCount > 0\n          ? `Search for ${searchCharCount} character(s): `\n          : 'Search for characters: ';\n      return message + vimState.easyMotion.searchAction.searchString;\n    case Mode.Visual: {\n      // TODO: holy shit, this is SO much more complicated than it should be because\n      // our representation of a visual selection is so weird and inconsistent\n      let [start, end] = [vimState.cursorStartPosition, vimState.cursorStopPosition];\n      let wentOverEOL = false;\n      if (start.isAfter(end)) {\n        start = start.getRightThroughLineBreaks();\n        [start, end] = [end, start];\n      } else if (end.isAfter(start) && end.character === 0) {\n        end = end.getLeftThroughLineBreaks(true);\n        wentOverEOL = true;\n      }\n      const lines = end.line - start.line + 1;\n      if (lines > 1) {\n        return `${lines} ${vimState.recordedState.pendingCommandString}`;\n      } else {\n        const chars = Math.max(end.character - start.character, 1) + (wentOverEOL ? 1 : 0);\n        return `${chars} ${vimState.recordedState.pendingCommandString}`;\n      }\n    }\n    case Mode.VisualLine:\n      return `${\n        Math.abs(vimState.cursorStopPosition.line - vimState.cursorStartPosition.line) + 1\n      } ${vimState.recordedState.pendingCommandString}`;\n    case Mode.VisualBlock: {\n      const lines =\n        Math.abs(vimState.cursorStopPosition.line - vimState.cursorStartPosition.line) + 1;\n      const chars =\n        Math.abs(vimState.cursorStopPosition.character - vimState.cursorStartPosition.character) +\n        1;\n      return `${lines}x${chars} ${vimState.recordedState.pendingCommandString}`;\n    }\n    case Mode.Insert:\n    case Mode.Replace:\n      return vimState.recordedState.pendingCommandString;\n    case Mode.Normal:\n    case Mode.Disabled:\n      return vimState.recordedState.commandString;\n    default:\n      return '';\n  }\n}\n","import * as vscode from 'vscode';\nimport Queue from 'queue';\nimport { Logger } from './util/logger';\nimport { extensionVersion } from './configuration/configuration';\n\nclass TaskQueue {\n  private readonly logger = Logger.get('TaskQueue');\n  private readonly taskQueue = new Queue({ autostart: true, concurrency: 1 });\n\n  constructor() {\n    this.taskQueue.addListener('error', (err, task) => {\n      if (err instanceof Error) {\n        const reportButton = 'Report bug';\n        const stack = err.stack;\n\n        // TODO: this is a bit janky - should probably create custom ContextualError class or find a library\n        // tslint:disable:no-string-literal\n        const context = err['context'];\n\n        vscode.window\n          .showErrorMessage(err.message, reportButton)\n          .then((picked: string | undefined) => {\n            if (picked === reportButton) {\n              let body = `**To Reproduce**\\nSteps to reproduce the behavior:\\n\\n1.  Go to '...'\\n2.  Click on '....'\\n3.  Scroll down to '....'\\n4.  See error\\n\\n**VSCodeVim version**: ${extensionVersion}`;\n              if (stack) {\n                body += `\\n\\n<details><summary>Stack trace</summary>\\n\\n\\`\\`\\`\\n${stack}\\n\\`\\`\\`\\n\\n</details>`;\n              }\n              if (context) {\n                body += `\\n\\n<details><summary>Additional context</summary>\\n\\n\\`\\`\\``;\n                for (const prop in context) {\n                  if (context.hasOwnProperty(prop)) {\n                    body += `\\n${prop}: ${JSON.stringify(context[prop], undefined, 2)}`;\n                  }\n                }\n                body += `\\n\\`\\`\\`\\n\\n</details>`;\n              }\n              vscode.commands.executeCommand(\n                'vscode.open',\n                vscode.Uri.parse(\n                  `https://github.com/VSCodeVim/Vim/issues/new?title=${err.message}&body=${body}`\n                )\n              );\n            }\n          });\n      } else {\n        this.logger.error(`Error running task due to an unknown error: ${err}.`);\n      }\n    });\n  }\n\n  /**\n   * Adds a task to the task queue.\n   */\n  public enqueueTask(task: () => Promise<void>): void {\n    this.taskQueue.push(task);\n  }\n}\n\nexport let taskQueue = new TaskQueue();\n","import * as vscode from 'vscode';\n\nimport { configuration } from './configuration/configuration';\nimport { VimState } from './state/vimState';\nimport { visualBlockGetTopLeftPosition, visualBlockGetBottomRightPosition } from './mode/mode';\nimport { Cursor } from './common/motion/cursor';\nimport { Position } from 'vscode';\nimport { Logger } from './util/logger';\nimport { clamp } from './util/util';\n\n/**\n * Collection of helper functions around vscode.window.activeTextEditor\n */\nexport class TextEditor {\n  private static readonly whitespaceRegExp = new RegExp('\\\\s+');\n  private static readonly logger = Logger.get('TextEditor');\n\n  /**\n   * @deprecated Use InsertTextTransformation (or InsertTextVSCodeTransformation) instead.\n   */\n  static async insert(\n    editor: vscode.TextEditor,\n    text: string,\n    at?: Position,\n    letVSCodeHandleKeystrokes?: boolean\n  ): Promise<void> {\n    // If we insert \"blah(\" with default:type, VSCode will insert the closing ).\n    // We *probably* don't want that to happen if we're inserting a lot of text.\n    letVSCodeHandleKeystrokes ??= text.length === 1;\n\n    if (!letVSCodeHandleKeystrokes) {\n      await editor.edit((editBuilder) => {\n        if (!at) {\n          at = editor.selection.active;\n        }\n\n        editBuilder.insert(at, text);\n      });\n    } else {\n      await vscode.commands.executeCommand('default:type', { text });\n    }\n  }\n\n  /**\n   * @deprecated. Use ReplaceTextTransformation instead.\n   */\n  static async replace(\n    editor: vscode.TextEditor,\n    range: vscode.Range,\n    text: string\n  ): Promise<boolean> {\n    return editor.edit((editBuilder) => {\n      editBuilder.replace(range, text);\n    });\n  }\n\n  /** @deprecated Use vimState.document.lineCount */\n  static getLineCount(textEditor?: vscode.TextEditor): number {\n    textEditor ??= vscode.window.activeTextEditor;\n    return textEditor?.document.lineCount ?? -1;\n  }\n\n  public static getLineLength(line: number): number {\n    if (line < 0 || line >= TextEditor.getLineCount()) {\n      this.logger.warn(`getLineLength() called with out-of-bounds line ${line}`);\n      return 0;\n    }\n\n    return vscode.window.activeTextEditor!.document.lineAt(line).text.length;\n  }\n\n  /** @deprecated Use `vimState.document.lineAt()` directly */\n  static getLine(lineNumber: number): vscode.TextLine {\n    return vscode.window.activeTextEditor!.document.lineAt(lineNumber);\n  }\n\n  static getCharAt(document: vscode.TextDocument, position: Position): string {\n    position = document.validatePosition(position);\n    return document.lineAt(position).text[position.character];\n  }\n\n  /**\n   * Retrieves the word at the given position.\n   *\n   * Respects `iskeyword`:\n   *    - Will go right (but not over line boundaries) until it finds a \"real\" word\n   *    - Will settle for a \"fake\" word only if it hits the line end\n   */\n  static getWord(document: vscode.TextDocument, position: Position): string | undefined {\n    const line = document.lineAt(position).text;\n\n    // Skip over whitespace\n    let firstNonBlank = position.character;\n    while (this.whitespaceRegExp.test(line[firstNonBlank])) {\n      firstNonBlank++;\n      if (firstNonBlank === line.length) {\n        // Hit end of line without finding a non-whitespace character\n        return undefined;\n      }\n    }\n\n    // Now skip over word separators and whitespace to find a \"real\" word\n    let start = firstNonBlank;\n    while (\n      configuration.iskeyword.includes(line[start]) ||\n      this.whitespaceRegExp.test(line[start])\n    ) {\n      start++;\n      if (start === line.length) {\n        // No keyword found - just settle for the word we're on\n        start = firstNonBlank;\n        break;\n      }\n    }\n\n    const foundRealWord = !configuration.iskeyword.includes(line[start]);\n    const includeInWord = (char: string) =>\n      !this.whitespaceRegExp.test(char) && configuration.iskeyword.includes(char) !== foundRealWord;\n\n    // Expand left and right to find the whole word\n    let end = start;\n    while (start > 0 && includeInWord(line[start - 1])) {\n      start--;\n    }\n    while (end < line.length && includeInWord(line[end + 1])) {\n      end++;\n    }\n\n    return line.substring(start, end + 1);\n  }\n\n  static getTabCharacter(editor: vscode.TextEditor): string {\n    if (editor.options.insertSpaces) {\n      // This will always be a number when we're getting it from the options\n      const tabSize = editor.options.tabSize as number;\n      return ' '.repeat(tabSize);\n    }\n    return '\\t';\n  }\n\n  /**\n   * @returns the number of visible columns that the given line begins with\n   */\n  static getIndentationLevel(line: string): number {\n    let visibleColumn = 0;\n    for (const char of line) {\n      switch (char) {\n        case '\\t':\n          visibleColumn += configuration.tabstop;\n          break;\n        case ' ':\n          visibleColumn += 1;\n          break;\n        default:\n          return visibleColumn;\n      }\n    }\n\n    return visibleColumn;\n  }\n\n  /**\n   * @returns `line` with its indentation replaced with `screenCharacters` visible columns of whitespace\n   */\n  static setIndentationLevel(line: string, screenCharacters: number): string {\n    const tabSize = configuration.tabstop;\n\n    if (screenCharacters < 0) {\n      screenCharacters = 0;\n    }\n\n    const indentString = configuration.expandtab\n      ? ' '.repeat(screenCharacters)\n      : '\\t'.repeat(screenCharacters / tabSize) + ' '.repeat(screenCharacters % tabSize);\n\n    return line.replace(/^\\s*/, indentString);\n  }\n\n  static getDocumentBegin(): Position {\n    return new Position(0, 0);\n  }\n\n  static getDocumentEnd(document: vscode.TextDocument): Position {\n    const line = Math.max(document.lineCount, 1) - 1;\n    return document.lineAt(line).range.end;\n  }\n\n  /**\n   * @returns the Position of the first character on the given line which is not whitespace.\n   * If it's all whitespace, will return the Position of the EOL character.\n   */\n  public static getFirstNonWhitespaceCharOnLine(\n    document: vscode.TextDocument,\n    line: number\n  ): Position {\n    line = clamp(line, 0, document.lineCount - 1);\n    return new Position(line, document.lineAt(line).firstNonWhitespaceCharacterIndex);\n  }\n\n  /**\n   * Iterate over every line in the block defined by the two positions (Range) passed in.\n   * If no range is given, the primary cursor will be used as the block.\n   *\n   * This is intended for visual block mode.\n   */\n  public static *iterateLinesInBlock(\n    vimState: VimState,\n    cursor?: Cursor,\n    options: { reverse?: boolean } = { reverse: false }\n  ): Iterable<{ line: string; start: Position; end: Position }> {\n    const { reverse } = options;\n\n    cursor ??= vimState.cursors[0];\n\n    const topLeft = visualBlockGetTopLeftPosition(cursor.start, cursor.stop);\n    const bottomRight = visualBlockGetBottomRightPosition(cursor.start, cursor.stop);\n\n    const [itrStart, itrEnd] = reverse\n      ? [bottomRight.line, topLeft.line]\n      : [topLeft.line, bottomRight.line];\n\n    const runToLineEnd = vimState.desiredColumn === Number.POSITIVE_INFINITY;\n\n    for (\n      let lineIndex = itrStart;\n      reverse ? lineIndex >= itrEnd : lineIndex <= itrEnd;\n      reverse ? lineIndex-- : lineIndex++\n    ) {\n      const line = vimState.document.lineAt(lineIndex).text;\n      const endCharacter = runToLineEnd\n        ? line.length + 1\n        : Math.min(line.length, bottomRight.character + 1);\n\n      yield {\n        line: line.substring(topLeft.character, endCharacter),\n        start: new Position(lineIndex, topLeft.character),\n        end: new Position(lineIndex, endCharacter),\n      };\n    }\n  }\n\n  /**\n   * Iterates through words on the same line, starting from the current position.\n   */\n  public static *iterateWords(\n    document: vscode.TextDocument,\n    start: Position\n  ): Iterable<{ start: Position; end: Position; word: string }> {\n    const text = document.lineAt(start).text;\n    if (/\\s/.test(text[start.character])) {\n      start = start.nextWordStart(document);\n    }\n    let wordEnd = start.nextWordEnd(document, { inclusive: true });\n    do {\n      const word = text.substring(start.character, wordEnd.character + 1);\n      yield {\n        start,\n        end: wordEnd,\n        word,\n      };\n\n      if (wordEnd.getRight().isLineEnd()) {\n        return;\n      }\n      start = start.nextWordStart(document);\n      wordEnd = start.nextWordEnd(document, { inclusive: true });\n    } while (true);\n  }\n}\n\n/**\n * Directions in the view for editor scroll command.\n */\nexport type EditorScrollDirection = 'up' | 'down';\n\n/**\n * Units for editor scroll 'by' argument\n */\nexport type EditorScrollByUnit = 'line' | 'wrappedLine' | 'page' | 'halfPage';\n\n/**\n * Positions in the view for cursor move command.\n */\nexport type CursorMovePosition =\n  | 'left'\n  | 'right'\n  | 'up'\n  | 'down'\n  | 'wrappedLineStart'\n  | 'wrappedLineFirstNonWhitespaceCharacter'\n  | 'wrappedLineColumnCenter'\n  | 'wrappedLineEnd'\n  | 'wrappedLineLastNonWhitespaceCharacter'\n  | 'viewPortTop'\n  | 'viewPortCenter'\n  | 'viewPortBottom'\n  | 'viewPortIfOutside';\n\n/**\n * Units for Cursor move 'by' argument\n */\nexport type CursorMoveByUnit = 'line' | 'wrappedLine' | 'character' | 'halfLine';\n","import { Position } from 'vscode';\nimport { TextEditor } from '../textEditor';\n\n/**\n * Get the end of the current paragraph.\n */\nexport function getCurrentParagraphEnd(pos: Position, trimWhite: boolean = false): Position {\n  const lastLine = TextEditor.getLineCount() - 1;\n\n  let line = pos.line;\n\n  // If we're not in a paragraph yet, go down until we are.\n  while (line < lastLine && isLineBlank(line, trimWhite)) {\n    line++;\n  }\n\n  // Go until we're outside of the paragraph, or at the end of the document.\n  while (line < lastLine && !isLineBlank(line, trimWhite)) {\n    line++;\n  }\n\n  return pos.with({ line }).getLineEnd();\n}\n\n/**\n * Get the beginning of the current paragraph.\n */\nexport function getCurrentParagraphBeginning(pos: Position, trimWhite: boolean = false): Position {\n  let line = pos.line;\n\n  // If we're not in a paragraph yet, go up until we are.\n  while (line > 0 && isLineBlank(line, trimWhite)) {\n    line--;\n  }\n\n  // Go until we're outside of the paragraph, or at the beginning of the document.\n  while (line > 0 && !isLineBlank(line, trimWhite)) {\n    line--;\n  }\n\n  return new Position(line, 0);\n}\n\nfunction isLineBlank(line: number, trimWhite: boolean = false): boolean {\n  const text = TextEditor.getLine(line).text;\n  return (trimWhite ? text.trim() : text) === '';\n}\n","import { Position } from 'vscode';\nimport { TextEditor } from '../textEditor';\nimport { getCurrentParagraphBeginning, getCurrentParagraphEnd } from './paragraph';\nimport { getAllPositions, getAllEndPositions } from './util';\n\nconst sentenceEndRegex = /[\\.!\\?]{1}([ \\n\\t]+|$)/g;\n\nexport function getSentenceBegin(position: Position, args: { forward: boolean }): Position {\n  if (args.forward) {\n    return getNextSentenceBegin(position);\n  } else {\n    return getPreviousSentenceBegin(position);\n  }\n}\n\nexport function getSentenceEnd(pos: Position): Position {\n  const paragraphEnd = getCurrentParagraphEnd(pos);\n  for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n    const allPositions = getAllPositions(TextEditor.getLine(currentLine).text, sentenceEndRegex);\n    const newCharacter = allPositions.find(\n      (index) => index > pos.character || currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return getFirstNonWhitespaceInParagraph(pos, paragraphEnd, false);\n}\n\nfunction getPreviousSentenceBegin(pos: Position): Position {\n  const paragraphBegin = getCurrentParagraphBeginning(pos);\n  for (let currentLine = pos.line; currentLine >= paragraphBegin.line; currentLine--) {\n    const endPositions = getAllEndPositions(TextEditor.getLine(currentLine).text, sentenceEndRegex);\n    const newCharacter = endPositions.reverse().find((index) => {\n      const newPositionBeforeThis = new Position(currentLine, index)\n        .getRightThroughLineBreaks()\n        .compareTo(pos);\n\n      return newPositionBeforeThis && (index < pos.character || currentLine < pos.line);\n    });\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter).getRightThroughLineBreaks();\n    }\n  }\n\n  if (paragraphBegin.line + 1 === pos.line || paragraphBegin.line === pos.line) {\n    return paragraphBegin;\n  } else {\n    return new Position(paragraphBegin.line + 1, 0);\n  }\n}\n\nfunction getNextSentenceBegin(pos: Position): Position {\n  // A paragraph and section boundary is also a sentence boundary.\n  const paragraphEnd = getCurrentParagraphEnd(pos);\n  for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n    const endPositions = getAllEndPositions(TextEditor.getLine(currentLine).text, sentenceEndRegex);\n    const newCharacter = endPositions.find(\n      (index) => index > pos.character || currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter).getRightThroughLineBreaks();\n    }\n  }\n\n  return getFirstNonWhitespaceInParagraph(pos, paragraphEnd, false);\n}\n\nfunction getFirstNonWhitespaceInParagraph(\n  pos: Position,\n  paragraphEnd: Position,\n  inclusive: boolean\n): Position {\n  // If the cursor is at an empty line, it's the end of a paragraph and the begin of another paragraph\n  // Find the first non-whitespace character.\n  if (TextEditor.getLine(pos.line).text) {\n    return paragraphEnd;\n  } else {\n    for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n      const nonWhitePositions = getAllPositions(TextEditor.getLine(currentLine).text, /\\S/g);\n      const newCharacter = nonWhitePositions.find(\n        (index) =>\n          (index > pos.character && !inclusive) ||\n          (index >= pos.character && inclusive) ||\n          currentLine !== pos.line\n      );\n\n      if (newCharacter !== undefined) {\n        return new Position(currentLine, newCharacter);\n      }\n    }\n  }\n\n  // Only happens at end of document\n  return pos;\n}\n","import { Cursor } from '../common/motion/cursor';\nimport { Mode } from '../mode/mode';\nimport { RegisterMode } from '../register/register';\nimport { VimState } from '../state/vimState';\nimport { TextEditor } from '../textEditor';\nimport { RegisterAction } from '../actions/base';\nimport { BaseMovement, IMovement, failedMovement } from '../actions/baseMotion';\nimport {\n  MoveAroundDoubleQuotes,\n  MoveAroundParentheses,\n  MoveAroundSingleQuotes,\n  MoveAroundSquareBracket,\n  MoveAroundBacktick,\n  MoveAroundTag,\n  ExpandingSelection,\n  MoveAroundCurlyBrace,\n} from '../actions/motion';\nimport { ChangeOperator } from '../actions/operator';\nimport { configuration } from '../configuration/configuration';\nimport { getCurrentParagraphBeginning, getCurrentParagraphEnd } from './paragraph';\nimport { Position, TextDocument } from 'vscode';\nimport { WordType } from './word';\n\nexport abstract class TextObject extends BaseMovement {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<IMovement> {\n    const res = await this.execAction(position, vimState);\n    // Since we need to handle leading spaces, we cannot use MoveWordBegin.execActionForOperator\n    // In normal mode, the character on the stop position will be the first character after the operator executed\n    // and we do left-shifting in operator-pre-execution phase, here we need to right-shift the stop position accordingly.\n    res.stop = new Position(res.stop.line, res.stop.character + 1);\n\n    return res;\n  }\n\n  public abstract override execAction(position: Position, vimState: VimState): Promise<IMovement>;\n}\n\n@RegisterAction\nexport class SelectWord extends TextObject {\n  keys = ['a', 'w'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n    const currentChar = TextEditor.getCharAt(vimState.document, position);\n\n    if (/\\s/.test(currentChar)) {\n      start = position.prevWordEnd(vimState.document).getRight();\n      stop = position.nextWordEnd(vimState.document);\n    } else {\n      stop = position.nextWordStart(vimState.document);\n      // If the next word is not at the beginning of the next line, we want to pretend it is.\n      // This is because 'aw' has two fundamentally different behaviors distinguished by whether\n      // the next word is directly after the current word, as described in the following comment.\n      // The only case that's not true is in cases like #1350.\n      if (stop.isEqual(TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, stop.line))) {\n        stop = stop.getLineBegin();\n      }\n      stop = stop.getLeftThroughLineBreaks().getLeftIfEOL();\n      // If we aren't separated from the next word by whitespace(like in \"horse ca|t,dog\" or at the end of the line)\n      // then we delete the spaces to the left of the current word. Otherwise, we delete to the right.\n      // Also, if the current word is the leftmost word, we only delete from the start of the word to the end.\n      if (\n        stop.isEqual(position.nextWordEnd(vimState.document, { inclusive: true })) &&\n        !position\n          .prevWordStart(vimState.document, { inclusive: true })\n          .isEqual(TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, stop.line)) &&\n        vimState.recordedState.count === 0\n      ) {\n        start = position.prevWordEnd(vimState.document).getRight();\n      } else {\n        start = position.prevWordStart(vimState.document, { inclusive: true });\n      }\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor position is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.prevWordStart(vimState.document, { inclusive: true });\n        } else {\n          stop = position.prevWordEnd(vimState.document).getRight();\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectABigWord extends TextObject {\n  keys = ['a', 'W'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n\n    const currentChar = vimState.document.lineAt(position).text[position.character];\n\n    if (/\\s/.test(currentChar)) {\n      start = position.prevWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n      stop = position.nextWordEnd(vimState.document, { wordType: WordType.Big });\n    } else {\n      // Check 'aw' code for much of the reasoning behind this logic.\n      const nextWord = position.nextWordStart(vimState.document, { wordType: WordType.Big });\n      if (\n        (nextWord.line > position.line || nextWord.isAtDocumentEnd()) &&\n        vimState.recordedState.count === 0\n      ) {\n        if (position.prevWordEnd(vimState.document, { wordType: WordType.Big }).isLineBeginning()) {\n          start = position.prevWordEnd(vimState.document, { wordType: WordType.Big });\n        } else {\n          start = position.prevWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n        }\n        stop = position.getLineEnd();\n      } else if (\n        (nextWord.isEqual(\n          TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, nextWord.line)\n        ) ||\n          nextWord.isLineEnd()) &&\n        vimState.recordedState.count === 0\n      ) {\n        start = position.prevWordEnd(vimState.document).getRight();\n        stop = position.getLineEnd();\n      } else {\n        start = position.prevWordStart(vimState.document, {\n          wordType: WordType.Big,\n          inclusive: true,\n        });\n        stop = position.nextWordStart(vimState.document, { wordType: WordType.Big }).getLeft();\n      }\n    }\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.prevWordStart(vimState.document, { wordType: WordType.Big });\n        } else {\n          stop = position.prevWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n/**\n * This is a custom action that I (johnfn) added. It selects procedurally\n * larger blocks. e.g. if you had \"blah (foo [bar 'ba|z'])\" then it would\n * select 'baz' first. If you pressed af again, it'd then select [bar 'baz'],\n * and if you did it a third time it would select \"(foo [bar 'baz'])\".\n *\n * Very similar is the now built-in `editor.action.smartSelect.expand`\n */\n@RegisterAction\nexport class SelectAnExpandingBlock extends ExpandingSelection {\n  keys = ['a', 'f'];\n  override modes = [Mode.Visual, Mode.VisualLine];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<IMovement> {\n    const blocks = [\n      new MoveAroundDoubleQuotes(),\n      new MoveAroundSingleQuotes(),\n      new MoveAroundBacktick(),\n      new MoveAroundCurlyBrace(),\n      new MoveAroundParentheses(),\n      new MoveAroundSquareBracket(),\n      new MoveAroundTag(),\n    ];\n    // ideally no state would change as we test each of the possible expansions\n    // a deep copy of vimState could work here but may be expensive\n    let ranges: IMovement[] = [];\n    for (const block of blocks) {\n      const cursorPos = new Position(position.line, position.character);\n      const cursorStartPos = new Position(\n        vimState.cursorStartPosition.line,\n        vimState.cursorStartPosition.character\n      );\n      ranges.push(await block.execAction(cursorPos, vimState, firstIteration, lastIteration));\n      vimState.cursorStartPosition = cursorStartPos;\n    }\n\n    ranges = ranges.filter((range) => {\n      return !range.failed;\n    });\n\n    let smallestRange: Cursor | undefined;\n\n    for (const iMotion of ranges) {\n      const currentSelectedRange = new Cursor(\n        vimState.cursorStartPosition,\n        vimState.cursorStopPosition\n      );\n      if (iMotion.failed) {\n        continue;\n      }\n\n      const range = new Cursor(iMotion.start, iMotion.stop);\n      let contender: Cursor | undefined;\n\n      if (\n        range.start.isBefore(currentSelectedRange.start) &&\n        range.stop.isAfter(currentSelectedRange.stop)\n      ) {\n        if (!smallestRange) {\n          contender = range;\n        } else {\n          if (range.start.isAfter(smallestRange.start) && range.stop.isBefore(smallestRange.stop)) {\n            contender = range;\n          }\n        }\n      }\n\n      if (contender) {\n        const areTheyEqual =\n          contender.equals(new Cursor(vimState.cursorStartPosition, vimState.cursorStopPosition)) ||\n          (vimState.currentMode === Mode.VisualLine &&\n            contender.start.line === vimState.cursorStartPosition.line &&\n            contender.stop.line === vimState.cursorStopPosition.line);\n\n        if (!areTheyEqual) {\n          smallestRange = contender;\n        }\n      }\n    }\n    if (!smallestRange) {\n      return {\n        start: vimState.cursorStartPosition,\n        stop: vimState.cursorStopPosition,\n      };\n    } else {\n      // revert relevant state changes\n      vimState.cursorStartPosition = new Position(\n        smallestRange.start.line,\n        smallestRange.start.character\n      );\n      vimState.cursorStopPosition = new Position(\n        smallestRange.stop.line,\n        smallestRange.stop.character\n      );\n      vimState.recordedState.operatorPositionDiff = undefined;\n      return {\n        start: smallestRange.start,\n        stop: smallestRange.stop,\n      };\n    }\n  }\n}\n\n@RegisterAction\nexport class SelectInnerWord extends TextObject {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = ['i', 'w'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n    const currentChar = vimState.document.lineAt(position).text[position.character];\n\n    if (/\\s/.test(currentChar)) {\n      start = position.prevWordEnd(vimState.document).getRight();\n      stop = position.nextWordStart(vimState.document).getLeftThroughLineBreaks();\n    } else {\n      start = position.prevWordStart(vimState.document, { inclusive: true });\n      stop = position.nextWordEnd(vimState.document, { inclusive: true });\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.prevWordEnd(vimState.document).getRight();\n        } else {\n          stop = position.prevWordStart(vimState.document, { inclusive: true });\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectInnerBigWord extends TextObject {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = ['i', 'W'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n    const currentChar = vimState.document.lineAt(position).text[position.character];\n\n    if (/\\s/.test(currentChar)) {\n      start = position.prevWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n      stop = position.nextWordStart(vimState.document, { wordType: WordType.Big }).getLeft();\n    } else {\n      start = position.prevWordStart(vimState.document, {\n        wordType: WordType.Big,\n        inclusive: true,\n      });\n      stop = position.nextWordEnd(vimState.document, {\n        wordType: WordType.Big,\n        inclusive: true,\n      });\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.prevWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n        } else {\n          stop = position.prevWordStart(vimState.document, { wordType: WordType.Big });\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectSentence extends TextObject {\n  keys = ['a', 's'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n\n    const currentSentenceBegin = position.getSentenceBegin({ forward: false });\n    const currentSentenceNonWhitespaceEnd = currentSentenceBegin.getSentenceEnd();\n\n    if (currentSentenceNonWhitespaceEnd.isBefore(position)) {\n      // The cursor is on a trailing white space.\n      start = currentSentenceNonWhitespaceEnd.getRight();\n      stop = currentSentenceBegin.getSentenceBegin({ forward: true }).getSentenceEnd();\n    } else {\n      const nextSentenceBegin = currentSentenceBegin.getSentenceBegin({ forward: true });\n\n      // If the sentence has no trailing white spaces, `as` should include its leading white spaces.\n      if (nextSentenceBegin.isEqual(currentSentenceBegin.getSentenceEnd())) {\n        start = currentSentenceBegin\n          .getSentenceBegin({ forward: false })\n          .getSentenceEnd()\n          .getRight();\n        stop = nextSentenceBegin;\n      } else {\n        start = currentSentenceBegin;\n        stop = nextSentenceBegin.getLeft();\n      }\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting sentences in reverser order.\n        if (currentSentenceNonWhitespaceEnd.isAfter(vimState.cursorStopPosition)) {\n          stop = currentSentenceBegin\n            .getSentenceBegin({ forward: false })\n            .getSentenceEnd()\n            .getRight();\n        } else {\n          stop = currentSentenceBegin;\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectInnerSentence extends TextObject {\n  keys = ['i', 's'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n\n    const currentSentenceBegin = position.getSentenceBegin({ forward: false });\n    const currentSentenceNonWhitespaceEnd = currentSentenceBegin.getSentenceEnd();\n\n    if (currentSentenceNonWhitespaceEnd.isBefore(position)) {\n      // The cursor is on a trailing white space.\n      start = currentSentenceNonWhitespaceEnd.getRight();\n      stop = currentSentenceBegin.getSentenceBegin({ forward: true }).getLeft();\n    } else {\n      start = currentSentenceBegin;\n      stop = currentSentenceNonWhitespaceEnd;\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting sentences in reverser order.\n        if (currentSentenceNonWhitespaceEnd.isAfter(vimState.cursorStopPosition)) {\n          stop = currentSentenceBegin;\n        } else {\n          stop = currentSentenceNonWhitespaceEnd.getRight();\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectParagraph extends TextObject {\n  keys = ['a', 'p'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    let start: Position;\n    const currentParagraphBegin = getCurrentParagraphBeginning(position, true);\n\n    if (vimState.document.lineAt(position).isEmptyOrWhitespace) {\n      // The cursor is at an empty line, it can be both the start of next paragraph and the end of previous paragraph\n      start = getCurrentParagraphEnd(getCurrentParagraphBeginning(position, true), true);\n    } else {\n      if (currentParagraphBegin.isLineBeginning() && currentParagraphBegin.isLineEnd()) {\n        start = currentParagraphBegin.getRightThroughLineBreaks();\n      } else {\n        start = currentParagraphBegin;\n      }\n    }\n\n    // Include additional blank lines.\n    let stop = getCurrentParagraphEnd(position, true);\n    while (\n      stop.line < vimState.document.lineCount - 1 &&\n      vimState.document.lineAt(stop.getDown()).isEmptyOrWhitespace\n    ) {\n      stop = stop.with({ character: 0 }).getDown();\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectInnerParagraph extends TextObject {\n  keys = ['i', 'p'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    let start: Position;\n    let stop: Position;\n\n    if (vimState.document.lineAt(position).isEmptyOrWhitespace) {\n      // The cursor is at an empty line, so white lines are the paragraph.\n      start = position.getLineBegin();\n      stop = position.getLineEnd();\n      while (start.line > 0 && vimState.document.lineAt(start.getUp()).isEmptyOrWhitespace) {\n        start = start.getUp();\n      }\n      while (\n        stop.line < vimState.document.lineCount - 1 &&\n        vimState.document.lineAt(stop.getDown()).isEmptyOrWhitespace\n      ) {\n        stop = stop.with({ character: 0 }).getDown();\n      }\n    } else {\n      const currentParagraphBegin = getCurrentParagraphBeginning(position, true);\n      stop = getCurrentParagraphEnd(position, true);\n      if (vimState.document.lineAt(currentParagraphBegin).isEmptyOrWhitespace) {\n        start = currentParagraphBegin.getRightThroughLineBreaks();\n      } else {\n        start = currentParagraphBegin;\n      }\n\n      // Exclude additional blank lines.\n      while (stop.line > 0 && vimState.document.lineAt(stop).isEmptyOrWhitespace) {\n        stop = stop.getUp().getLineEnd();\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectEntire extends TextObject {\n  keys = ['a', 'e'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    return {\n      start: TextEditor.getDocumentBegin(),\n      stop: TextEditor.getDocumentEnd(vimState.document),\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectEntireIgnoringLeadingTrailing extends TextObject {\n  keys = ['i', 'e'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position = TextEditor.getDocumentBegin();\n    let stop: Position = TextEditor.getDocumentEnd(vimState.document);\n\n    while (start.line < stop.line && vimState.document.lineAt(start).isEmptyOrWhitespace) {\n      start = start.getDown();\n    }\n\n    while (stop.line > start.line && vimState.document.lineAt(stop).isEmptyOrWhitespace) {\n      stop = stop.getUp();\n    }\n    stop = stop.getLineEnd();\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\nabstract class IndentObjectMatch extends TextObject {\n  override setsDesiredColumnToEOL = true;\n\n  protected includeLineAbove = false;\n  protected includeLineBelow = false;\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const isChangeOperator = vimState.recordedState.operator instanceof ChangeOperator;\n    const firstValidLineNumber = IndentObjectMatch.findFirstValidLine(vimState.document, position);\n    const firstValidLine = vimState.document.lineAt(firstValidLineNumber);\n    const cursorIndent = firstValidLine.firstNonWhitespaceCharacterIndex;\n\n    let startLineNumber = IndentObjectMatch.findRangeStartOrEnd(\n      vimState.document,\n      firstValidLineNumber,\n      cursorIndent,\n      -1\n    );\n    let endLineNumber = IndentObjectMatch.findRangeStartOrEnd(\n      vimState.document,\n      firstValidLineNumber,\n      cursorIndent,\n      1\n    );\n\n    // Adjust the start line as needed.\n    if (this.includeLineAbove) {\n      startLineNumber -= 1;\n    }\n    // Check for OOB.\n    if (startLineNumber < 0) {\n      startLineNumber = 0;\n    }\n\n    // Adjust the end line as needed.\n    if (this.includeLineBelow) {\n      endLineNumber += 1;\n    }\n    // Check for OOB.\n    if (endLineNumber > vimState.document.lineCount - 1) {\n      endLineNumber = vimState.document.lineCount - 1;\n    }\n\n    // If initiated by a change operation, adjust the cursor to the indent level\n    // of the block.\n    let startCharacter = 0;\n    if (isChangeOperator) {\n      startCharacter = vimState.document.lineAt(startLineNumber).firstNonWhitespaceCharacterIndex;\n    }\n    // TextEditor.getLineMaxColumn throws when given line 0, which we don't\n    // care about here since it just means this text object wouldn't work on a\n    // single-line document.\n    let endCharacter: number;\n    if (endLineNumber === vimState.document.lineCount - 1 || vimState.currentMode === Mode.Visual) {\n      endCharacter = TextEditor.getLineLength(endLineNumber);\n    } else {\n      endCharacter = 0;\n      endLineNumber++;\n    }\n    return {\n      start: new Position(startLineNumber, startCharacter),\n      stop: new Position(endLineNumber, endCharacter),\n    };\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<IMovement> {\n    return this.execAction(position, vimState);\n  }\n\n  /**\n   * Searches up from the cursor for the first non-empty line.\n   */\n  public static findFirstValidLine(document: TextDocument, cursorPosition: Position): number {\n    for (let i = cursorPosition.line; i >= 0; i--) {\n      if (!document.lineAt(i).isEmptyOrWhitespace) {\n        return i;\n      }\n    }\n\n    return cursorPosition.line;\n  }\n\n  /**\n   * Searches up or down from a line finding the first with a lower indent level.\n   */\n  public static findRangeStartOrEnd(\n    document: TextDocument,\n    startIndex: number,\n    cursorIndent: number,\n    step: -1 | 1\n  ): number {\n    let i = startIndex;\n    let ret = startIndex;\n    const end = step === 1 ? document.lineCount : -1;\n\n    for (; i !== end; i += step) {\n      const line = document.lineAt(i);\n      if (line.firstNonWhitespaceCharacterIndex < cursorIndent && !line.isEmptyOrWhitespace) {\n        break;\n      }\n\n      ret = i;\n    }\n\n    return ret;\n  }\n}\n\n@RegisterAction\nclass InsideIndentObject extends IndentObjectMatch {\n  keys = ['i', 'i'];\n}\n\n@RegisterAction\nclass InsideIndentObjectAbove extends IndentObjectMatch {\n  keys = ['a', 'i'];\n  override includeLineAbove = true;\n}\n\n@RegisterAction\nclass InsideIndentObjectBoth extends IndentObjectMatch {\n  keys = ['a', 'I'];\n  override includeLineAbove = true;\n  override includeLineBelow = true;\n}\n\nabstract class SelectArgument extends TextObject {\n  override modes = [Mode.Normal, Mode.Visual];\n\n  private static openingDelimiterCharacters(): string[] {\n    return configuration.argumentObjectOpeningDelimiters;\n  }\n  private static closingDelimiterCharacters(): string[] {\n    return configuration.argumentObjectClosingDelimiters;\n  }\n  private static separatorCharacters(): string[] {\n    return configuration.argumentObjectSeparators;\n  }\n\n  // SelectArgument supports two select types: inner and around.\n  //\n  // Inner will adjust start/stop positions, so that they are inside\n  // the delimiters (excluding the delimiters themselves).\n  // Around will adjust start/stop positions, so that ONE of them includes\n  // a separator character (optionally including extra whitespace).\n  protected selectAround = false;\n\n  // Requirement is that below example still works as expected, i.e.\n  // when we have nested pairs of parens\n  //\n  //        ( a, b, (void*) | c(void*, void*), a)\n  //\n  // Warning: For now, mismatched opening and closing delimiters, e.g.\n  // in (foo] will still be matched by this movement.\n  //\n  // Procedure:\n  //\n  // 1   Find boundaries left/right (i.e. where the argument starts/ends)\n  // 1.1 Walk left until we find a comma or an opening paren, that does not\n  //     have a matching closed one. This way we can ignore pairs\n  //     of parentheses which are part of the current argument.\n  // 1.2 Vice versa for walking right.\n  // 2   Depending on our mode (inner or around), improve the start/stop\n  //     locations for most consistent behaviour, especially in case of\n  //     multi-line statements.\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const failure = failedMovement(vimState);\n\n    let leftSearchStartPosition = position;\n    let rightSearchStartPosition = position;\n\n    const charAtPos = TextEditor.getCharAt(vimState.document, position);\n\n    // When the cursor is on a delimiter already, pre-advance the cursor,\n    // so that our search actually spans a range. We will advance to the next argument,\n    // in case of opening delimiters or separators, and advance to the\n    // previous on closing delimiters.\n    if (\n      SelectArgument.separatorCharacters().includes(charAtPos) ||\n      SelectArgument.openingDelimiterCharacters().includes(charAtPos)\n    ) {\n      rightSearchStartPosition = position.getRightThroughLineBreaks(true);\n    } else if (SelectArgument.closingDelimiterCharacters().includes(charAtPos)) {\n      leftSearchStartPosition = position.getLeftThroughLineBreaks(true);\n    }\n\n    // Early abort, if no delimiters (i.e. (), [], etc.) surround us.\n    // This prevents applying the movement to surrounding separators across the buffer.\n    if (\n      SelectInnerArgument.findLeftArgumentBoundary(\n        vimState.document,\n        leftSearchStartPosition,\n        true\n      ) === undefined ||\n      SelectInnerArgument.findRightArgumentBoundary(\n        vimState.document,\n        rightSearchStartPosition,\n        true\n      ) === undefined\n    ) {\n      return failure;\n    }\n\n    const leftArgumentBoundary = SelectInnerArgument.findLeftArgumentBoundary(\n      vimState.document,\n      leftSearchStartPosition\n    );\n    if (leftArgumentBoundary === undefined) {\n      return failure;\n    }\n\n    const rightArgumentBoundary = SelectInnerArgument.findRightArgumentBoundary(\n      vimState.document,\n      rightSearchStartPosition\n    );\n    if (rightArgumentBoundary === undefined) {\n      return failure;\n    }\n\n    let start: Position;\n    let stop: Position;\n\n    if (this.selectAround) {\n      const isLeftOnOpening: boolean = SelectArgument.openingDelimiterCharacters().includes(\n        TextEditor.getCharAt(vimState.document, leftArgumentBoundary)\n      );\n      const isRightOnClosing: boolean = SelectArgument.closingDelimiterCharacters().includes(\n        TextEditor.getCharAt(vimState.document, rightArgumentBoundary)\n      );\n\n      // Edge-case:\n      // Ensure we do not select anything if we have an empty argument list, e.g. \"()\"\n      const isEmptyArgumentList =\n        leftArgumentBoundary.getRight().isEqual(rightArgumentBoundary) &&\n        isLeftOnOpening &&\n        isRightOnClosing;\n      if (isEmptyArgumentList) {\n        return failure;\n      }\n\n      // Only when we are in the first argument we outset the right boundary\n      // until the first non-whitespace, so we do not end up with whitespace\n      // at the beginning of the parens.\n      const isInFirstArgument = isLeftOnOpening && !isRightOnClosing;\n      if (isInFirstArgument) {\n        stop = rightArgumentBoundary.getRight();\n        // Walk right until non-whitespace\n        while (/\\s/.test(TextEditor.getCharAt(vimState.document, stop.getRight()))) {\n          stop = stop.getRight();\n        }\n      } else {\n        // In any other case, we inset\n        stop = rightArgumentBoundary.getLeftThroughLineBreaks(true);\n      }\n\n      // In case the left boundary is on a opening delimiter, move that position inwards\n      if (isLeftOnOpening) {\n        start = leftArgumentBoundary.getRightThroughLineBreaks(true);\n      } else {\n        start = leftArgumentBoundary;\n      }\n    } else {\n      // Inset the start once to get off the boundary and then keep\n      // going until the first non whitespace.\n      // This ensures that indented argument-lists keep the indentation.\n      start = leftArgumentBoundary.getRightThroughLineBreaks(false);\n      while (/\\s/.test(TextEditor.getCharAt(vimState.document, start))) {\n        start = start.getRightThroughLineBreaks(false);\n      }\n\n      // Same procedure for stop.\n      stop = rightArgumentBoundary.getLeftThroughLineBreaks(false);\n      while (/\\s/.test(TextEditor.getCharAt(vimState.document, stop))) {\n        stop = stop.getLeftThroughLineBreaks(false);\n      }\n\n      // Edge-case: Seems there is only whitespace in this argument.\n      // Omit any weird handling and just clear all whitespace.\n      if (stop.isBeforeOrEqual(start)) {\n        start = leftArgumentBoundary.getRightThroughLineBreaks(true);\n        stop = rightArgumentBoundary.getLeftThroughLineBreaks(true);\n      }\n    }\n\n    // Handle case when cursor is not inside the anticipated movement range\n    if (position.isBefore(start)) {\n      vimState.recordedState.operatorPositionDiff = start.subtract(position);\n    }\n    vimState.cursorStartPosition = start;\n\n    return {\n      start,\n      stop,\n    };\n  }\n\n  private static findLeftArgumentBoundary(\n    document: TextDocument,\n    position: Position,\n    ignoreSeparators: boolean = false\n  ): Position | undefined {\n    let delimiterPosition: Position | undefined;\n    let walkingPosition = position;\n    let closedParensCount = 0;\n\n    while (true) {\n      const char = TextEditor.getCharAt(document, walkingPosition);\n      if (closedParensCount === 0) {\n        let isOnBoundary: boolean = SelectArgument.openingDelimiterCharacters().includes(char);\n        if (!ignoreSeparators) {\n          isOnBoundary ||= SelectArgument.separatorCharacters().includes(char);\n        }\n\n        if (isOnBoundary) {\n          // We have found the left most delimiter or the first proper delimiter\n          // in our cursor's list 'depth' and thus can abort.\n          delimiterPosition = walkingPosition;\n          break;\n        }\n      }\n      if (SelectArgument.closingDelimiterCharacters().includes(char)) {\n        closedParensCount++;\n      }\n      if (SelectArgument.openingDelimiterCharacters().includes(char)) {\n        closedParensCount--;\n      }\n\n      if (walkingPosition.isAtDocumentBegin()) {\n        break;\n      }\n\n      walkingPosition = walkingPosition.getLeftThroughLineBreaks(true);\n    }\n\n    return delimiterPosition;\n  }\n\n  private static findRightArgumentBoundary(\n    document: TextDocument,\n    position: Position,\n    ignoreSeparators: boolean = false\n  ): Position | undefined {\n    let delimiterPosition: Position | undefined;\n    let walkingPosition = position;\n    let openedParensCount = 0;\n\n    while (true) {\n      const char = TextEditor.getCharAt(document, walkingPosition);\n      if (openedParensCount === 0) {\n        let isOnBoundary: boolean = SelectArgument.closingDelimiterCharacters().includes(char);\n        if (!ignoreSeparators) {\n          isOnBoundary ||= SelectArgument.separatorCharacters().includes(char);\n        }\n\n        if (isOnBoundary) {\n          delimiterPosition = walkingPosition;\n          break;\n        }\n      }\n      if (SelectArgument.openingDelimiterCharacters().includes(char)) {\n        openedParensCount++;\n      }\n      if (SelectArgument.closingDelimiterCharacters().includes(char)) {\n        openedParensCount--;\n      }\n\n      if (walkingPosition.isAtDocumentEnd()) {\n        break;\n      }\n\n      // We need to include the EOL so that isAtDocumentEnd actually\n      // becomes true.\n      walkingPosition = walkingPosition.getRightThroughLineBreaks(true);\n    }\n\n    return delimiterPosition;\n  }\n}\n\n@RegisterAction\nexport class SelectInnerArgument extends SelectArgument {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = ['i', 'a'];\n}\n\n@RegisterAction\nexport class SelectAroundArgument extends SelectArgument {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = ['a', 'a'];\n  override selectAround = true;\n}\n","export function getAllPositions(line: string, regex: RegExp): number[] {\n  const positions: number[] = [];\n  let result = regex.exec(line);\n\n  while (result) {\n    positions.push(result.index);\n\n    // Handles the case where an empty string match causes lastIndex not to advance,\n    // which gets us in an infinite loop.\n    if (result.index === regex.lastIndex) {\n      regex.lastIndex++;\n    }\n    result = regex.exec(line);\n  }\n\n  return positions;\n}\n\nexport function getAllEndPositions(line: string, regex: RegExp): number[] {\n  const positions: number[] = [];\n  let result = regex.exec(line);\n\n  while (result) {\n    if (result[0].length) {\n      positions.push(result.index + result[0].length - 1);\n    }\n\n    // Handles the case where an empty string match causes lastIndex not to advance,\n    // which gets us in an infinite loop.\n    if (result.index === regex.lastIndex) {\n      regex.lastIndex++;\n    }\n    result = regex.exec(line);\n  }\n\n  return positions;\n}\n","import * as _ from 'lodash';\nimport { Position, TextDocument } from 'vscode';\nimport { configuration } from '../configuration/configuration';\nimport { getAllPositions, getAllEndPositions } from './util';\n\nexport enum WordType {\n  Normal,\n  Big,\n  CamelCase,\n  FileName,\n}\n\nconst nonWordCharRegex = makeUnicodeWordRegex(configuration.iskeyword);\nconst nonBigWordCharRegex = makeWordRegex('');\nconst nonCamelCaseWordCharRegex = makeCamelCaseWordRegex(configuration.iskeyword);\nconst nonFileNameRegex = makeWordRegex('\"\\'`;<>{}[]()');\n\nfunction regexForWordType(wordType: WordType): RegExp {\n  switch (wordType) {\n    case WordType.Normal:\n      return nonWordCharRegex;\n    case WordType.Big:\n      return nonBigWordCharRegex;\n    case WordType.CamelCase:\n      return nonCamelCaseWordCharRegex;\n    case WordType.FileName:\n      return nonFileNameRegex;\n  }\n}\n\n/**\n * Get the position of the word counting from the position specified.\n * @param text The string to search from.\n * @param pos The position of text to search from.\n * @returns The character position of the word to the left relative to the text and the pos.\n *          undefined if there is no word to the left of the postion.\n */\nexport function getWordLeftInText(\n  text: string,\n  pos: number,\n  wordType: WordType\n): number | undefined {\n  return getWordLeftOnLine(text, pos, wordType);\n}\n\nexport function getWordRightInText(\n  text: string,\n  pos: number,\n  wordType: WordType\n): number | undefined {\n  return getAllPositions(text, regexForWordType(wordType)).find((index) => index > pos);\n}\n\nexport function prevWordStart(\n  document: TextDocument,\n  pos: Position,\n  wordType: WordType,\n  inclusive: boolean = false\n): Position {\n  for (let currentLine = pos.line; currentLine >= 0; currentLine--) {\n    const newCharacter = getWordLeftOnLine(\n      document.lineAt(currentLine).text,\n      pos.character,\n      wordType,\n      currentLine !== pos.line,\n      inclusive\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(0, 0);\n}\n\nfunction getWordLeftOnLine(\n  text: string,\n  pos: number,\n  wordType: WordType,\n  forceFirst: boolean = false,\n  inclusive: boolean = false\n): number | undefined {\n  return getAllPositions(text, regexForWordType(wordType))\n    .reverse()\n    .find((index) => (index < pos && !inclusive) || (index <= pos && inclusive) || forceFirst);\n}\n\nexport function nextWordStart(\n  document: TextDocument,\n  pos: Position,\n  wordType: WordType,\n  inclusive: boolean = false\n): Position {\n  for (let currentLine = pos.line; currentLine < document.lineCount; currentLine++) {\n    const positions = getAllPositions(\n      document.lineAt(currentLine).text,\n      regexForWordType(wordType)\n    );\n    const newCharacter = positions.find(\n      (index) =>\n        (index > pos.character && !inclusive) ||\n        (index >= pos.character && inclusive) ||\n        currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(document.lineCount - 1, 0).getLineEnd();\n}\n\nexport function nextWordEnd(\n  document: TextDocument,\n  pos: Position,\n  wordType: WordType,\n  inclusive: boolean = false\n): Position {\n  for (let currentLine = pos.line; currentLine < document.lineCount; currentLine++) {\n    const positions = getAllEndPositions(\n      document.lineAt(currentLine).text,\n      regexForWordType(wordType)\n    );\n    const newCharacter = positions.find(\n      (index) =>\n        (index > pos.character && !inclusive) ||\n        (index >= pos.character && inclusive) ||\n        currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(document.lineCount - 1, 0).getLineEnd();\n}\n\nexport function prevWordEnd(document: TextDocument, pos: Position, wordType: WordType): Position {\n  for (let currentLine = pos.line; currentLine > -1; currentLine--) {\n    let positions = getAllEndPositions(\n      document.lineAt(currentLine).text,\n      regexForWordType(wordType)\n    );\n    // if one line is empty, use the 0 position as the default value\n    if (positions.length === 0) {\n      positions.push(0);\n    }\n    // reverse the list to find the biggest element smaller than pos.character\n    positions = positions.reverse();\n    const index = positions.findIndex((i) => i < pos.character || currentLine !== pos.line);\n    let newCharacter = 0;\n    if (index === -1) {\n      if (currentLine > -1) {\n        continue;\n      }\n      newCharacter = positions[positions.length - 1];\n    } else {\n      newCharacter = positions[index];\n    }\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(0, 0);\n}\n\nfunction makeWordRegex(characterSet: string): RegExp {\n  const escaped = characterSet && _.escapeRegExp(characterSet).replace(/-/g, '\\\\-');\n  const segments = [`([^\\\\s${escaped}]+)`, `[${escaped}]+`, `$^`];\n\n  return new RegExp(segments.join('|'), 'g');\n}\n\nfunction makeCamelCaseWordRegex(characterSet: string): RegExp {\n  const escaped = characterSet && _.escapeRegExp(characterSet).replace(/-/g, '\\\\-');\n  const segments: string[] = [];\n\n  // Older browsers don't support lookbehind - in this case, use an inferior regex rather than crashing\n  let supportsLookbehind = true;\n  try {\n    // tslint:disable-next-line\n    new RegExp('(?<=x)');\n  } catch {\n    supportsLookbehind = false;\n  }\n\n  // prettier-ignore\n  const firstSegment =\n      '(' +                                             // OPEN: group for matching camel case words\n      `[^\\\\s${escaped}]` +                              //   words can start with any word character\n      '(?:' +                                           //   OPEN: group for characters after initial char\n      `(?:${supportsLookbehind ? '(?<=[A-Z_])' : ''}` + //     If first char was a capital\n      `[A-Z](?=[\\\\sA-Z0-9${escaped}_]))+` +             //       the word can continue with all caps\n      '|' +                                             //     OR\n      `(?:${supportsLookbehind ? '(?<=[0-9_])' : ''}` + //     If first char was a digit\n      `[0-9](?=[\\\\sA-Z0-9${escaped}_]))+` +             //       the word can continue with all digits\n      '|' +                                             //     OR\n      `(?:${supportsLookbehind ? '(?<=[_])' : ''}` +    //     If first char was an underscore\n      `[_](?=[\\\\s${escaped}_]))+`  +                    //       the word can continue with all underscores\n      '|' +                                             //     OR\n      `[^\\\\sA-Z0-9${escaped}_]*` +                      //     Continue with regular characters\n      ')' +                                             //   END: group for characters after initial char\n      ')' +                                             // END: group for matching camel case words\n      '';\n\n  segments.push(firstSegment);\n  segments.push(`[${escaped}]+`);\n  segments.push(`$^`);\n\n  // it can be difficult to grok the behavior of the above regex\n  // feel free to check out https://regex101.com/r/mkVeiH/1 as a live example\n  return new RegExp(segments.join('|'), 'g');\n}\n\nfunction makeUnicodeWordRegex(keywordChars: string): RegExp {\n  // Distinct categories of characters\n  enum CharKind {\n    Punctuation,\n    Superscript,\n    Subscript,\n    Braille,\n    Ideograph,\n    Hiragana,\n    Katakana,\n    Hangul,\n  }\n\n  // List of printable characters (code point intervals) and their character kinds.\n  // Latin alphabets (e.g., ASCII alphabets and numbers,  Latin-1 Supplement, European Latin) are excluded.\n  // Imported from utf_class_buf in src/mbyte.c of Vim.\n  const symbolTable: Array<[[number, number], CharKind]> = [\n    [[0x00a1, 0x00bf], CharKind.Punctuation], // Latin-1 punctuation\n    [[0x037e, 0x037e], CharKind.Punctuation], // Greek question mark\n    [[0x0387, 0x0387], CharKind.Punctuation], // Greek ano teleia\n    [[0x055a, 0x055f], CharKind.Punctuation], // Armenian punctuation\n    [[0x0589, 0x0589], CharKind.Punctuation], // Armenian full stop\n    [[0x05be, 0x05be], CharKind.Punctuation],\n    [[0x05c0, 0x05c0], CharKind.Punctuation],\n    [[0x05c3, 0x05c3], CharKind.Punctuation],\n    [[0x05f3, 0x05f4], CharKind.Punctuation],\n    [[0x060c, 0x060c], CharKind.Punctuation],\n    [[0x061b, 0x061b], CharKind.Punctuation],\n    [[0x061f, 0x061f], CharKind.Punctuation],\n    [[0x066a, 0x066d], CharKind.Punctuation],\n    [[0x06d4, 0x06d4], CharKind.Punctuation],\n    [[0x0700, 0x070d], CharKind.Punctuation], // Syriac punctuation\n    [[0x0964, 0x0965], CharKind.Punctuation],\n    [[0x0970, 0x0970], CharKind.Punctuation],\n    [[0x0df4, 0x0df4], CharKind.Punctuation],\n    [[0x0e4f, 0x0e4f], CharKind.Punctuation],\n    [[0x0e5a, 0x0e5b], CharKind.Punctuation],\n    [[0x0f04, 0x0f12], CharKind.Punctuation],\n    [[0x0f3a, 0x0f3d], CharKind.Punctuation],\n    [[0x0f85, 0x0f85], CharKind.Punctuation],\n    [[0x104a, 0x104f], CharKind.Punctuation], // Myanmar punctuation\n    [[0x10fb, 0x10fb], CharKind.Punctuation], // Georgian punctuation\n    [[0x1361, 0x1368], CharKind.Punctuation], // Ethiopic punctuation\n    [[0x166d, 0x166e], CharKind.Punctuation], // Canadian Syl. punctuation\n    [[0x169b, 0x169c], CharKind.Punctuation],\n    [[0x16eb, 0x16ed], CharKind.Punctuation],\n    [[0x1735, 0x1736], CharKind.Punctuation],\n    [[0x17d4, 0x17dc], CharKind.Punctuation], // Khmer punctuation\n    [[0x1800, 0x180a], CharKind.Punctuation], // Mongolian punctuation\n    [[0x200c, 0x2027], CharKind.Punctuation], // punctuation and symbols\n    [[0x202a, 0x202e], CharKind.Punctuation], // punctuation and symbols\n    [[0x2030, 0x205e], CharKind.Punctuation], // punctuation and symbols\n    [[0x2060, 0x27ff], CharKind.Punctuation], // punctuation and symbols\n    [[0x2070, 0x207f], CharKind.Superscript], // superscript\n    [[0x2080, 0x2094], CharKind.Subscript], // subscript\n    [[0x20a0, 0x27ff], CharKind.Punctuation], // all kinds of symbols\n    [[0x2800, 0x28ff], CharKind.Braille], // braille\n    [[0x2900, 0x2998], CharKind.Punctuation], // arrows, brackets, etc.\n    [[0x29d8, 0x29db], CharKind.Punctuation],\n    [[0x29fc, 0x29fd], CharKind.Punctuation],\n    [[0x2e00, 0x2e7f], CharKind.Punctuation], // supplemental punctuation\n    [[0x3001, 0x3020], CharKind.Punctuation], // ideographic punctuation\n    [[0x3030, 0x3030], CharKind.Punctuation],\n    [[0x303d, 0x303d], CharKind.Punctuation],\n    [[0x3040, 0x309f], CharKind.Hiragana], // Hiragana\n    [[0x30a0, 0x30ff], CharKind.Katakana], // Katakana\n    [[0x3300, 0x9fff], CharKind.Ideograph], // CJK Ideographs\n    [[0xac00, 0xd7a3], CharKind.Hangul], // Hangul Syllables\n    [[0xf900, 0xfaff], CharKind.Ideograph], // CJK Ideographs\n    [[0xfd3e, 0xfd3f], CharKind.Punctuation],\n    [[0xfe30, 0xfe6b], CharKind.Punctuation], // punctuation forms\n    [[0xff00, 0xff0f], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0xff1a, 0xff20], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0xff3b, 0xff40], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0xff5b, 0xff65], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0x20000, 0x2a6df], CharKind.Ideograph], // CJK Ideographs\n    [[0x2a700, 0x2b73f], CharKind.Ideograph], // CJK Ideographs\n    [[0x2b740, 0x2b81f], CharKind.Ideograph], // CJK Ideographs\n    [[0x2f800, 0x2fa1f], CharKind.Ideograph], // CJK Ideographs\n  ];\n\n  const codePointRangePatterns: string[][] = [];\n  for (const kind in CharKind) {\n    if (!isNaN(Number(kind))) {\n      codePointRangePatterns[kind] = [];\n    }\n  }\n\n  for (const [[first, last], kind] of symbolTable) {\n    if (first === last) {\n      // '\\u{hhhh}'\n      codePointRangePatterns[kind].push(`\\\\u{${first.toString(16)}}`);\n    } else {\n      // '\\u{hhhh}-\\u{hhhh}'\n      codePointRangePatterns[kind].push(`\\\\u{${first.toString(16)}}-\\\\u{${last.toString(16)}}`);\n    }\n  }\n\n  // Symbols in vim.iskeyword or editor.wordSeparators\n  // are treated as CharKind.Punctuation\n  const escapedKeywordChars = _.escapeRegExp(keywordChars).replace(/-/g, '\\\\-');\n  codePointRangePatterns[Number(CharKind.Punctuation)].push(escapedKeywordChars);\n\n  const codePointRanges = codePointRangePatterns.map((patterns) => patterns.join(''));\n  const symbolSegments = codePointRanges.map((range) => `([${range}]+)`);\n\n  // wordSegment matches word characters.\n  // A word character is a symbol which is neither\n  // - space\n  // - a symbol listed in the table\n  // - a keyword (vim.iskeyword)\n  const wordSegment = `([^\\\\s${codePointRanges.join('')}]+)`;\n\n  // https://regex101.com/r/X1agK6/2\n  const segments = symbolSegments.concat(wordSegment, '$^');\n  return new RegExp(segments.join('|'), 'ug');\n}\n","import * as vscode from 'vscode';\nimport { Logger } from '../util/logger';\nimport {\n  isTextTransformation,\n  TextTransformations,\n  Transformation,\n  isMultiCursorTextTransformation,\n  InsertTextVSCodeTransformation,\n  areAllSameTransformation,\n  overlappingTransformations,\n} from './transformations';\nimport { commandLine } from '../cmd_line/commandLine';\nimport { PositionDiff } from '../common/motion/position';\nimport { VimError, ErrorCode } from '../error';\nimport { Mode } from '../mode/mode';\nimport { Register } from '../register/register';\nimport { globalState } from '../state/globalState';\nimport { RecordedState } from '../state/recordedState';\nimport { TextEditor } from '../textEditor';\nimport { reportSearch } from '../util/statusBarTextUtils';\nimport { Cursor } from '../common/motion/cursor';\nimport { Position } from 'vscode';\nimport { VimState } from '../state/vimState';\nimport { Transformer } from './transformer';\nimport { Globals } from '../globals';\n\nexport interface IModeHandler {\n  vimState: VimState;\n\n  updateView(args?: { drawSelection: boolean; revealRange: boolean }): Promise<void>;\n  runMacro(recordedMacro: RecordedState): Promise<void>;\n  handleMultipleKeyEvents(keys: string[]): Promise<void>;\n  rerunRecordedState(recordedState: RecordedState): Promise<void>;\n}\n\nconst logger = Logger.get('Parser');\n\nexport async function executeTransformations(\n  modeHandler: IModeHandler,\n  transformations: Transformation[]\n) {\n  if (transformations.length === 0) {\n    return;\n  }\n\n  const vimState = modeHandler.vimState;\n\n  const textTransformations: TextTransformations[] = transformations.filter((x) =>\n    isTextTransformation(x)\n  ) as any;\n  const multicursorTextTransformations: InsertTextVSCodeTransformation[] = transformations.filter(\n    (x) => isMultiCursorTextTransformation(x)\n  ) as any;\n\n  const otherTransformations = transformations.filter(\n    (x) => !isTextTransformation(x) && !isMultiCursorTextTransformation(x)\n  );\n\n  const accumulatedPositionDifferences: { [key: number]: PositionDiff[] } = {};\n\n  const doTextEditorEdit = (command: TextTransformations, edit: vscode.TextEditorEdit) => {\n    switch (command.type) {\n      case 'insertText':\n        edit.insert(command.position, command.text);\n        break;\n      case 'replaceText':\n        edit.replace(command.range, command.text);\n        break;\n      case 'deleteRange':\n        edit.delete(command.range);\n        break;\n      case 'moveCursor':\n        break;\n      default:\n        logger.warn(`Unhandled text transformation type: ${command.type}.`);\n        break;\n    }\n\n    if (command.diff) {\n      if (command.cursorIndex === undefined) {\n        throw new Error('No cursor index - this should never ever happen!');\n      }\n\n      if (!accumulatedPositionDifferences[command.cursorIndex]) {\n        accumulatedPositionDifferences[command.cursorIndex] = [];\n      }\n\n      accumulatedPositionDifferences[command.cursorIndex].push(command.diff);\n    }\n  };\n\n  if (textTransformations.length > 0) {\n    const overlapping = overlappingTransformations(textTransformations);\n    if (overlapping !== undefined) {\n      const msg = `Transformations overlapping: ${JSON.stringify(overlapping)}`;\n      logger.warn(msg);\n      if (Globals.isTesting) {\n        throw new Error(msg);\n      }\n\n      // TODO: Select one transformation for every cursor and run them all\n      // in parallel. Repeat till there are no more transformations.\n      for (const transformation of textTransformations) {\n        await vimState.editor.edit((edit) => doTextEditorEdit(transformation, edit));\n      }\n    } else {\n      // This is the common case!\n\n      /**\n       * batch all text operations together as a single operation\n       * (this is primarily necessary for multi-cursor mode, since most\n       * actions will trigger at most one text operation).\n       */\n      try {\n        await vimState.editor.edit((edit) => {\n          for (const command of textTransformations) {\n            doTextEditorEdit(command, edit);\n          }\n        });\n      } catch (e) {\n        // Messages like \"TextEditor(vs.editor.ICodeEditor:1,$model8) has been disposed\" can be ignored.\n        // They occur when the user switches to a new tab while an action is running.\n        if (e.name !== 'DISPOSED') {\n          e.context = {\n            currentMode: Mode[vimState.currentMode],\n            cursors: vimState.cursors.map((cursor) => cursor.toString()),\n            actionsRunPressedKeys: vimState.recordedState.actionsRunPressedKeys,\n            actionsRun: vimState.recordedState.actionsRun.map((action) => action.constructor.name),\n            textTransformations,\n          };\n          throw e;\n        }\n      }\n    }\n  }\n\n  if (multicursorTextTransformations.length > 0) {\n    if (areAllSameTransformation(multicursorTextTransformations)) {\n      /**\n       * Apply the transformation only once instead of to each cursor\n       * if they are all the same.\n       *\n       * This lets VSCode do multicursor snippets, auto braces and\n       * all the usual jazz VSCode does on text insertion.\n       */\n      const { text } = multicursorTextTransformations[0];\n\n      // await vscode.commands.executeCommand('default:type', { text });\n      await TextEditor.insert(vimState.editor, text);\n    } else {\n      logger.warn(`Unhandled multicursor transformations. Not all transformations are the same!`);\n    }\n  }\n\n  for (const transformation of otherTransformations) {\n    switch (transformation.type) {\n      case 'insertTextVSCode':\n        await TextEditor.insert(vimState.editor, transformation.text);\n        vimState.cursors[0] = Cursor.FromVSCodeSelection(vimState.editor.selection);\n        break;\n\n      case 'deleteLeft':\n        await vscode.commands.executeCommand('deleteLeft');\n        break;\n\n      case 'deleteRight':\n        await vscode.commands.executeCommand('deleteRight');\n        break;\n\n      case 'showCommandHistory':\n        const cmd = await commandLine.showHistory(vimState.currentCommandlineText);\n        if (cmd && cmd.length !== 0) {\n          await commandLine.Run(cmd, vimState);\n          modeHandler.updateView();\n        }\n        break;\n\n      case 'showSearchHistory':\n        const searchState = await globalState.showSearchHistory();\n        if (searchState) {\n          globalState.searchState = searchState;\n          const nextMatch = searchState.getNextSearchMatchPosition(\n            vimState.editor,\n            vimState.cursorStartPosition,\n            transformation.direction\n          );\n\n          if (!nextMatch) {\n            throw VimError.fromCode(\n              transformation.direction > 0 ? ErrorCode.SearchHitBottom : ErrorCode.SearchHitTop,\n              searchState.searchString\n            );\n          }\n\n          vimState.cursorStopPosition = nextMatch.pos;\n          modeHandler.updateView();\n          reportSearch(\n            nextMatch.index,\n            searchState.getMatchRanges(vimState.editor).length,\n            vimState\n          );\n        }\n        break;\n\n      case 'replayRecordedState':\n        await modeHandler.rerunRecordedState(transformation.recordedState.clone());\n        break;\n\n      case 'macro':\n        const recordedMacro = (await Register.get(transformation.register))?.text;\n        if (!(recordedMacro instanceof RecordedState)) {\n          return;\n        }\n\n        vimState.isReplayingMacro = true;\n\n        vimState.recordedState = new RecordedState();\n        if (transformation.register === ':') {\n          await commandLine.Run(recordedMacro.commandString, vimState);\n        } else if (transformation.replay === 'contentChange') {\n          await modeHandler.runMacro(recordedMacro);\n        } else {\n          let keyStrokes: string[] = [];\n          for (const action of recordedMacro.actionsRun) {\n            keyStrokes = keyStrokes.concat(action.keysPressed);\n          }\n          await modeHandler.handleMultipleKeyEvents(keyStrokes);\n        }\n\n        await executeTransformations(\n          modeHandler,\n          vimState.recordedState.transformer.transformations\n        );\n\n        vimState.isReplayingMacro = false;\n        vimState.lastInvokedMacro = recordedMacro;\n\n        if (vimState.lastMovementFailed) {\n          // movement in last invoked macro failed then we should stop all following repeating macros.\n          // Besides, we should reset `lastMovementFailed`.\n          vimState.lastMovementFailed = false;\n          return;\n        }\n        break;\n\n      case 'contentChange':\n        for (const change of transformation.changes) {\n          await TextEditor.insert(vimState.editor, change.text);\n          vimState.cursorStopPosition = vimState.editor.selection.start;\n        }\n        const newPos = vimState.cursorStopPosition.add(vimState.document, transformation.diff);\n        vimState.editor.selection = new vscode.Selection(newPos, newPos);\n        break;\n\n      case 'tab':\n        await vscode.commands.executeCommand('tab');\n        if (transformation.diff) {\n          if (transformation.cursorIndex === undefined) {\n            throw new Error('No cursor index - this should never ever happen!');\n          }\n\n          if (!accumulatedPositionDifferences[transformation.cursorIndex]) {\n            accumulatedPositionDifferences[transformation.cursorIndex] = [];\n          }\n\n          accumulatedPositionDifferences[transformation.cursorIndex].push(transformation.diff);\n        }\n        break;\n\n      case 'reindent':\n        await vscode.commands.executeCommand('editor.action.reindentselectedlines');\n        if (transformation.diff) {\n          if (transformation.cursorIndex === undefined) {\n            throw new Error('No cursor index - this should never ever happen!');\n          }\n\n          if (!accumulatedPositionDifferences[transformation.cursorIndex]) {\n            accumulatedPositionDifferences[transformation.cursorIndex] = [];\n          }\n\n          accumulatedPositionDifferences[transformation.cursorIndex].push(transformation.diff);\n        }\n        break;\n\n      default:\n        logger.warn(`Unhandled text transformation type: ${transformation.type}.`);\n        break;\n    }\n  }\n\n  const selections = vimState.editor.selections.map((sel) => {\n    let range = Cursor.FromVSCodeSelection(sel);\n    if (range.start.isBefore(range.stop)) {\n      range = range.withNewStop(range.stop.getLeftThroughLineBreaks(true));\n    }\n    return new vscode.Selection(range.start, range.stop);\n  });\n  const firstTransformation = transformations[0];\n  const manuallySetCursorPositions =\n    (firstTransformation.type === 'deleteRange' ||\n      firstTransformation.type === 'replaceText' ||\n      firstTransformation.type === 'insertText') &&\n    firstTransformation.manuallySetCursorPositions;\n\n  // We handle multiple cursors in a different way in visual block mode, unfortunately.\n  // TODO - refactor that out!\n  if (vimState.currentMode !== Mode.VisualBlock && !manuallySetCursorPositions) {\n    vimState.cursors = selections.map((sel, idx) => {\n      const diffs = accumulatedPositionDifferences[idx] ?? [];\n      if (vimState.recordedState.operatorPositionDiff) {\n        diffs.push(vimState.recordedState.operatorPositionDiff);\n      }\n\n      return diffs.reduce(\n        (cursor, diff) =>\n          new Cursor(\n            cursor.start.add(vimState.document, diff),\n            cursor.stop.add(vimState.document, diff)\n          ),\n        Cursor.FromVSCodeSelection(sel)\n      );\n    });\n\n    vimState.recordedState.operatorPositionDiff = undefined;\n  } else if (accumulatedPositionDifferences[0]?.length > 0) {\n    const diff = accumulatedPositionDifferences[0][0];\n    vimState.cursorStopPosition = vimState.cursorStopPosition.add(vimState.document, diff);\n    vimState.cursorStartPosition = vimState.cursorStartPosition.add(vimState.document, diff);\n  }\n\n  /**\n   * This is a bit of a hack because Visual Block Mode isn't fully on board with\n   * the new text transformation style yet.\n   *\n   * (TODO)\n   */\n  if (firstTransformation.type === 'deleteRange') {\n    if (firstTransformation.collapseRange) {\n      vimState.cursorStopPosition = new Position(\n        vimState.cursorStopPosition.line,\n        vimState.cursorStartPosition.character\n      );\n    }\n  }\n\n  vimState.recordedState.transformer = new Transformer();\n}\n","import { Position, Range, TextDocumentContentChangeEvent } from 'vscode';\nimport { RecordedState } from '../state/recordedState';\nimport { PositionDiff } from './../common/motion/position';\n\n/**\n * This file contains definitions of objects that represent text\n * additions/deletions/replacements on the document. You'll add them\n * to vimState.recordedState.transformer.transformations and then they will be applied\n * later on.\n *\n * We do it in this way so they can all be processed in parallel and merged\n * if necessary.\n */\n\n/**\n * Represents inserting text at a position in the document.\n */\nexport interface InsertTextTransformation {\n  /**\n   * Type of this insertion (used for type checking with discriminated\n   * union types).\n   */\n  type: 'insertText';\n\n  /**\n   * Text content of this insertion.\n   */\n  text: string;\n\n  /**\n   * The location to insert the text.\n   */\n  position: Position;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n\n  manuallySetCursorPositions?: boolean;\n}\n\nexport interface ReplaceTextTransformation {\n  type: 'replaceText';\n\n  /**\n   * Text to insert.\n   */\n  text: string;\n\n  /**\n   * Range of characters to replace.\n   */\n  range: Range;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n\n  /**\n   * Please don't use this! It's a hack.\n   */\n  manuallySetCursorPositions?: boolean;\n}\n\n/**\n * Represents inserting a character and allowing visual studio to do\n * its post-character stuff if it wants. (e.g., if you type \"(\" this\n * will automatically add the closing \")\").\n */\nexport interface InsertTextVSCodeTransformation {\n  type: 'insertTextVSCode';\n\n  /**\n   * Text to insert.\n   */\n  text: string;\n\n  /**\n   * Whether this transformation was created in multicursor mode.\n   */\n  isMultiCursor?: boolean;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n}\n\n/**\n * <BS>\n */\nexport interface DeleteLeft {\n  type: 'deleteLeft';\n}\n\n/**\n * <Del>\n */\nexport interface DeleteRight {\n  type: 'deleteRight';\n}\n\n/**\n * Represents deleting a range of characters.\n */\nexport interface DeleteTextRangeTransformation {\n  type: 'deleteRange';\n\n  /**\n   * Range of characters to delete.\n   */\n  range: Range;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n\n  collapseRange?: boolean;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * Please don't use this! It's a hack.\n   */\n  manuallySetCursorPositions?: boolean;\n}\n\nexport interface MoveCursorTransformation {\n  type: 'moveCursor';\n\n  cursorIndex?: number;\n\n  /**\n   * Move the cursor this much.\n   */\n  diff: PositionDiff;\n}\n\n/**\n * Represents pressing ':'\n */\nexport interface ShowCommandHistory {\n  type: 'showCommandHistory';\n}\n\nexport interface ShowSearchHistory {\n  type: 'showSearchHistory';\n  direction: number;\n}\n\n/**\n * Replays a RecordedState. Used for `.`, primarily.\n */\nexport interface Dot {\n  type: 'replayRecordedState';\n  recordedState: RecordedState;\n}\n\n/**\n * Represents Tab\n */\nexport interface Tab {\n  type: 'tab';\n  cursorIndex?: number;\n\n  /**\n   * Move the cursor this much.\n   */\n  diff?: PositionDiff;\n}\n\n/**\n * Represents reindenting the selected line\n */\nexport interface Reindent {\n  type: 'reindent';\n  cursorIndex?: number;\n\n  /**\n   * Move the cursor this much.\n   */\n  diff?: PositionDiff;\n}\n\n/**\n * Represents macro\n */\nexport interface Macro {\n  type: 'macro';\n  register: string;\n  replay: 'contentChange' | 'keystrokes';\n}\n\n/**\n * Represents updating document content changes\n */\nexport interface ContentChangeTransformation {\n  type: 'contentChange';\n  changes: TextDocumentContentChangeEvent[];\n  diff: PositionDiff;\n}\n\nexport type Transformation =\n  | InsertTextTransformation\n  | InsertTextVSCodeTransformation\n  | ReplaceTextTransformation\n  | DeleteTextRangeTransformation\n  | DeleteLeft\n  | DeleteRight\n  | MoveCursorTransformation\n  | ShowCommandHistory\n  | ShowSearchHistory\n  | Dot\n  | Macro\n  | ContentChangeTransformation\n  | Tab\n  | Reindent;\n\n/**\n * Text Transformations\n *\n * Using these indicates that you want Visual Studio Code to execute your text\n * actions as a batch operation. It's a bit tricky because we defer cursor updating\n * behavior to whatever the batch operation returns, so if you update the cursor in your\n * Action, VSCode will override whatever you did.\n *\n * If your cursor isn't ending up in the right place, you can adjust it by passing along\n * a PositionDiff.\n *\n * (There are a LOT of weird edge cases with cursor behavior that we don't want to have to reimplement. Trust\n * me... I tried.)\n */\nexport type TextTransformations =\n  | InsertTextTransformation\n  | InsertTextVSCodeTransformation\n  | DeleteTextRangeTransformation\n  | MoveCursorTransformation\n  | ReplaceTextTransformation;\n\nexport const isTextTransformation = (x: Transformation): x is TextTransformations => {\n  return (\n    x.type === 'insertText' ||\n    x.type === 'replaceText' ||\n    x.type === 'deleteRange' ||\n    x.type === 'moveCursor'\n  );\n};\nexport const isMultiCursorTextTransformation = (x: Transformation): boolean => {\n  return (x.type === 'insertTextVSCode' && x.isMultiCursor) ?? false;\n};\n\nconst getRangeFromTextTransformation = (transformation: TextTransformations): Range | undefined => {\n  switch (transformation.type) {\n    case 'insertText':\n      return new Range(\n        transformation.position,\n        transformation.position.advancePositionByText(transformation.text)\n      );\n    case 'replaceText':\n      // TODO: Do we need to do the same sort of thing here as for insertText?\n      return transformation.range;\n    case 'deleteRange':\n      return transformation.range;\n    case 'moveCursor':\n      return undefined;\n  }\n\n  throw new Error('Unhandled text transformation: ' + transformation);\n};\n\nexport function overlappingTransformations(\n  transformations: TextTransformations[]\n): [TextTransformations, TextTransformations] | undefined {\n  for (let i = 0; i < transformations.length; i++) {\n    for (let j = i + 1; j < transformations.length; j++) {\n      const first = transformations[i];\n      const second = transformations[j];\n\n      const firstRange = getRangeFromTextTransformation(first);\n      const secondRange = getRangeFromTextTransformation(second);\n\n      if (!firstRange || !secondRange) {\n        continue;\n      }\n\n      const intersection = firstRange.intersection(secondRange);\n      if (intersection && !intersection.start.isEqual(intersection.end)) {\n        return [first, second];\n      }\n    }\n  }\n\n  return undefined;\n}\n\nexport const areAllSameTransformation = (transformations: Transformation[]): boolean => {\n  const firstTransformation = transformations[0];\n\n  return transformations.every((t) => {\n    return Object.entries(t).every(([key, value]) => {\n      return firstTransformation[key] === value;\n    });\n  });\n};\n\nexport function stringify(transformation: Transformation): string {\n  if (transformation.type === 'replayRecordedState') {\n    return `Replay: ${transformation.recordedState.actionsRun\n      .map((x) => x.keysPressed.join(''))\n      .join('')}`;\n  } else {\n    return JSON.stringify(transformation);\n  }\n}\n","import { Position, Range } from 'vscode';\nimport { PositionDiff } from '../common/motion/position';\nimport { Logger } from '../util/logger';\nimport { stringify, Transformation } from './transformations';\n\nexport class Transformer {\n  public readonly transformations: Transformation[] = [];\n\n  private logger = Logger.get('Transformer');\n\n  public addTransformation(transformation: Transformation): void {\n    this.logger.debug(`Adding Transformation ${stringify(transformation)}`);\n    this.transformations.push(transformation);\n  }\n\n  public insert(position: Position, text: string, diff?: PositionDiff): void {\n    this.addTransformation({ type: 'insertText', position, text, diff });\n  }\n\n  public delete(range: Range, diff?: PositionDiff): void {\n    this.addTransformation({ type: 'deleteRange', range, diff });\n  }\n\n  public replace(range: Range, text: string, diff?: PositionDiff): void {\n    this.addTransformation({ type: 'replaceText', range, text, diff });\n  }\n}\n","import * as vscode from 'vscode';\nimport { Logger } from './logger';\n\n/**\n * A thin wrapper around `vscode.env.clipboard`\n */\nexport class Clipboard {\n  private static readonly logger = Logger.get('Clipboard');\n\n  public static async Copy(text: string): Promise<void> {\n    try {\n      await vscode.env.clipboard.writeText(text);\n    } catch (e) {\n      this.logger.error(`Error copying to clipboard. err=${e}`);\n    }\n  }\n\n  public static async Paste(): Promise<string> {\n    return vscode.env.clipboard.readText();\n  }\n}\n","import { readFileAsync, writeFileAsync, unlink } from 'platform/fs';\nimport { tmpdir } from '../util/os';\nimport { join } from '../util/path';\nimport { VimError, ErrorCode } from '../error';\nimport { promisify } from 'util';\nimport * as process from 'process';\n\nclass ExternalCommand {\n  private previousExternalCommand: string | undefined;\n\n  private getRandomFileName(): string {\n    return Math.random()\n      .toString(36)\n      .replace(/[^a-z]+/g, '')\n      .substr(0, 10);\n  }\n\n  /**\n   * Expands the given command by replacing any '!' with the previous external\n   * command. The '!' can be escaped if there is a backslash preceeding the\n   * '!', then the backslash is removed and the '!' is kept.\n   *\n   * If a '!' is present but there is no previous external command, then a\n   * VimError is thrown.\n   * @param command the command to expand\n   */\n  private expandCommand(command: string): string {\n    const result: string[] = [];\n\n    for (let i = 0; i < command.length; i++) {\n      if (command[i] === '!') {\n        if (i > 0 && command[i - 1] === '\\\\') {\n          // escape the '!' and keep it\n          result.pop();\n          result.push('!');\n        } else if (!this.previousExternalCommand) {\n          // no previous command available to substitute\n          throw VimError.fromCode(ErrorCode.NoPreviousCommand);\n        } else {\n          result.push(this.previousExternalCommand);\n        }\n      } else {\n        result.push(command[i]);\n      }\n    }\n    return result.join('');\n  }\n\n  /**\n   * Creates a shell command from a command string, and redirects stdin and\n   * stdout/stderr to the given input/output files.\n   *\n   * @param command the command to redirect\n   * @param inputFile path to the input file\n   * @param outputFile path to the output file\n   */\n  private redirectCommand(command: string, inputFile: string, outputFile: string): string {\n    let result: string;\n    if (process.platform === 'win32') {\n      // need to put the '<' redirection after the first command in the pipe\n      const pipeIndex = command.indexOf('|');\n\n      if (pipeIndex !== -1) {\n        const firstCommand = command.slice(0, pipeIndex);\n        const restOfCommand = command.slice(pipeIndex);\n        result = `${firstCommand} < ${inputFile} ${restOfCommand} > ${outputFile}`;\n      } else {\n        result = `${command} < ${inputFile} > ${outputFile}`;\n      }\n    } else if (process.env.SHELL === 'fish') {\n      result = `begin; ${command}; end < ${inputFile} > ${outputFile}`;\n    } else {\n      result = `(${command}) < ${inputFile} > ${outputFile}`;\n    }\n\n    // combines stdout and stderr (compatible for all platforms)\n    result += ' 2>&1';\n    return result;\n  }\n\n  /**\n   * Runs the given command and returns the output (stdout and stderr).\n   * Optionally, `stdin` can be piped into stdin during execution.\n   *\n   * @param command the command to run\n   * @param stdin string to pipe into stdin, by default the empty string\n   */\n  public async run(command: string, stdin: string = ''): Promise<string> {\n    const inputFile = join(tmpdir(), this.getRandomFileName());\n    const outputFile = join(tmpdir(), this.getRandomFileName());\n    let result = '';\n\n    try {\n      await writeFileAsync(inputFile, stdin, 'utf8');\n\n      command = this.expandCommand(command);\n      this.previousExternalCommand = command;\n      command = this.redirectCommand(command, inputFile, outputFile);\n      try {\n        await import('child_process').then((cp) => {\n          return promisify(cp.exec)(command);\n        });\n      } catch (e) {\n        // exec throws an error if exit code != 0\n        // keep going and read the output anyway (just like vim)\n      }\n\n      result = await readFileAsync(outputFile, 'utf8');\n      // vim behavior: always trim newlines\n      if (result.endsWith('\\n')) {\n        result = result.slice(0, -1);\n      }\n    } finally {\n      // always delete tmp files at the end\n      await unlink(inputFile);\n      await unlink(outputFile);\n    }\n\n    return result;\n  }\n}\n\nexport const externalCommand = new ExternalCommand();\n","import { ILogger } from 'src/platform/common/logger';\nimport { LoggerImpl } from 'platform/loggerImpl';\nimport { IConfiguration } from 'src/configuration/iconfiguration';\n\nexport class Logger {\n  private static readonly cache = new Map<string, ILogger>();\n  private static configuration: IConfiguration | undefined = undefined;\n\n  static get(prefix: string): ILogger {\n    let logger = Logger.cache.get(prefix);\n    if (logger === undefined) {\n      logger = LoggerImpl.get(prefix);\n      if (Logger.configuration) {\n        logger.configChanged(Logger.configuration);\n      }\n      Logger.cache.set(prefix, logger);\n    }\n\n    return logger;\n  }\n\n  static configChanged(configuration: IConfiguration) {\n    Logger.configuration = configuration;\n    for (const logger of this.cache.values()) {\n      logger.configChanged(configuration);\n    }\n  }\n}\n","import * as os from 'os';\n\nexport function tmpdir(): string {\n  return os.tmpdir();\n}\n","import * as vscode from 'vscode';\nimport * as path from 'path';\nimport untildify = require('untildify');\n\n/**\n * A interface to the path in the node.js.\n */\ninterface Path {\n  normalize(p: string): string;\n  join(...paths: string[]): string;\n  resolve(...pathSegments: string[]): string;\n  isAbsolute(p: string): boolean;\n  relative(from: string, to: string): string;\n  dirname(p: string): string;\n  basename(p: string, ext?: string): string;\n  extname(p: string): string;\n  sep: string;\n  delimiter: string;\n}\n\n/**\n * Separate a partial path or full path into dirname and the basename.\n * @param searchPath The path to separate.\n * @param sep The separator of the searchPath.\n * @return A two-element array where the first element is the dirname and the second\n * is the basename.\n */\nexport function separatePath(searchPath: string, sep: string) {\n  // Special handle for UNC path on windows\n  if (sep === path.win32.sep) {\n    if (searchPath[0] === sep && searchPath[1] === sep) {\n      const idx = searchPath.indexOf(sep, 2);\n      if (idx === -1) {\n        // If there isn't a complete UNC path,\n        // return the incomplete UNC as baseName\n        // e.g. \\\\test-server is an incomplete path\n        // and \\\\test-server\\ is a complete path\n        return [searchPath, ''];\n      }\n    }\n  }\n\n  const baseNameIndex = searchPath.lastIndexOf(sep) + 1;\n  const baseName = searchPath.slice(baseNameIndex);\n  const dirName = searchPath.slice(0, baseNameIndex);\n  return [dirName, baseName];\n}\n\n/**\n * The comment is used conjunction with getPathDetails.\n */\ninterface PathDetails {\n  /**\n   * A full absolute path resolved from directory of the currently active document.\n   * If the active document is an untitled document, full path will be dirName of\n   * the input partialPath.\n   */\n  fullPath: string;\n  /**\n   * A full absolute path of the directory of fullPath.\n   * If the active document is an untitled document, full path will be the input partialPath.\n   */\n  fullDirPath: string;\n  /**\n   * The dir name of partialPath.\n   * If the partialPath is an absolute path, this will be equal to fullDirPat\n   * If partialPath is ./abc/xyz.txt, baseName will be './abc/'\n   * If partialPath is /abc/xyz.txt, baseName will be '/abc/'\n   */\n  dirName: string;\n  /**\n   * A base name of the partialPath.\n   * If partialPath is ./abc/xyz.txt, baseName will be 'xyz.txt'\n   * If partialPath is /abc/xyz.txt, baseName will be 'xyz.txt'\n   */\n  baseName: string;\n  /**\n   * An updated partialPath which has its / changed to \\ on Windows.\n   */\n  partialPath: string;\n  /**\n   * The correct node js path for the partial path. This will be either\n   * path.win32 or path.posix for further processing.\n   */\n  path: Path;\n}\n\n/**\n * Get path detail.\n *\n * If the currently active document is an untitled document, we will assume the partialPath\n * is a Windows path only when the VS Code is running on Windows, and not remote session; else, posix path.\n *\n * If the currently active document is not an untitled document, we will assume the partialPath\n * is a Windows path when the current uri is local file where the first character of fsPath of the\n * current uri is not \"/\"; otherwise, posix path. fsPath can return C:\\path\\avc.txt or \\\\drive\\location\\abc.txt\n * on Windows.\n *\n * This is to maximize usability of the combination of Windows and posix machine using remote while browsing\n * file on both local and remote.\n *\n * @param partialPath A string of relative path to the directory of the currentUri,\n * or an absolute path in the environment of the currentUri.\n * ~/ can be used only if active document is local document, or local untitled document.\n * @param currentUri A uri of the currently active document.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @return A PathDetail.\n */\nexport function getPathDetails(\n  partialPath: string,\n  currentUri: vscode.Uri,\n  isRemote: boolean\n): PathDetails {\n  let isWindows: boolean;\n  if (currentUri.scheme === 'untitled') {\n    // Assume remote server is nix only\n    isWindows = path === path.win32 && !isRemote;\n  } else {\n    // Assuming other schemes return full path\n    // e.g. 'file' and 'vscode-remote' both return full path\n    // Also only scheme that support Windows is 'file', so we can\n    // safely check if fsPath returns '/' as the first character\n    // (fsPath in 'vscode-remote' on Windows return \\ as separator instead of /)\n    isWindows = currentUri.scheme === 'file' && currentUri.fsPath[0] !== '/';\n  }\n\n  const p = isWindows ? path.win32 : path.posix;\n  if (isWindows) {\n    // normalize / to \\ on windows\n    partialPath = partialPath.replace(/\\//g, '\\\\');\n  }\n  const updatedPartialPath = partialPath;\n\n  if (currentUri.scheme === 'file' || (currentUri.scheme === 'untitled' && !isRemote)) {\n    // We can untildify when the scheme is 'file' or 'untitled' on local fs because\n    // because we only support opening files mounted locally.\n    partialPath = untildify(partialPath);\n  }\n\n  const [dirName, baseName] = separatePath(partialPath, p.sep);\n  let fullDirPath: string;\n  if (p.isAbsolute(dirName)) {\n    fullDirPath = dirName;\n  } else {\n    fullDirPath = p.join(\n      // On Windows machine:\n      // fsPath returns Windows drive path (C:\\xxx\\) or UNC path (\\\\server\\xxx)\n      // fsPath returns path with \\ as separator even if 'vscode-remote' is connect to a linux box\n      //\n      // path will return /home/user for example even 'vscode-remote' is used on windows\n      // as we relied of our isWindows detection\n      separatePath(isWindows ? currentUri.fsPath : currentUri.path, p.sep)[0],\n      dirName\n    );\n  }\n\n  const fullPath = p.join(fullDirPath, baseName);\n  return {\n    fullPath,\n    fullDirPath,\n    dirName,\n    baseName,\n    partialPath: updatedPartialPath,\n    path: p,\n  };\n}\n\n/**\n * Resolve the absolutePath to Uri.\n *\n * @param absolutePath A string of absolute path.\n * @param sep The separator of the absolutePath.\n * This is used to determine we should consider absolutePath a Windows path.\n * @param currentUri A uri to resolve the absolutePath to Uri.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @return null if the absolutePath is invalid. A uri resolved with the currentUri.\n */\nexport function resolveUri(\n  absolutePath: string,\n  sep: string,\n  currentUri: vscode.Uri,\n  isRemote: boolean\n) {\n  const isWindows = sep === path.win32.sep;\n  if (isWindows && !/^(\\\\\\\\.+\\\\)|([a-zA-Z]:\\\\)/.test(absolutePath)) {\n    // if it is windows and but don't have either\n    // UNC path or the windows drive\n    return null;\n  }\n  if (!isWindows && absolutePath[0] !== sep) {\n    // if it is not windows, but the absolute path doesn't begin with /\n    return null;\n  }\n\n  const isLocalUntitled = !isRemote && currentUri.scheme === 'untitled';\n  return isWindows\n    ? // Create new local Uri when it's on windows.\n      // Only local resource is support (vscode-remote doesn't have windows path)\n      // UNC path like //server1/folder should also work.\n      vscode.Uri.file(absolutePath)\n    : currentUri.with({\n        // search local file with currently active document is a local untitled doc\n        scheme: isLocalUntitled ? 'file' : currentUri.scheme,\n        path: absolutePath,\n      });\n}\n\n/**\n * Get the name of the items in a directory.\n * @param absolutePath A string of absolute path.\n * @param sep The separator of the absolutePath.\n * @param currentUri A uri of the currently active document.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @param addCurrentAndUp A boolean to indicate if .{$sep} and ..${sep} should be add to the result\n * @return A Promise which resolves to an array of string. The array can be empty if the path specified is actual\n * empty, of if the absolutePath specified is invalid, or if any error occurred during directory reading.\n * The string in the array will have sep appended if it is a directory.\n */\nexport async function readDirectory(\n  absolutePath: string,\n  sep: string,\n  currentUri: vscode.Uri,\n  isRemote: boolean,\n  addCurrentAndUp: boolean\n) {\n  try {\n    const directoryUri = resolveUri(absolutePath, sep, currentUri, isRemote);\n    if (directoryUri === null) {\n      return [];\n    }\n    const directoryResult = await vscode.workspace.fs.readDirectory(directoryUri);\n    return (\n      directoryResult\n        // Add the separator at the end to the path if it is a directory\n        .map((d) => d[0] + (d[1] === vscode.FileType.Directory ? sep : ''))\n        // Add ./ and ../ to the result if specified\n        .concat(addCurrentAndUp ? [`.${sep}`, `..${sep}`] : [])\n    );\n  } catch {\n    return [];\n  }\n}\n\nexport function join(...paths: string[]): string {\n  return path.join(...paths);\n}\n","export enum SpecialKeys {\n  ExtensionEnable = '<ExtensionEnable>',\n  ExtensionDisable = '<ExtensionDisable>',\n  TimeoutFinished = '<TimeoutFinished>',\n}\n","import { Mode } from '../mode/mode';\nimport { StatusBar } from '../statusBar';\nimport { VimState } from '../state/vimState';\nimport { configuration } from '../configuration/configuration';\nimport { Position } from 'vscode';\n\n/**\n * Shows the number of lines you just changed (with `dG`, for instance), if it\n * crosses a configured threshold.\n * @param numLinesChanged The number of lines changed\n */\nexport function reportLinesChanged(numLinesChanged: number, vimState: VimState) {\n  if (numLinesChanged > configuration.report) {\n    StatusBar.setText(vimState, `${numLinesChanged} more lines`);\n  } else if (-numLinesChanged > configuration.report) {\n    StatusBar.setText(vimState, `${Math.abs(numLinesChanged)} fewer lines`);\n  } else {\n    StatusBar.clear(vimState);\n  }\n}\n\n/**\n * Shows the number of lines you just yanked, if it crosses a configured threshold.\n * @param numLinesYanked The number of lines yanked\n */\nexport function reportLinesYanked(numLinesYanked: number, vimState: VimState) {\n  if (numLinesYanked > configuration.report) {\n    if (vimState.currentMode === Mode.VisualBlock) {\n      StatusBar.setText(vimState, `block of ${numLinesYanked} lines yanked`);\n    } else {\n      StatusBar.setText(vimState, `${numLinesYanked} lines yanked`);\n    }\n  } else {\n    StatusBar.clear(vimState);\n  }\n}\n\n/**\n * Shows the active file's path and line count as well as position in the file as a percentage.\n * Triggered via `<C-g>` or `:f[ile]`.\n */\nexport function reportFileInfo(position: Position, vimState: VimState) {\n  const doc = vimState.document;\n  const fileName = doc.isUntitled ? '[No Name]' : doc.fileName;\n  const modified = doc.isDirty ? ' [Modified]' : '';\n\n  if (doc.lineCount === 1 && doc.lineAt(0).text.length === 0) {\n    // TODO: Vim behaves slightly differently - seems this is only shown for new buffer that hasn't been saved to disk\n    StatusBar.setText(vimState, `\"${fileName}\"${modified} --No lines in buffer--`);\n  } else {\n    const progress = Math.floor(((position.line + 1) / doc.lineCount) * 100);\n    StatusBar.setText(\n      vimState,\n      `\"${fileName}\"${modified} ${doc.lineCount} line${\n        doc.lineCount > 1 ? 's' : ''\n      } --${progress}%--`\n    );\n  }\n}\n\n/**\n * Shows the number of matches and current match index of a search.\n * @param matchIdx Index of current match, starting at 0\n * @param numMatches Total number of matches\n * @param vimState The current `VimState`\n */\nexport function reportSearch(matchIdx: number, numMatches: number, vimState: VimState) {\n  StatusBar.setText(vimState, `match ${matchIdx + 1} of ${numMatches}`);\n}\n","import * as vscode from 'vscode';\nimport { Cursor } from '../common/motion/cursor';\nimport { VimState } from '../state/vimState';\n\n/**\n * We used to have an issue where we would do something like execute a VSCode\n * command, and would encounter race conditions because the cursor positions\n * wouldn't yet be updated. So we waited for a selection change event, but\n * this doesn't seem to be necessary any more.\n */\nexport function getCursorsAfterSync(): Cursor[] {\n  return vscode.window.activeTextEditor!.selections.map((x) => Cursor.FromVSCodeSelection(x));\n}\n\nexport function clamp(num: number, min: number, max: number) {\n  return Math.min(Math.max(num, min), max);\n}\n\nexport function scrollView(vimState: VimState, offset: number) {\n  if (offset !== 0) {\n    vimState.postponedCodeViewChanges.push({\n      command: 'editorScroll',\n      args: {\n        to: offset > 0 ? 'up' : 'down',\n        by: 'line',\n        value: Math.abs(offset),\n        revealCursor: false,\n        select: false,\n      },\n    });\n  }\n}\n","import * as vscode from 'vscode';\nimport { Logger } from './logger';\n\ntype ContextValue = boolean | string;\n\n/**\n * Wrapper around VS Code's `setContext`.\n * The API call takes several milliseconds to seconds to complete,\n * so let's cache the values and only call the API when necessary.\n */\nexport abstract class VSCodeContext {\n  private static readonly cache: Map<string, ContextValue> = new Map();\n\n  public static async set(key: string, value: ContextValue): Promise<void> {\n    const prev = this.get(key);\n    if (prev !== value) {\n      Logger.get('vscode-context').debug(`Setting key='${key}' to value='${value}'`);\n      this.cache.set(key, value);\n      await vscode.commands.executeCommand('setContext', key, value);\n    }\n  }\n\n  public static get(key: string): ContextValue | undefined {\n    return this.cache.get(key);\n  }\n}\n","import { ErrorCode, VimError } from '../error';\nimport { VimState } from '../state/vimState';\nimport { LineRange } from './lineRange';\n\n// TODO: Implement `:help :bar`\n// TODO: Implement `:help :comment`\nexport abstract class ExCommand {\n  /**\n   * If this returns true and Neovim integration is enabled, we'll send this command to Neovim.\n   */\n  public neovimCapable(): boolean {\n    return false;\n  }\n\n  abstract execute(vimState: VimState): Promise<void>;\n\n  async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    // By default, throw E481 (\"No range allowed\")\n    throw VimError.fromCode(ErrorCode.NoRangeAllowed);\n  }\n}\n","import { all, alt, optWhitespace, Parser, regexp, seq, string } from 'parsimmon';\nimport { CopyCommand } from '../cmd_line/commands/copy';\nimport { GotoCommand } from '../cmd_line/commands/goto';\nimport { GotoLineCommand } from '../cmd_line/commands/gotoLine';\nimport { ClearJumpsCommand, JumpsCommand } from '../cmd_line/commands/jumps';\nimport { NohlCommand } from '../cmd_line/commands/nohl';\nimport { OnlyCommand } from '../cmd_line/commands/only';\nimport { ShCommand } from '../cmd_line/commands/sh';\nimport { SmileCommand } from '../cmd_line/commands/smile';\nimport { UndoCommand } from '../cmd_line/commands/undo';\nimport { VsCodeCommand } from '../cmd_line/commands/vscode';\nimport { YankCommand } from '../cmd_line/commands/yank';\nimport { parseBangCommand } from '../cmd_line/subparsers/bang';\nimport { parseBufferDeleteCommandArgs } from '../cmd_line/subparsers/bufferDelete';\nimport { parseCloseCommandArgs } from '../cmd_line/subparsers/close';\nimport { parseDeleteRangeLinesCommandArgs } from '../cmd_line/subparsers/deleteRange';\nimport { parseDigraphCommandArgs } from '../cmd_line/subparsers/digraph';\nimport * as fileCmd from '../cmd_line/subparsers/file';\nimport { parseFileInfoCommandArgs } from '../cmd_line/subparsers/fileInfo';\nimport { parseHistoryCommandArgs } from '../cmd_line/subparsers/history';\nimport { parseMarksCommandArgs, parseMarksRemoveCommandArgs } from '../cmd_line/subparsers/marks';\nimport { parsePutExCommandArgs } from '../cmd_line/subparsers/put';\nimport { parseQuitAllCommandArgs, parseQuitCommandArgs } from '../cmd_line/subparsers/quit';\nimport { parseReadCommandArgs } from '../cmd_line/subparsers/read';\nimport { parseRegisterCommandArgs } from '../cmd_line/subparsers/register';\nimport { parseOptionsCommandArgs } from '../cmd_line/subparsers/setoptions';\nimport { parseSortCommandArgs } from '../cmd_line/subparsers/sort';\nimport { parseSubstituteCommandArgs } from '../cmd_line/subparsers/substitute';\nimport * as tabCmd from '../cmd_line/subparsers/tab';\nimport { parseWallCommandArgs } from '../cmd_line/subparsers/wall';\nimport { parseWriteCommandArgs } from '../cmd_line/subparsers/write';\nimport { parseWriteQuitCommandArgs } from '../cmd_line/subparsers/writequit';\nimport { parseWriteQuitAllCommandArgs } from '../cmd_line/subparsers/writequitall';\nimport { ErrorCode, VimError } from '../error';\nimport { VimState } from '../state/vimState';\nimport { StatusBar } from '../statusBar';\nimport { ExCommand } from './exCommand';\nimport { LineRange } from './lineRange';\n\nexport const exCommandParser: Parser<{ lineRange: LineRange | undefined; command: ExCommand }> =\n  optWhitespace\n    .then(string(':').skip(optWhitespace).many())\n    .then(\n      seq(\n        LineRange.parser.fallback(undefined).skip(optWhitespace),\n        alt(string('!'), regexp(/[a-z]*/i)).skip(optWhitespace),\n        all\n      )\n    )\n    .map(([lineRange, commandName, args]) => {\n      const parser = getParser(commandName);\n      if (!parser) {\n        // TODO: This should show entire command (with range and args)\n        throw VimError.fromCode(ErrorCode.NotAnEditorCommand, commandName);\n      }\n      return { lineRange, command: parser(args) };\n    });\n\n// Associates a name and an abbreviation with a command parser\ntype CommandParserMapping = {\n  /** The shortest abbreviation that will work, such as `:q` */\n  abbrev?: string;\n\n  /** The parser for this command. Undefined if no implementation exists yet. */\n  parser?: (args: string) => ExCommand;\n};\n\n// Keep this sorted, please :)\nexport const commandParsers = {\n  '': {\n    parser: () => new GotoLineCommand(),\n  },\n\n  '!': {\n    parser: parseBangCommand,\n  },\n\n  bdelete: {\n    abbrev: 'bd',\n    parser: parseBufferDeleteCommandArgs,\n  },\n\n  bfirst: {\n    abbrev: 'bf',\n    parser: undefined,\n  },\n\n  blast: {\n    abbrev: 'bl',\n    parser: undefined,\n  },\n\n  bmodified: {\n    abbrev: 'bm',\n    parser: undefined,\n  },\n\n  bnext: {\n    abbrev: 'bn',\n    parser: tabCmd.parseTabNCommandArgs,\n  },\n\n  bNext: {\n    abbrev: 'bN',\n    parser: tabCmd.parseTabPCommandArgs,\n  },\n\n  bprevious: {\n    abbrev: 'bp',\n    parser: tabCmd.parseTabPCommandArgs,\n  },\n\n  brewind: {\n    abbrev: 'br',\n    parser: undefined,\n  },\n\n  buffers: {\n    parser: undefined,\n  },\n\n  center: {\n    abbrev: 'ce',\n    parser: undefined,\n  },\n\n  clearjumps: {\n    abbrev: 'cle',\n    parser: () => new ClearJumpsCommand(),\n  },\n\n  close: {\n    abbrev: 'clo',\n    parser: parseCloseCommandArgs,\n  },\n\n  copy: {\n    abbrev: 'co',\n    parser: CopyCommand.parseArgs,\n  },\n\n  delete: {\n    abbrev: 'd',\n    parser: parseDeleteRangeLinesCommandArgs,\n  },\n\n  delmarks: {\n    abbrev: 'delm',\n    parser: parseMarksRemoveCommandArgs,\n  },\n\n  digraphs: {\n    abbrev: 'dig',\n    parser: parseDigraphCommandArgs,\n  },\n\n  display: {\n    abbrev: 'di',\n    parser: parseRegisterCommandArgs,\n  },\n\n  edit: {\n    abbrev: 'e',\n    parser: fileCmd.parseEditFileCommandArgs,\n  },\n\n  enew: {\n    abbrev: 'ene',\n    parser: fileCmd.parseEditNewFileCommandArgs,\n  },\n\n  file: {\n    abbrev: 'f',\n    parser: parseFileInfoCommandArgs,\n  },\n\n  files: {\n    parser: undefined,\n  },\n\n  global: {\n    abbrev: 'g',\n    parser: undefined,\n  },\n\n  goto: {\n    abbrev: 'go',\n    parser: GotoCommand.parseArgs,\n  },\n\n  help: {\n    abbrev: 'h',\n    parser: undefined,\n  },\n\n  history: {\n    abbrev: 'his',\n    parser: parseHistoryCommandArgs,\n  },\n\n  jumps: {\n    abbrev: 'ju',\n    parser: () => new JumpsCommand(),\n  },\n\n  left: {\n    abbrev: 'le',\n    parser: undefined,\n  },\n\n  ls: {\n    parser: undefined,\n  },\n\n  marks: {\n    parser: parseMarksCommandArgs,\n  },\n\n  move: {\n    abbrev: 'm',\n    parser: undefined,\n  },\n\n  new: {\n    parser: fileCmd.parseEditNewFileInNewHorizontalWindowCommandArgs,\n  },\n\n  nohlsearch: {\n    abbrev: 'noh',\n    parser: () => new NohlCommand(),\n  },\n\n  normal: {\n    abbrev: 'norm',\n    parser: undefined,\n  },\n\n  only: {\n    abbrev: 'on',\n    parser: () => new OnlyCommand(),\n  },\n\n  put: {\n    abbrev: 'pu',\n    parser: parsePutExCommandArgs,\n  },\n\n  qall: {\n    abbrev: 'qa',\n    parser: parseQuitAllCommandArgs,\n  },\n\n  quit: {\n    abbrev: 'q',\n    parser: parseQuitCommandArgs,\n  },\n\n  quitall: {\n    abbrev: 'quita',\n    parser: parseQuitAllCommandArgs,\n  },\n\n  read: {\n    abbrev: 'r',\n    parser: parseReadCommandArgs,\n  },\n\n  registers: {\n    abbrev: 'reg',\n    parser: parseRegisterCommandArgs,\n  },\n\n  right: {\n    abbrev: 'ri',\n    parser: undefined,\n  },\n\n  set: {\n    abbrev: 'se',\n    parser: parseOptionsCommandArgs,\n  },\n\n  shell: {\n    abbrev: 'sh',\n    parser: () => new ShCommand(),\n  },\n\n  smile: {\n    parser: () => new SmileCommand(),\n  },\n\n  sort: {\n    abbrev: 'sor',\n    parser: parseSortCommandArgs,\n  },\n\n  source: {\n    abbrev: 'so',\n    parser: undefined,\n  },\n\n  split: {\n    abbrev: 'sp',\n    parser: fileCmd.parseEditFileInNewHorizontalWindowCommandArgs,\n  },\n\n  substitute: {\n    abbrev: 's',\n    parser: parseSubstituteCommandArgs,\n  },\n\n  t: {\n    parser: CopyCommand.parseArgs,\n  },\n\n  tabclose: {\n    abbrev: 'tabc',\n    parser: tabCmd.parseTabCloseCommandArgs,\n  },\n\n  tabedit: {\n    abbrev: 'tabe',\n    parser: tabCmd.parseTabNewCommandArgs,\n  },\n\n  tabfirst: {\n    abbrev: 'tabfir',\n    parser: tabCmd.parseTabFirstCommandArgs,\n  },\n\n  tablast: {\n    abbrev: 'tabl',\n    parser: tabCmd.parseTabLastCommandArgs,\n  },\n\n  tabmove: {\n    abbrev: 'tabm',\n    parser: tabCmd.parseTabMovementCommandArgs,\n  },\n\n  tabnew: {\n    parser: tabCmd.parseTabNewCommandArgs,\n  },\n\n  tabnext: {\n    abbrev: 'tabn',\n    parser: tabCmd.parseTabNCommandArgs,\n  },\n\n  tabNext: {\n    abbrev: 'tabN',\n    parser: tabCmd.parseTabPCommandArgs,\n  },\n\n  tabonly: {\n    abbrev: 'tabo',\n    parser: tabCmd.parseTabOnlyCommandArgs,\n  },\n\n  tabprevious: {\n    abbrev: 'tabp',\n    parser: tabCmd.parseTabPCommandArgs,\n  },\n\n  undo: {\n    abbrev: 'u',\n    parser: () => new UndoCommand(),\n  },\n\n  vglobal: {\n    abbrev: 'v',\n    parser: undefined,\n  },\n\n  vnew: {\n    abbrev: 'vne',\n    parser: fileCmd.parseEditNewFileInNewVerticalWindowCommandArgs,\n  },\n\n  vscode: {\n    abbrev: 'vsc',\n    parser: VsCodeCommand.parseArgs,\n  },\n\n  vsplit: {\n    abbrev: 'vs',\n    parser: fileCmd.parseEditFileInNewVerticalWindowCommandArgs,\n  },\n\n  wall: {\n    abbrev: 'wa',\n    parser: parseWallCommandArgs,\n  },\n\n  wq: {\n    parser: parseWriteQuitCommandArgs,\n  },\n\n  wqall: {\n    abbrev: 'wqa',\n    parser: parseWriteQuitAllCommandArgs,\n  },\n\n  write: {\n    abbrev: 'w',\n    parser: parseWriteCommandArgs,\n  },\n\n  x: {\n    parser: parseWriteQuitCommandArgs,\n  },\n\n  xall: {\n    abbrev: 'xa',\n    parser: parseWriteQuitAllCommandArgs,\n  },\n\n  yank: {\n    abbrev: 'y',\n    parser: YankCommand.parseArgs,\n  },\n};\n\n/**\n * Returns a command parser for the given `input`, if one exists.\n * Resolves `q`, `qu`, `qui`, and `quit` the same.\n */\nexport function getParser(input: string): ((args: string) => ExCommand) | undefined {\n  for (const fullName of Object.keys(commandParsers)) {\n    const parserMapping: CommandParserMapping = commandParsers[fullName];\n\n    const parser =\n      parserMapping.parser ??\n      ((args: string) => {\n        return new UnimplementedCommand(fullName, parserMapping);\n      });\n\n    if (parserMapping.abbrev !== undefined) {\n      if (input.startsWith(parserMapping.abbrev) && fullName.startsWith(input)) {\n        return parser;\n      }\n    } else {\n      if (input === fullName) {\n        return parser;\n      }\n    }\n  }\n\n  return undefined;\n}\n\nclass UnimplementedCommand extends ExCommand {\n  fullName: string;\n  parserMapping: CommandParserMapping;\n\n  public override neovimCapable(): boolean {\n    // If the user has neovim integration enabled, don't stop them from using these commands\n    return true;\n  }\n\n  constructor(fullName: string, parserMapping: CommandParserMapping) {\n    super();\n    this.fullName = fullName;\n    this.parserMapping = parserMapping;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const commandText = this.parserMapping.abbrev\n      ? `${this.parserMapping.abbrev}[${this.fullName.substr(this.parserMapping.abbrev.length)}]`\n      : this.fullName;\n    StatusBar.setText(vimState, `Command :${commandText} is not yet implemented`, true);\n  }\n}\n","import { alt, any, optWhitespace, Parser, regexp, seq, string, succeed } from 'parsimmon';\nimport { Position, Range } from 'vscode';\nimport { ErrorCode, VimError } from '../error';\nimport { globalState } from '../state/globalState';\nimport { SearchDirection, SearchState } from '../state/searchState';\nimport { VimState } from '../state/vimState';\nimport { numberParser } from './parserUtils';\n\n/**\n * Specifies the start or end of a line range.\n * See :help {address}\n */\ntype LineSpecifier =\n  | {\n      // {number}\n      type: 'number';\n      num: number;\n    }\n  | {\n      // .\n      type: 'current_line';\n    }\n  | {\n      // $\n      type: 'last_line';\n    }\n  | {\n      // %\n      type: 'entire_file';\n    }\n  | {\n      // *\n      type: 'last_visual_range';\n    }\n  | {\n      // 't\n      type: 'mark';\n      mark: string;\n    }\n  | {\n      // /{pattern}[/]\n      type: 'pattern_next';\n      pattern: string;\n    }\n  | {\n      // ?{pattern}[?]\n      type: 'pattern_prev';\n      pattern: string;\n    }\n  | {\n      // \\/\n      type: 'last_search_pattern_next';\n    }\n  | {\n      // \\?\n      type: 'last_search_pattern_prev';\n    }\n  | {\n      // \\&\n      type: 'last_substitute_pattern_next';\n    };\n\nconst lineSpecifierParser: Parser<LineSpecifier> = alt(\n  numberParser.map((num) => {\n    return { type: 'number', num };\n  }),\n  string('.').result({ type: 'current_line' }),\n  string('$').result({ type: 'last_line' }),\n  string('%').result({ type: 'entire_file' }),\n  string('*').result({ type: 'last_visual_range' }),\n  string(\"'\")\n    .then(any)\n    .map((mark) => {\n      return { type: 'mark', mark };\n    }),\n  // TODO: pattern_next\n  // TODO: pattern_prev\n  string('\\\\/').result({ type: 'last_search_pattern_next' }),\n  string('\\\\?').result({ type: 'last_search_pattern_prev' }),\n  string('\\\\&').result({ type: 'last_substitute_pattern_next' })\n);\n\nconst offsetParser: Parser<number> = alt(\n  string('+').then(numberParser.fallback(1)),\n  string('-')\n    .then(numberParser.fallback(1))\n    .map((num) => -num),\n  numberParser\n)\n  .skip(optWhitespace)\n  .atLeast(1)\n  .map((nums) => nums.reduce((x, y) => x + y, 0));\n\nexport class Address {\n  public readonly specifier: LineSpecifier;\n  public readonly offset: number;\n\n  constructor(specifier: LineSpecifier, offset?: number) {\n    this.specifier = specifier;\n    this.offset = offset ?? 0;\n  }\n\n  public static parser: Parser<Address> = alt(\n    seq(lineSpecifierParser.skip(optWhitespace), offsetParser.fallback(0)),\n    seq(succeed({ type: 'current_line' as const }), offsetParser)\n  ).map(([specifier, offset]) => {\n    return new Address(specifier, offset);\n  });\n\n  public resolve(vimState: VimState, side: 'left' | 'right'): number {\n    const line = (() => {\n      switch (this.specifier.type) {\n        case 'number':\n          return this.specifier.num ? this.specifier.num - 1 : 0;\n        case 'current_line':\n          return vimState.cursorStopPosition.line;\n        case 'last_line':\n          return vimState.document.lineCount - 1;\n        case 'entire_file':\n          return vimState.document.lineCount - 1;\n        case 'last_visual_range':\n          const res =\n            side === 'left'\n              ? vimState.lastVisualSelection?.start.line\n              : vimState.lastVisualSelection?.end.line;\n          if (res === undefined) {\n            throw VimError.fromCode(ErrorCode.MarkNotSet);\n          }\n          return res;\n        case 'mark':\n          const mark = vimState.historyTracker.getMark(this.specifier.mark);\n          if (!mark || (mark.document && mark.document !== vimState.document)) {\n            throw VimError.fromCode(ErrorCode.MarkNotSet);\n          }\n          return mark.position.line;\n        case 'pattern_next':\n          throw new Error('Using a pattern in a line range is not yet supported'); // TODO\n        case 'pattern_prev':\n          throw new Error('Using a pattern in a line range is not yet supported'); // TODO\n        case 'last_search_pattern_next':\n          if (!globalState.searchState) {\n            throw VimError.fromCode(ErrorCode.NoPreviousRegularExpression);\n          }\n          const nextMatch = globalState.searchState.getNextSearchMatchPosition(\n            vimState.editor,\n            vimState.cursorStopPosition,\n            SearchDirection.Forward\n          );\n          if (nextMatch === undefined) {\n            // TODO: throw proper errors for nowrapscan\n            throw VimError.fromCode(ErrorCode.PatternNotFound);\n          }\n          return nextMatch.pos.line;\n        case 'last_search_pattern_prev':\n          if (!globalState.searchState) {\n            throw VimError.fromCode(ErrorCode.NoPreviousRegularExpression);\n          }\n          const prevMatch = globalState.searchState.getNextSearchMatchPosition(\n            vimState.editor,\n            vimState.cursorStopPosition,\n            SearchDirection.Backward\n          );\n          if (prevMatch === undefined) {\n            // TODO: throw proper errors for nowrapscan\n            throw VimError.fromCode(ErrorCode.PatternNotFound);\n          }\n          return prevMatch.pos.line;\n        case 'last_substitute_pattern_next':\n          if (!globalState.substituteState) {\n            throw VimError.fromCode(ErrorCode.NoPreviousSubstituteRegularExpression);\n          }\n          const searchState = new SearchState(\n            SearchDirection.Forward,\n            vimState.cursorStopPosition,\n            globalState.substituteState.searchPattern,\n            {},\n            vimState.currentMode\n          );\n          const match = searchState.getNextSearchMatchPosition(\n            vimState.editor,\n            vimState.cursorStopPosition\n          );\n          if (match === undefined) {\n            // TODO: throw proper errors for nowrapscan\n            throw VimError.fromCode(ErrorCode.PatternNotFound);\n          }\n          return match.pos.line;\n        default:\n          const guard: never = this.specifier;\n          throw new Error('Got unexpected LineSpecifier.type');\n      }\n    })();\n    const result = line + this.offset;\n    if (result < 0) {\n      throw VimError.fromCode(ErrorCode.InvalidRange);\n    }\n    return result;\n  }\n}\n\nexport class LineRange {\n  private readonly start: Address;\n  private readonly end: Address;\n  public readonly separator: ',' | ';';\n\n  constructor(start: Address, end?: Address, separator?: ',' | ';') {\n    this.start = start;\n    this.end = end ?? start;\n    this.separator = separator ?? ',';\n  }\n\n  public static parser: Parser<LineRange> = seq(\n    Address.parser.skip(optWhitespace),\n    seq(\n      alt(string(','), string(';')).skip(optWhitespace),\n      Address.parser.fallback(new Address({ type: 'current_line' }))\n    ).fallback(undefined)\n  ).map(([start, sepEnd]) => {\n    if (sepEnd) {\n      const [sep, end] = sepEnd;\n      return new LineRange(start, end, sep);\n    }\n    return new LineRange(start, start);\n  });\n\n  public resolve(vimState: VimState): { start: number; end: number } | undefined {\n    // TODO: *,4 is not a valid range\n\n    if (this.end.specifier.type === 'entire_file') {\n      return { start: 0, end: vimState.document.lineCount - 1 };\n    } else if (this.end.specifier.type === 'last_visual_range') {\n      if (vimState.lastVisualSelection === undefined) {\n        throw VimError.fromCode(ErrorCode.MarkNotSet);\n      }\n      return {\n        start: vimState.lastVisualSelection.start.line,\n        end: vimState.lastVisualSelection.end.line,\n      };\n    }\n\n    const left = this.start.resolve(vimState, 'left');\n    if (this.separator === ';') {\n      vimState.cursorStartPosition = vimState.cursorStopPosition = new Position(left, 0);\n    }\n    const right = this.end.resolve(vimState, 'right');\n    if (left > right) {\n      // Reverse the range to keep start < end\n      // NOTE: Vim generally makes you confirm before doing this, but we do it automatically.\n      return {\n        start: this.end.resolve(vimState, 'left'),\n        end: this.start.resolve(vimState, 'right'),\n      };\n    } else {\n      return {\n        start: this.start.resolve(vimState, 'left'),\n        end: this.end.resolve(vimState, 'right'),\n      };\n    }\n  }\n\n  public resolveToRange(vimState: VimState): Range {\n    const { start, end } = this.resolve(vimState)!;\n    return new Range(new Position(start, 0), new Position(end, 0).getLineEnd());\n  }\n}\n","import { Parser, regexp } from 'parsimmon';\n\nexport const numberParser: Parser<number> = regexp(/\\d+/).map((num) => Number.parseInt(num, 10));\n","'use strict';\nconst os = require('os');\n\nconst homeDirectory = os.homedir();\n\nmodule.exports = pathWithTilde => {\n\tif (typeof pathWithTilde !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof pathWithTilde}`);\n\t}\n\n\treturn homeDirectory ? pathWithTilde.replace(/^~(?=$|\\/|\\\\)/, homeDirectory) : pathWithTilde;\n};\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n'use strict';\n\nvar isArgumentsObject = require('is-arguments');\nvar isGeneratorFunction = require('is-generator-function');\nvar whichTypedArray = require('which-typed-array');\nvar isTypedArray = require('is-typed-array');\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\n// Store a copy of SharedArrayBuffer in case it's deleted elsewhere\nvar SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBufferCopy === 'undefined') {\n    return false;\n  }\n\n  if (typeof isSharedArrayBufferToString.working === 'undefined') {\n    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBufferCopy;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = require('./support/types');\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","'use strict';\n\nvar forEach = require('foreach');\nvar availableTypedArrays = require('available-typed-arrays');\nvar callBound = require('call-bind/callBound');\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasToStringTag = require('has-tostringtag/shams')();\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = require('es-abstract/helpers/getOwnPropertyDescriptor');\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof g[typedArray] === 'function') {\n\t\t\tvar arr = new g[typedArray]();\n\t\t\tif (Symbol.toStringTag in arr) {\n\t\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\t\tif (!descriptor) {\n\t\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t\t}\n\t\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t\t}\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = require('is-typed-array');\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag || !(Symbol.toStringTag in value)) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n","module.exports = require(\"vscode\");","'use strict';\n\nvar possibleNames = [\n\t'BigInt64Array',\n\t'BigUint64Array',\n\t'Float32Array',\n\t'Float64Array',\n\t'Int16Array',\n\t'Int32Array',\n\t'Int8Array',\n\t'Uint16Array',\n\t'Uint32Array',\n\t'Uint8Array',\n\t'Uint8ClampedArray'\n];\n\nvar g = typeof globalThis === 'undefined' ? global : globalThis;\n\nmodule.exports = function availableTypedArrays() {\n\tvar out = [];\n\tfor (var i = 0; i < possibleNames.length; i++) {\n\t\tif (typeof g[possibleNames[i]] === 'function') {\n\t\t\tout[out.length] = possibleNames[i];\n\t\t}\n\t}\n\treturn out;\n};\n","'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","/**\n * Extension.ts is a lightweight wrapper around ModeHandler. It converts key\n * events to their string names and passes them on to ModeHandler via\n * handleKeyEvent().\n */\nimport './src/actions/include-main';\n\n/**\n * Load configuration validator\n */\n\nimport './src/configuration/validators/inputMethodSwitcherValidator';\nimport './src/configuration/validators/remappingValidator';\n\nimport * as vscode from 'vscode';\nimport { activate as activateFunc } from './extensionBase';\n\n// tslint:disable-next-line: no-var-requires\nrequire('setimmediate');\n\nexport async function activate(context: vscode.ExtensionContext) {\n  activateFunc(context, false);\n}\n"],"names":["root","factory","exports","module","define","amd","a","i","self","GetIntrinsic","callBind","$indexOf","name","allowMissing","intrinsic","bind","$apply","$call","$reflectApply","call","$gOPD","$defineProperty","$max","value","e","originalFunction","func","arguments","desc","configurable","length","applyBind","apply","diff_match_patch","this","Diff_Timeout","Diff_EditCost","Match_Threshold","Match_Distance","Patch_DeleteThreshold","Patch_Margin","Match_MaxBits","DIFF_DELETE","Diff","op","text","prototype","diff_main","text1","text2","opt_checklines","opt_deadline","Number","MAX_VALUE","Date","getTime","deadline","Error","checklines","commonlength","diff_commonPrefix","commonprefix","substring","diff_commonSuffix","commonsuffix","diffs","diff_compute_","unshift","push","diff_cleanupMerge","longtext","shorttext","indexOf","hm","diff_halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","concat","diff_lineMode_","diff_bisect_","diff_linesToChars_","chars1","chars2","linearray","lineArray","diff_charsToLines_","diff_cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","splice","subDiff","j","pop","text1_length","text2_length","max_d","Math","ceil","v_offset","v_length","v1","Array","v2","x","delta","front","k1start","k1end","k2start","k2end","d","k1","k1_offset","y1","x1","charAt","k2_offset","x2","diff_bisectSplit_","k2","y2","y","text1a","text2a","text1b","text2b","diffsb","lineHash","diff_linesToCharsMunge_","chars","lineStart","lineEnd","lineArrayLength","line","hasOwnProperty","undefined","String","fromCharCode","maxLines","charCodeAt","join","pointermin","pointermax","min","pointermid","pointerstart","floor","pointerend","diff_commonOverlap_","text_length","best","pattern","found","dmp","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","suffixLength","hm1","hm2","changes","equalities","equalitiesLength","lastEquality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","max","diff_cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","char1","char2","nonAlphaNumeric1","match","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","diff_cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","diff_xIndex","loc","last_chars1","last_chars2","diff_prettyHtml","html","pattern_amp","pattern_lt","pattern_gt","pattern_para","replace","diff_text1","diff_text2","diff_levenshtein","levenshtein","insertions","deletions","data","diff_toDelta","encodeURI","diff_fromDelta","diffsLength","tokens","split","param","decodeURI","ex","n","parseInt","isNaN","match_main","match_bitap_","s","match_alphabet_","match_bitapScore_","accuracy","proximity","abs","score_threshold","best_loc","lastIndexOf","bin_min","bin_mid","matchmask","last_rd","bin_max","start","finish","rd","charMatch","patch_addContext_","patch","start2","length1","padding","prefix","suffix","start1","length2","patch_make","opt_b","opt_c","patches","patch_obj","patchDiffLength","char_count1","char_count2","prepatch_text","postpatch_text","diff_type","diff_text","patch_deepCopy","patchesCopy","patchCopy","patch_apply","nullPadding","patch_addPadding","patch_splitMax","results","start_loc","expected_loc","end_loc","index2","index1","mod","paddingLength","extraLength","patch_size","bigpatch","precontext","empty","shift","postcontext","patch_toText","patch_fromText","textline","textPointer","patchHeader","m","sign","toString","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","args","Function","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","EventEmitter","init","once","emitter","Promise","resolve","reject","eventListener","errorListener","removeListener","slice","err","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","events","existing","warning","create","newListener","emit","warned","w","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","_listeners","unwrap","evlistener","arr","ret","unwrapListeners","arrayClone","listenerCount","copy","defineProperty","enumerable","get","set","arg","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","handler","len","listeners","addListener","on","prependListener","prependOnceListener","list","position","originalListener","index","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","hasOwn","obj","fn","ctx","l","k","ERROR_MESSAGE","toStr","funcType","bound","binder","result","boundLength","boundArgs","Empty","implementation","$SyntaxError","SyntaxError","$Function","$TypeError","getEvalledConstructor","expressionSyntax","getOwnPropertyDescriptor","throwTypeError","ThrowTypeError","calleeThrows","gOPDthrows","hasSymbols","getProto","__proto__","needsEval","TypedArray","Uint8Array","INTRINSICS","AggregateError","ArrayBuffer","Symbol","iterator","Atomics","BigInt","Boolean","DataView","decodeURIComponent","encodeURIComponent","eval","EvalError","Float32Array","Float64Array","FinalizationRegistry","Int8Array","Int16Array","Int32Array","isFinite","JSON","Map","parseFloat","Proxy","ReferenceError","RegExp","Set","SharedArrayBuffer","Uint8ClampedArray","Uint16Array","Uint32Array","URIError","WeakMap","WeakRef","WeakSet","doEval","gen","LEGACY_ALIASES","$concat","$spliceApply","$replace","$strSlice","rePropName","reEscapeChar","stringToPath","string","first","last","number","quote","subString","getBaseIntrinsic","alias","intrinsicName","parts","intrinsicBaseName","intrinsicRealName","skipFurtherCaching","isOwn","part","origSymbol","g","hasSymbolSham","sym","symObj","syms","propertyIsEnumerable","descriptor","toStringTag","ctor","superCtor","super_","constructor","writable","TempCtor","hasToStringTag","$toString","callBound","isStandardArguments","isLegacyArguments","callee","supportsStandardArguments","GeneratorFunction","fnToStr","isFnRegex","test","generatorFunc","getGeneratorFunc","forEach","availableTypedArrays","globalThis","typedArrays","array","$slice","toStrTags","gOPD","typedArray","proto","superProto","tag","anyTrue","getter","tryTypedArrays","FUNC_ERROR_TEXT","HASH_UNDEFINED","PLACEHOLDER","WRAP_PARTIAL_FLAG","WRAP_ARY_FLAG","INFINITY","MAX_SAFE_INTEGER","NAN","MAX_ARRAY_LENGTH","wrapFlags","argsTag","arrayTag","boolTag","dateTag","errorTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reEmptyStringLeading","reEmptyStringMiddle","reEmptyStringTrailing","reEscapedHtml","reUnescapedHtml","reHasEscapedHtml","source","reHasUnescapedHtml","reEscape","reEvaluate","reInterpolate","reIsDeepProp","reIsPlainProp","reRegExpChar","reHasRegExpChar","reTrimStart","reWhitespace","reWrapComment","reWrapDetails","reSplitDetails","reAsciiWord","reForbiddenIdentifierChars","reEsTemplate","reFlags","reIsBadHex","reIsBinary","reIsHostCtor","reIsOctal","reIsUint","reLatin","reNoMatch","reUnescapedString","rsComboRange","rsComboMarksRange","rsLowerRange","rsUpperRange","rsBreakRange","rsMathOpRange","rsBreak","rsCombo","rsDigits","rsLower","rsMisc","rsFitz","rsNonAstral","rsRegional","rsSurrPair","rsUpper","rsMiscLower","rsMiscUpper","rsOptContrLower","rsOptContrUpper","reOptMod","rsModifier","rsOptVar","rsSeq","rsEmoji","rsSymbol","reApos","reComboMark","reUnicode","reUnicodeWord","reHasUnicode","reHasUnicodeWord","contextProps","templateCounter","typedArrayTags","cloneableTags","stringEscapes","freeParseFloat","freeParseInt","freeGlobal","freeSelf","freeExports","nodeType","freeModule","moduleExports","freeProcess","process","nodeUtil","require","types","binding","nodeIsArrayBuffer","isArrayBuffer","nodeIsDate","isDate","nodeIsMap","isMap","nodeIsRegExp","isRegExp","nodeIsSet","isSet","nodeIsTypedArray","isTypedArray","thisArg","arrayAggregator","setter","iteratee","accumulator","arrayEach","arrayEachRight","arrayEvery","predicate","arrayFilter","resIndex","arrayIncludes","baseIndexOf","arrayIncludesWith","comparator","arrayMap","arrayPush","values","offset","arrayReduce","initAccum","arrayReduceRight","arraySome","asciiSize","baseProperty","baseFindKey","collection","eachFunc","baseFindIndex","fromIndex","fromRight","strictIndexOf","baseIsNaN","baseIndexOfWith","baseMean","baseSum","object","basePropertyOf","baseReduce","current","baseTimes","baseTrim","trimmedEndIndex","baseUnary","baseValues","props","cacheHas","cache","has","charsStartIndex","strSymbols","chrSymbols","charsEndIndex","countHolders","placeholder","deburrLetter","escapeHtmlChar","escapeStringChar","chr","hasUnicode","mapToArray","map","size","overArg","transform","replaceHolders","setToArray","setToPairs","stringSize","lastIndex","unicodeSize","stringToArray","unicodeToArray","asciiToArray","unescapeHtmlChar","_","runInContext","uid","defaults","pick","arrayProto","funcProto","objectProto","coreJsData","funcToString","idCounter","maskSrcKey","exec","IE_PROTO","nativeObjectToString","objectCtorString","oldDash","reIsNative","Buffer","allocUnsafe","getPrototype","objectCreate","spreadableSymbol","isConcatSpreadable","symIterator","symToStringTag","getNative","ctxClearTimeout","clearTimeout","ctxNow","now","ctxSetTimeout","setTimeout","nativeCeil","nativeFloor","nativeGetSymbols","nativeIsBuffer","isBuffer","nativeIsFinite","nativeJoin","nativeKeys","nativeMax","nativeMin","nativeNow","nativeParseInt","nativeRandom","random","nativeReverse","reverse","nativeCreate","metaMap","realNames","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","symbolToString","lodash","isObjectLike","isArray","LazyWrapper","LodashWrapper","wrapperClone","baseCreate","isObject","baseLodash","chainAll","__wrapped__","__actions__","__chain__","__index__","__values__","__dir__","__filtered__","__iteratees__","__takeCount__","__views__","Hash","entries","clear","entry","ListCache","MapCache","SetCache","__data__","add","Stack","arrayLikeKeys","inherited","isArr","isArg","isArguments","isBuff","isType","skipIndexes","isIndex","arraySample","baseRandom","arraySampleSize","shuffleSelf","copyArray","baseClamp","arrayShuffle","assignMergeValue","eq","baseAssignValue","assignValue","objValue","assocIndexOf","baseAggregator","baseEach","baseAssign","copyObject","baseAt","paths","skip","lower","upper","baseClone","bitmask","customizer","stack","isDeep","isFlat","isFull","input","initCloneArray","getTag","isFunc","cloneBuffer","initCloneObject","getSymbolsIn","copySymbolsIn","keysIn","baseAssignIn","getSymbols","copySymbols","symbol","Ctor","cloneArrayBuffer","dataView","buffer","byteOffset","byteLength","cloneDataView","cloneTypedArray","regexp","cloneRegExp","initCloneByTag","stacked","subValue","getAllKeysIn","getAllKeys","baseConformsTo","baseDelay","wait","baseDifference","includes","isCommon","valuesLength","outer","computed","valuesIndex","templateSettings","getMapData","pairs","LARGE_ARRAY_SIZE","createBaseEach","baseForOwn","baseEachRight","baseForOwnRight","baseEvery","baseExtremum","isSymbol","baseFilter","baseFlatten","depth","isStrict","isFlattenable","baseFor","createBaseFor","baseForRight","baseFunctions","isFunction","baseGet","path","castPath","toKey","baseGetAllKeys","keysFunc","symbolsFunc","baseGetTag","unmasked","getRawTag","objectToString","baseGt","other","baseHas","baseHasIn","baseIntersection","arrays","othLength","othIndex","caches","maxLength","Infinity","seen","baseInvoke","parent","baseIsArguments","baseIsEqual","equalFunc","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","equalArrays","convert","isPartial","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","objProps","objLength","objStacked","othStacked","skipCtor","othValue","compared","objCtor","othCtor","equalObjects","baseIsEqualDeep","baseIsMatch","matchData","noCustomizer","srcValue","COMPARE_PARTIAL_FLAG","baseIsNative","baseIteratee","identity","baseMatchesProperty","baseMatches","property","baseKeys","isPrototype","baseLt","baseMap","isArrayLike","getMatchData","matchesStrictComparable","isKey","isStrictComparable","hasIn","baseMerge","srcIndex","mergeFunc","safeGet","newValue","isTyped","isArrayLikeObject","isPlainObject","toPlainObject","baseMergeDeep","baseNth","baseOrderBy","iteratees","orders","getIteratee","comparer","sort","objCriteria","criteria","othCriteria","ordersLength","compareAscending","compareMultiple","baseSortBy","basePickBy","baseSet","basePullAll","basePullAt","indexes","previous","baseUnset","baseRepeat","baseRest","setToString","overRest","baseSample","baseSampleSize","nested","baseSetData","baseSetToString","constant","baseShuffle","baseSlice","end","baseSome","baseSortedIndex","retHighest","low","high","mid","baseSortedIndexBy","valIsNaN","valIsNull","valIsSymbol","valIsUndefined","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","setLow","baseSortedUniq","baseToNumber","baseToString","baseUniq","createSet","seenIndex","baseUpdate","updater","baseWhile","isDrop","baseWrapperValue","actions","action","baseXor","baseZipObject","assignFunc","valsLength","castArrayLikeObject","castFunction","castRest","castSlice","id","arrayBuffer","valIsDefined","valIsReflexive","composeArgs","partials","holders","isCurried","argsIndex","argsLength","holdersLength","leftIndex","leftLength","rangeLength","isUncurried","composeArgsRight","holdersIndex","rightIndex","rightLength","isNew","createAggregator","initializer","createAssigner","assigner","sources","guard","isIterateeCall","iterable","createCaseFirst","methodName","trailing","createCompounder","callback","words","deburr","createCtor","thisBinding","createFind","findIndexFunc","createFlow","flatRest","funcs","prereq","thru","wrapper","getFuncName","funcName","getData","isLaziable","plant","createHybrid","partialsRight","holdersRight","argPos","ary","arity","isAry","isBind","isBindKey","isFlip","getHolder","holdersCount","newHolders","createRecurry","reorder","createInverter","toIteratee","baseInverter","createMathOperation","operator","defaultValue","createOver","arrayFunc","createPadding","charsLength","createRange","step","toFinite","baseRange","createRelationalOperation","toNumber","wrapFunc","isCurry","newData","setData","setWrapToString","createRound","precision","toInteger","pair","noop","createToPairs","baseToPairs","createWrap","srcBitmask","newBitmask","isCombo","mergeData","createCurry","createPartial","createBind","customDefaultsAssignIn","customDefaultsMerge","customOmitClone","arrLength","arrStacked","arrValue","flatten","otherFunc","getValue","stubArray","hasPath","hasFunc","isLength","ctorString","isMaskable","stubFalse","otherArgs","oldArray","shortOut","reference","details","insertWrapDetails","updateWrapDetails","getWrapDetails","lastCalled","stamp","remaining","rand","memoize","clone","difference","differenceBy","differenceWith","findIndex","findLastIndex","head","intersection","mapped","intersectionBy","intersectionWith","pull","pullAll","pullAt","union","unionBy","unionWith","unzip","group","unzipWith","without","xor","xorBy","xorWith","zip","zipWith","chain","interceptor","wrapperAt","countBy","find","findLast","forEachRight","groupBy","invokeMap","keyBy","partition","sortBy","before","bindKey","WRAP_BIND_FLAG","debounce","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","invokeFunc","time","leadingEdge","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","cancel","flush","defer","delay","resolver","memoized","Cache","negate","overArgs","transforms","funcsLength","partial","partialRight","rearg","gt","gte","isError","isInteger","isNumber","isString","lt","lte","toArray","next","done","iteratorToArray","remainder","toLength","isBinary","assign","assignIn","assignInWith","assignWith","at","propsIndex","propsLength","defaultsDeep","mergeWith","invert","invertBy","invoke","nativeKeysIn","isProto","baseKeysIn","merge","omit","CLONE_DEEP_FLAG","basePick","pickBy","prop","toPairs","toPairsIn","camelCase","word","toLowerCase","capitalize","upperFirst","kebabCase","lowerCase","lowerFirst","snakeCase","startCase","upperCase","toUpperCase","hasUnicodeWord","unicodeWords","asciiWords","attempt","bindAll","methodNames","flow","flowRight","method","methodOf","mixin","over","overEvery","overSome","basePropertyDeep","range","rangeRight","augend","addend","divide","dividend","divisor","multiply","multiplier","multiplicand","round","subtract","minuend","subtrahend","after","castArray","chunk","compact","cond","conforms","baseConforms","properties","curry","curryRight","drop","dropRight","dropRightWhile","dropWhile","fill","baseFill","filter","flatMap","flatMapDeep","flatMapDepth","flattenDeep","flattenDepth","flip","fromPairs","functions","functionsIn","initial","mapKeys","mapValues","matches","matchesProperty","nthArg","omitBy","orderBy","propertyOf","pullAllBy","pullAllWith","remove","rest","sampleSize","setWith","shuffle","sortedUniq","sortedUniqBy","separator","limit","spread","tail","take","takeRight","takeRightWhile","takeWhile","tap","throttle","toPath","isArrLike","unary","uniq","uniqBy","uniqWith","unset","update","updateWith","valuesIn","wrap","zipObject","zipObjectDeep","entriesIn","extend","extendWith","clamp","cloneDeep","cloneDeepWith","cloneWith","conformsTo","defaultTo","endsWith","escape","escapeRegExp","every","findKey","findLastKey","forIn","forInRight","forOwn","forOwnRight","inRange","baseInRange","isBoolean","isElement","isEmpty","isEqual","isEqualWith","isMatch","isMatchWith","isNative","isNil","isNull","isSafeInteger","isUndefined","isWeakMap","isWeakSet","strictLastIndexOf","maxBy","mean","meanBy","minBy","stubObject","stubString","stubTrue","nth","noConflict","pad","strLength","padEnd","padStart","radix","floating","temp","reduce","reduceRight","repeat","sample","some","sortedIndex","sortedIndexBy","sortedIndexOf","sortedLastIndex","sortedLastIndexBy","sortedLastIndexOf","startsWith","sum","sumBy","template","settings","isEscaping","isEvaluating","imports","importsKeys","importsValues","interpolate","reDelimiters","evaluate","sourceURL","escapeValue","interpolateValue","esTemplateValue","evaluateValue","variable","times","toLower","toSafeInteger","toUpper","trim","trimEnd","trimStart","truncate","omission","search","global","newEnd","unescape","uniqueId","each","eachRight","VERSION","isFilter","takeName","dropName","checkIteratee","isTaker","lodashFunc","retUnwrapped","isLazy","useLazy","isHybrid","isUnwrapped","onlyLazy","chainName","dir","isRight","view","getView","iterLength","takeCount","iterIndex","commit","toJSON","endianness","hostname","location","loadavg","uptime","freemem","totalmem","cpus","release","navigator","appVersion","networkInterfaces","getNetworkInterfaces","arch","platform","tmpdir","tmpDir","EOL","homedir","t","r","u","c","o","__esModule","default","p","f","v","buf","from","readUInt16BE","b","coll","h","readUIntBE","readUIntLE","readIntBE","readIntLE","E","status","furthest","expected","B","_supportsSet","S","column","L","O","P","U","W","to","D","M","I","N","G","flags","ignoreCase","multiline","unicode","sticky","C","J","T","Y","V","H","or","X","then","many","K","Q","Z","$","nn","tn","rn","parse","tryParse","assert","tieWith","tie","atMost","atLeast","contramap","promap","mark","en","node","sepBy","sepBy1","lookahead","notFollowedBy","fallback","ap","of","un","an","cn","sn","ln","pn","hn","dn","vn","gn","mn","yn","all","alt","any","cr","createLanguage","crlf","custom","digit","digits","eof","fail","formatError","isParser","lazy","letter","letters","lf","makeFailure","makeSuccess","newline","noneOf","oneOf","optWhitespace","Parser","regex","seq","seqMap","seqObj","succeed","whitespace","Binary","bitSeq","bitSeqObj","byte","encodedString","uintBE","uint8BE","uint16BE","uint32BE","uintLE","uint8LE","uint16LE","uint32LE","intBE","int8BE","int16BE","int32BE","intLE","int8LE","int16LE","int32LE","floatBE","readFloatBE","floatLE","readFloatLE","doubleBE","readDoubleBE","doubleLE","readDoubleLE","assertPath","stringify","normalizeStringPosix","allowAboveRoot","code","res","lastSegmentLength","lastSlash","dots","lastSlashIndex","posix","cwd","resolvedPath","resolvedAbsolute","normalize","isAbsolute","trailingSeparator","joined","relative","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","matchedSlash","basename","ext","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","base","_format","delimiter","win32","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","nextTick","title","browser","env","argv","version","versions","chdir","umask","inherits","Queue","concurrency","autostart","pending","session","running","jobs","timers","clearTimers","timeoutId","callOnErrorOrEnd","cb","onerror","onend","begin","methodResult","job","didTimeout","resultIndex","promise","catch","stop","setImmediate","registerImmediate","channel","messagePrefix","onGlobalMessage","nextHandle","tasksByHandle","currentlyRunningATask","doc","document","attachTo","handle","runIfPresent","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","canUsePostMessage","event","addEventListener","attachEvent","MessageChannel","port1","port2","createElement","documentElement","script","onreadystatechange","removeChild","appendChild","task","clearImmediate","extensionContext","previousActiveEditorId","lastClosedModeHandler","async","getAndUpdateModeHandler","forceSyncAndUpdate","activeTextEditor","vscode","window","isClosed","activeEditorId","EditorIdentity","fromEditor","curHandler","ModeHandlerMap","getOrCreate","subscriptions","vimState","editor","syncCursors","updateView","drawSelection","revealRange","focusChanged","loadConfiguration","validatorResults","configuration","load","Logger","configChanged","logger","debug","numErrors","validatorResult","level","toggleExtension","isDisabled","compositionState","VSCodeContext","mh","handleKeyEvent","SpecialKeys","ExtensionDisable","reset","ExtensionEnable","overrideCommand","command","disposable","commands","registerCommand","disableExtension","executeCommand","uri","requiresActiveEditor","registerEventListener","exitOnExtensionDisable","exitOnTests","Globals","isTesting","forceStopRecursiveRemap","remapState","isCurrentlyPerformingRecursiveRemapping","forceStopRecursiveRemapping","handleLocal","StatusBar","Register","loadFromDisk","commandLine","globalState","filepathComponents","fileName","setReadonlyRegister","workspace","onDidChangeConfiguration","onDidChangeTextDocument","changeEvent","contentChanges","jumpTracker","handleTextDeleted","textWasAdded","handleTextAdded","getAll","modeHandler","currentMode","Mode","Insert","historyTracker","currentContentChanges","contentChangeHandler","isDirty","isUntitled","HistoryTracker","onDidCloseTextDocument","closedDocument","documents","textDocuments","editorIdentity","getKeys","shouldDelete","delete","onDidSaveTextDocument","vimrc","enable","showInformationMessage","onDidChangeActiveTextEditor","mhPrevious","oldFileRegister","relativePath","asRelativePath","taskQueue","enqueueTask","handleFileJump","Jump","fromStateNow","onDidChangeTextEditorSelection","textEditor","kind","TextEditorSelectionChangeKind","Mouse","selectionsHash","selections","hash","anchor","character","active","idx","selectionsChanged","ourSelections","ignoreIntermediateSelections","EasyMotionMode","handleSelectionChange","onDidChangeTextEditorVisibleRanges","lastMessageTime","CompositionState","isInComposition","composingText","insertedText","substr","replaceCharCnt","cursorStopPosition","selection","cursorStartPosition","handleMultipleKeyEvents","PromptAndRun","Notation","NormalizeKey","leader","Run","openTextDocument","showTextDocument","boundKey","boundKeyCombinations","startInInsertMode","cursors","cursor","eolColumn","lineAt","withNewStop","with","BaseAction","isMotion","isOperator","isCommand","isJump","canBeRepeatedWithDot","preservesDesiredColumn","keysPressed","currentModeIncludingPseudoModes","OperatorPendingMode","modes","CompareKeypressSequence","keysSlice","is2DArray","sequence","left","right","isSingleNumber","isSingleAlpha","IsControlKey","KeypressState","isCompleteAction","runsOnceForEachCountPrefix","timesToRepeat","recordedState","runsOnceForEveryCursor","transformation","transformer","transformations","isTextTransformation","cursorIndex","resultingCursors","cursorsToIterateOver","Cursor","multicursorIndex","actionMap","possibleActionsForMode","hasPotentialMatch","actionType","doesActionApply","actionKeys","couldActionApply","WaitingOnKeys","NoPossibleMatch","actionInstance","modeName","isIMovement","SelectionType","failedMovement","failed","BaseMovement","isRepeat","super","Normal","Visual","VisualLine","VisualBlock","setsDesiredColumnToEOL","minCount","maxCount","selectionType","Concatenating","firstIteration","lastIteration","execAction","prevResult","firstMovementStart","createMovementResult","Position","adjustPosition","execActionForOperator","getRightThroughLineBreaks","DocumentContentChangeAction","BaseCommand","cursorStart","cursorEnd","cursorPosition","compressChanges","positionDiff","diff","originalLeftBoundary","rightBoundary","change","linesAffected","resultLines","translate","diffPos","lineOffset","char","replaceRange","Range","isAfter","textDiffLines","numLinesAdded","newRightBoundary","laterOf","insert","PositionDiff","exactPosition","second","rangeOffset","compressed","prev","merged","DisableExtension","SearchInProgressMode","CommandlineInProgress","Replace","EasyMotionInputMode","SurroundInputMode","setCurrentMode","Disabled","RegisterAction","EnableExtension","CommandNumber","num","operatorCount","lastAction","actionsRun","isZero","CommandRegister","register","isValidRegister","registerName","CommandRecordMacro","registerKey","toLocaleLowerCase","macro","RecordedState","isValidUppercaseRegister","newRegister","put","CommandQuitRecordMacro","existingMacro","CommandExecuteLastMacro","lastInvokedMacro","addTransformation","replay","displayError","VimError","ErrorCode","NoPreviouslyUsedRegister","CommandExecuteMacro","InvalidRegisterName","CommandEsc","surround","isMultiCursor","allSettled","easyMotion","clearDecorations","CommandEditorScroll","scrolloff","getConfiguration","visibleRange","visibleRanges","linesAboveCursor","linesBelowCursor","getUp","withColumn","desiredColumn","getDown","postponedCodeViewChanges","by","revealCursor","select","isVisualMode","CommandCtrlE","CommandCtrlY","CommandScrollAndMoveCursor","smoothScrolling","moveLines","actionCount","getNumLines","scrollLines","lineCount","newPositionLine","obeyStartOfLine","CommandMoveFullPageUp","CommandMoveFullPageDown","CommandMoveHalfPageDown","getScrollLines","CommandMoveHalfPageUp","CommandInsertAtCursor","previousActionsNumbers","prevAction","CommandReplaceAtCursorFromNormalMode","replaceState","ReplaceState","CommandOverrideCopy","sorted","getText","getRight","earlierOf","getLineBegin","getLineEnd","TextEditor","iterateLinesInBlock","Clipboard","Copy","CommandCmdA","MarkCommand","markName","addMark","CommandShowCommandLine","currentCommandlineText","statusBarCursorCharacterPos","previousMode","commandLineHistoryIndex","historyEntries","CommandShowCommandHistory","CommandShowSearchHistory","direction","SearchDirection","Forward","Backward","CommandDot","previousFullAction","CommandRepeatSubstitution","CommandFold","levels","commandName","getCursorsAfterSync","CommandToggleFold","CommandCloseFold","CommandCloseAllFolds","CommandOpenFold","CommandOpenAllFolds","CommandCloseAllFoldsRecursively","CommandOpenAllFoldsRecursively","CommandCenterScroll","TextEditorRevealType","InCenter","CommandCenterScrollFirstChar","getFirstNonWhitespaceCharOnLine","CommandTopScroll","lineNumber","CommandTopScrollFirstChar","CommandBottomScroll","CommandBottomScrollFirstChar","CommandGoToOtherEndOfHighlightedText","CommandGoToOtherSideOfHighlightedText","CommandUndo","newPosition","goBackHistoryStep","setText","CommandUndoOnLine","goBackHistoryStepsOnLine","CommandRedo","goForwardHistoryStep","CommandDeleteToLineEnd","isLineEnd","linesDown","getLeftThroughLineBreaks","DeleteOperator","CommandYankFullLine","getLeft","currentRegisterMode","RegisterMode","LineWise","YankOperator","CommandChangeToLineEnd","ChangeOperator","CommandClearLine","runRepeat","sneak","CommandExitVisualMode","CommandVisualMode","CommandReselectVisual","lastVisualSelection","mode","CommandVisualBlockMode","CommandExitVisualBlockMode","CommandVisualLineMode","CommandExitVisualLineMode","CommandOpenFile","fullFilePath","prevWordStart","wordType","WordType","FileName","inclusive","nextWordStart","fileInfo","filePath","FileCommand","createFileIfNotExists","execute","CommandGoToDefinition","CommandOpenLink","CommandGoBackInChangelist","prevPos","prevChangeInChangeList","CommandGoForwardInChangelist","nextPos","nextChangeInChangeList","CommandInsertAtLastChange","getLastChangeEndPosition","CommandInsertAtFirstCharacter","CommandInsertAtLineBegin","CommandInsertAfterCursor","CommandInsertAtLineEnd","CommandInsertNewLineAbove","newPos","isFakeMultiCursor","CommandInsertNewLineBefore","setIndentationLevel","manuallySetCursorPositions","CommandNavigateBack","jumpBack","CommandNavigateForward","jumpForward","CommandQuit","QuitCommand","CommandOnly","OnlyCommand","MoveToRightPane","MoveToLowerPane","MoveToUpperPane","MoveToLeftPane","CycleThroughPanes","VerticalSplit","OrthogonalSplit","EvenPaneWidths","CommandTabNext","TabCommand","tab","Tab","Absolute","Next","CommandTabPrevious","Previous","ActionDeleteChar","getLeftIfEOL","ActionDeleteCharWithDeleteKey","actionsRunPressedKeys","execCount","ActionDeleteLastChar","ActionJoin","str","chCode","startPosition","joinspaces","startLineNumber","startColumn","endLineNumber","endColumn","columnDeltaOffset","getLineLength","trimmedLinesContent","lineText","firstNonWhitespaceIdx","firstNonWhitespaceIndex","insertSpace","lineTextWithoutIndent","deleteStartPosition","deleteEndPosition","execJoinLines","ActionJoinVisualMode","CharacterWise","ActionJoinVisualBlockMode","ActionJoinNoWhitespace","execJoin","joinedText","newCursorColumn","exactCharacter","ActionJoinNoWhitespaceVisualMode","ActionReplaceCharacter","toReplace","endPos","ActionReplaceCharacterVisual","toInsert","getTabCharacter","visualSelectionOffset","textLength","lineNum","ActionReplaceCharacterVisualBlock","isBeforeOrEqual","topLeft","visualBlockGetTopLeftPosition","ActionDeleteVisualBlock","lines","BlockWise","ActionShiftDVisualBlock","ActionGoToInsertVisualBlockMode","ActionChangeInVisualBlockMode","ActionChangeToEOLInVisualBlockMode","collapseRange","ActionGoToInsertVisualLineModeCommand","cursorsOnBlankLines","cursorRange","getCursorRangeForLine","isEmptyOrWhitespace","ActionGoToInsertVisualLineMode","startCharacterPosition","firstNonWhitespaceCharacterIndex","ActionGoToInsertVisualLineModeAppend","endCharacterPosition","ActionGoToInsertVisualMode","selectionStart","selectionEnd","ActionGoToInsertVisualModeAppend","ActionGoToInsertVisualBlockModeAppend","newCursors","insertionColumn","POSITIVE_INFINITY","newCursor","ActionDeleteLineVisualMode","ActionChangeLineVisualModeS","ActionChangeLineVisualMode","ActionChangeLineVisualBlockMode","ActionChangeChar","ToggleCaseAndMoveForward","newText","toggled","toLocaleUpperCase","shouldWrapKey","getOffsetThroughLineBreaks","toggleCase","IncrementDecrementNumberAction","ranges","getSearchRanges","stepNum","whereToStart","wordLoop","iterateWords","NumericString","suffixOffset","pos","replaceNum","staircase","startPos","oldLength","newNum","bottomRight","visualBlockGetBottomRightPosition","IncrementNumberAction","DecrementNumberAction","IncrementNumberStaircaseAction","DecrementNumberStaircaseAction","CommandUnicodeName","charCode","ActionTriggerHover","ActionOverrideCmdD","ActionOverrideCmdDInsert","curPos","Selection","nextWordEnd","matchWordPos","matchWordLength","wordBegin","ActionOverrideCmdAltDown","ActionOverrideCmdAltUp","ActionShowFileInfo","reportFileInfo","WriteQuit","WriteQuitCommand","Quit","bang","ActionGoToAlternateFile","altFile","NoAlternateFile","files","findFiles","CommandTabInCommandline","isTabForward","autoCompleteItems","autoCompleteIndex","lastPos","preCompleteCharacterPos","lastCmd","preCompleteCommand","evalCmd","restCmd","lastKeyPressed","cycleCompletion","newCompletionItems","currentCmd","cursorPos","fileRegex","commandParsers","cmd","filePathInCmd","currentUri","isRemote","remoteName","fullDirPath","baseName","partialPath","getPathDetails","shouldAddDotItems","readDirectory","newIndex","completion","CommandEnterInCommandline","CommandRemoveWordCommandline","cmdText","characterAt","getWordLeftInText","CommandRemoveWordInSearchMode","searchState","searchString","WordLeftInCommandline","Big","WordRightInCommandline","getWordRightInText","WordLeftInSearchMode","WordRightInSearchMode","CommandInsertInCommandline","modifiedString","CommandInsertInSearchMode","prevSearchList","searchStatePrevious","CommandEscInSearchMode","searchDirection","addSearchStateToHistory","hl","getMatchRanges","PatternNotFound","nextMatch","searchPos","getNextSearchMatchPosition","SearchHitTop","SearchHitBottom","reportSearch","searchStateIndex","CommandEscInCommandline","firstVisibleLineBeforeSearch","scrollView","CommandInsertRegisterContentInCommandLine","NothingInRegister","keyStrokes","registerMode","CommandInsertRegisterContentInSearchMode","CommandInsertWord","getWord","CommandNavigateInCommandlineOrSearchMode","statusBarText","getTrimmedStatusBarText","CommandPasteInCommandline","textFromClipboard","Paste","CommandPasteInSearchMode","CommandCtrlLInSearchMode","getNextSearchMatchRange","DefaultDigraphs","CommandEscInsertMode","returnToInsertAfterCommand","lastActionBeforeEsc","languageId","changeAction","getTransformation","lastContentChanges","CommandInsertPreviousText","NoInsertedTextYet","ArrowsInInsertMode","CommandInsertPreviousTextAndQuit","IncreaseIndent","originalText","indentationWidth","getIndentationLevel","tabSize","tabstop","newIndentationWidth","DecreaseIndent","CommandBackspaceInInsertMode","CommandDeleteInInsertMode","CommandInsertInInsertMode","CommandInsertDigraph","digraph","reverseDigraph","charCodes","digraphs","reverseChars","digraphChars","CommandInsertRegisterContent","CommandOneNormalCommandInInsertMode","CommandCtrlW","isAtDocumentBegin","isInLeadingWhitespace","isLineBeginning","InsertCharAbove","charPos","InsertCharBelow","CommandCtrlUInInsertMode","getLineBeginRespectingIndent","CommandNavigateAutocompleteDown","CommandNavigateAutocompleteUp","CommandCtrlVInInsertMode","clipboard","CommandShowLineAutocomplete","lineCompletionProvider","showLineCompletionsQuickPick","NewLineInsertMode","CommandReplaceAtCursorFromInsertMode","CreateUndoPoint","addChange","finishCurrentStep","firstNonBlankChar","BasePutCommand","getRegisterMode","getReplaceRange","getRegisterText","shouldAdjustIndent","lineToMatch","adjustIndent","newCursorPosition","getCursorPosition","adjustLinewiseRegisterText","getTransformations","advancePositionByText","useSystemClipboard","numNewlinesAfterPut","reportLinesChanged","firstLineIdentationWidth","deletedNewlines","spaces","insertPos","putBefore","PutCommand","rangeStart","PutBeforeCommand","PlaceCursorAfterText","Base","GPutCommand","GPutBeforeCommand","AdjustIndent","PutWithIndentCommand","PutBeforeWithIndentCommand","ExCommand","insertLine","PutFromCmdLine","PutBeforeFromCmdLine","ExitReplaceMode","newChars","ReplaceModeToInsertMode","BackspaceInReplaceMode","replaceCursorStartPosition","originalChars","ReplaceInReplaceMode","isNewLineOrTab","searchCurrentWord","isExact","currentWord","searchStartCursorPosition","createSearchStateAndMoveToMatch","needle","NoStringUnderCursor","searchCurrentSelection","currentSelection","SearchState","isRegex","ignoreSmartcase","CommandSearchCurrentWordExactForward","CommandSearchCurrentWordForward","CommandSearchVisualForward","visualstar","CommandSearchCurrentWordExactBackward","CommandSearchCurrentWordBackward","CommandSearchVisualBackward","CommandSearchForwards","CommandSearchBackwards","SearchObject","TextObject","newSearchState","getSearchMatchRangeOf","SearchObjectForward","SearchObjectBackward","supportsLookbehind","PythonDocument","_document","parsed","_parseLines","structure","_parseStructure","reOnlyWhitespace","indentation","_indentation","_parseLine","info","reDefOrClass","endLine","reLastNonWhiteSpaceCharacter","edge","isDirection","elements","elem","element","forward","BasePythonMovement","MovePythonNextFunctionStart","MovePythonPrevFunctionStart","MovePythonNextFunctionEnd","MovePythonPrevFunctionEnd","ExpandingSelection","Expanding","MoveByScreenLine","execActionWithCount","movementType","removed","MoveUpByScreenLine","MoveDownByScreenLine","MoveByScreenLineMaintainDesiredColumn","prevDesiredColumn","prevLine","returnedPos","MoveDownFoldFix","prevChar","moveDownByScreenLine","lineChanged","colChanged","MoveDown","scheme","foldfix","MoveUp","MoveUpFoldFix","moveUpByScreenLine","MoveLeft","MoveRight","ArrowsInReplaceMode","CommandNextSearchMatch","searchForward","CommandPreviousSearchMatch","prevMatch","MarkMovementBOL","getMark","MarkNotSet","isUppercaseMark","ensureEditorIsActive","MarkMovement","NextMark","positions","getLocalMarks","compareTo","PrevMark","isBefore","NextMarkLinewise","PrevMarkLinewise","MoveDownNonBlank","MoveUpNonBlank","MoveDownUnderscore","MoveToColumn","findHelper","MoveFindForward","sneakReplacesF","SneakForward","ToControlCharacter","lastSemicolonRepeatableMovement","lastCommaRepeatableMovement","MoveFindBackward","SneakBackward","tilHelper","MoveTilForward","toFind","MoveTilBackward","MoveRepeat","movement","MoveRepeatReversed","semiColonMovement","commaMovement","MoveLineEnd","MoveLineBegin","MoveScreenLineBegin","MoveScreenNonBlank","MoveScreenLineEnd","MoveScreenLineEndNonBlank","MoveScreenLineCenter","MoveUpByDisplayLine","MoveDownByDisplayLine","MoveUpByScreenLineVisualLine","MoveDownByScreenLineVisualLine","MoveUpByScreenLineVisualBlock","MoveDownByScreenLineVisualBlock","MoveScreenToRight","MoveScreenToLeft","MoveScreenToRightHalf","MoveScreenToLeftHalf","MoveToLineFromViewPortTop","MoveToLineFromViewPortBottom","MoveToMiddleLineInViewPort","MoveNonBlank","MoveNonBlankFirst","MoveNonBlankLast","EndOfSpecificLine","MoveWordBegin","changeWordIncludesWhitespace","isFirstWordOfLine","MoveFullWordBegin","MoveWordEnd","MoveFullWordEnd","MoveLastWordEnd","prevWordEnd","MoveLastFullWordEnd","MoveBeginningWord","MoveBeginningFullWord","MovePreviousSentenceBegin","getSentenceBegin","GoToOffset","positionAt","MoveNextSentenceBegin","MoveParagraphEnd","iteration","isFirstLineWise","hasOperator","paragraphEnd","getCurrentParagraphEnd","isLineWise","isLastIteration","isAtDocumentEnd","MoveParagraphBegin","getCurrentParagraphBeginning","MoveSectionBoundary","moveClassBoundary","boundary","MoveNextSectionBegin","MoveNextSectionEnd","MovePreviousSectionBegin","MovePreviousSectionEnd","MoveToMatchingBracket","failure","col","currentChar","PairMatcher","getPercentPairing","nextPairedChar","targetLine","trunc","MoveInsideCharacter","includeSurrounding","closingChar","pairings","charToMatch","selStart","selEnd","openPos","closePos","isAfterOrEqual","outerOpenPos","outerClosePos","operatorPositionDiff","MoveInsideParentheses","MoveAroundParentheses","MoveInsideCurlyBrace","MoveAroundCurlyBrace","MoveInsideCaret","MoveAroundCaret","MoveInsideSquareBracket","MoveAroundSquareBracket","MoveQuoteMatch","adjustForTrailingWhitespace","includeQuotes","quoteIndices","QuoteMatcher","surroundingQuotes","trailingWhitespace","hasRunOperator","MoveInsideSingleQuotes","MoveAroundSingleQuotes","MoveInsideDoubleQuotes","MoveAroundDoubleQuotes","MoveInsideBacktick","MoveAroundBacktick","MoveToUnclosedRoundBracketBackward","MoveToUnclosedRoundBracketForward","MoveToUnclosedCurlyBracketBackward","MoveToUnclosedCurlyBracketForward","MoveTagMatch","includeTag","editorText","offsetAt","tagMatcher","TagMatcher","findOpening","findClosing","endPosition","MoveInsideTag","MoveAroundTag","BaseOperator","doesRepeatedOperatorApply","nonCountActions","highlightedyank","yankDecoration","createTextEditorDecorationType","backgroundColor","color","textColor","setDecorations","dispose","duration","numLinesDeleted","isOnLastLine","startOfLine","DeleteOperatorVisual","extendedEnd","highlightYankedRanges","numLinesYanked","reportLinesYanked","FilterOperator","cursorsInitialState","ShiftYankOperatorVisual","DeleteOperatorXVisual","ChangeOperatorSVisual","FormatOperator","ChangeCaseOperator","transformText","UpperCaseOperator","UpperCaseWithMotion","LowerCaseOperator","LowerCaseWithMotion","ToggleCaseOperator","ToggleCaseWithMotion","IndentOperator","IndentOperatorInVisualModesIsAWeirdSpecialCase","isRunningDotCommand","dotCommandPreviousVisualSelection","shiftSelectionByNum","OutdentOperator","OutdentOperatorInVisualModesIsAWeirdSpecialCase","deleteRange","autoindent","firstLineIndent","endOfLine","YankVisualBlockMode","CommentOperator","ROT13Operator","original","rot13","A","CommentBlockOperator","ActionVisualReflowParagraph","indent","getIndentation","indentLevel","maximumLineLength","textwidth","chunksToReflow","lastChunk","trimmedLine","commentType","CommentTypes","final","singleLine","inner","content","indentLevelAfterComment","indentAfterComment","commentLength","lastLine","breakpoint","textToReflow","reflowParagraph","trigger","leaderCount","BaseEasyMotionCommand","baseOptions","_baseOptions","clearMarkers","markerGenerator","MarkerGenerator","matchPosition","resolveMatchPosition","generateMarker","addMarker","searchOptions","easymotion","getMatches","EasyMotion","processMarkers","markers","getMatchesForString","sortedSearch","regexFlags","ignorecase","smartcase","_options","charCount","labelPosition","removeTrailingLineBreak","EasyMotionCharMoveCommandBase","_action","searchAction","getMatchesForWord","jumpToAnywhere","easymotionJumpToAnywhereRegex","getMatchesForLineStart","EasyMotionCharInputMode","shouldFire","fire","CommandEscEasyMotionCharInputMode","MoveEasyMotion","nail","accumulation","findMarkers","visibleMarkers","decorations","decorationTypeCache","getDecorationType","fade","hide","onlyVisible","specialCharactersRegex","lineMin","lineMax","lineIdx","Match","computeAboluteDiff","matchIndex","absDiff","customizedValue","themeColorId","ThemeColor","getMarkerColor","easymotionMarkerBackgroundColor","easymotionMarkerForegroundColorOneChar","easymotionMarkerForegroundColorTwoCharFirst","easymotionMarkerForegroundColorTwoCharSecond","easymotionDimColor","dimmingZones","dimmingRenderOptions","getEasymotionDimColor","hiddenChars","keystroke","nextKeystroke","firstCharFontColor","getEasymotionMarkerForegroundColorTwoCharFirst","getEasymotionMarkerForegroundColorOneChar","getEasymotionMarkerBackgroundColor","firstCharRange","firstCharRenderOptions","contentText","margin","easymotionMarkerFontWeight","height","renderOptions","dark","light","secondCharFontColor","getEasymotionMarkerForegroundColorTwoCharSecond","secondCharRange","secondCharRenderOptions","easymotionDimBackground","prevMarker","prevKeystroke","prevDimPos","offsetPrevDimPos","getDocumentEnd","matchesCount","keyTable","getKeyTable","prefixKeyTable","createPrefixKeyTable","markerPosition","currentStep","totalRemainder","totalSteps","reversed","easymotionKeys","PluginDefaultMappings","config","defaultMappings","configSwitch","mapping","startingLetter","sneakUseIgnorecaseAndSmartcase","whichwrap","history","CommandLineHistory","recState","commandList","lineRange","exCommandParser","enableNeovim","neovimCapable","nvim","executeWithRange","NotAnEditorCommand","initialText","showInputBox","getInputBoxOptions","prompt","ignoreFocusOut","valueSelection","showQuickPick","placeHolder","BangCommand","_arguments","numNewlines","check","numWhitespace","externalCommand","resolvedRange","resolveToRange","output","getReplaceDiff","BufferDeleteCommand","NoWriteSinceLastChange","tabPosition","NoBuffersDeleted","CloseCommand","visibleTextEditors","CannotCloseLastWindow","oldViewColumn","viewColumn","CopyCommand","dest","scanner","Scanner","nextWord","isAtEof","TrailingCharacters","sourceStart","sourceEnd","InvalidAddress","copiedText","copyLines","DeleteRangeCommand","startLine","getLineEndIncludingEOL","linesToRemove","DigraphsCommand","quickPicks","digraphKey","charDesc","label","description","digraphKeyAndContent","makeQuickPicks","val","FilePosition","editorFileUri","editorFilePath","fsPath","NewWindowVerticalSplit","NewWindowHorizontalSplit","hidePreviousEditor","untildify","fileUri","fileList","showOpenDialog","fullPath","uriPath","resolveUri","fileExists","doesFileExist","pathWithExt","uriPathWithExt","FileInfoCommand","GotoCommand","gotoOffset","GotoLineCommand","HistoryCommandType","HistoryCommand","Cmd","Search","Expr","Input","Debug","All","JumpPickItem","jump","detail","JumpsCommand","hasJumps","quickPickItems","jumps","item","canPickMany","ClearJumpsCommand","clearJumps","MarkQuickPickItem","picked","alwaysShow","MarksCommand","marksFilter","getMarks","DeleteMarksCommand","numbers","numberRange","letterRange","ArgumentRequired","removeLocalMarks","removeMarks","numberArgs","letterArgs","InvalidArgument","caseMismatch","NohlCommand","PutExCommand","putCmd","setInsertionLine","doPut","duplicatedInSplit","quitAll","ReadCommand","textToInsert","getTextToInsert","file","getTextToInsertFromFile","getTextToInsertFromCmd","readFileAsync","SUPPORT_READ_COMMAND","cp","stdout","stderr","RegisterCommand","getRegisterDisplayValue","specials","registers","displayRegisterValue","currentRegisterKeys","reg","reg1","reg2","regSortOrder","registerKeyAndContent","SetOptionOperator","SetOptionsCommand","optionName","optionAliases","UnknownOption","Reset","Equal","Invert","Append","Subtract","initialValue","Info","ShCommand","createTerminal","show","SmileCommand","smileText","SortCommand","sortLines","originalLines","currentLine","lastLineLength","unique","uniqueLines","adjustedLine","sortedLines","localeCompare","sortedContent","SubstituteFlags","SubstituteCommand","abort","ConfirmEach","jsRegexFlags","gdefault","substituteGlobalFlag","ReplaceAll","IgnoreCase","prevSubstituteState","substituteState","searchPattern","NoPreviousSubstituteRegularExpression","replaceString","prevSearchState","NoPreviousRegularExpression","SubstituteState","originalContent","PrintCount","newContent","nonGlobalRegex","matchPos","confirmReplacement","rangeEnd","recordJump","replacement","cancellationToken","CancellationTokenSource","validSelections","searchRanges","decoration","searchHighlight","validateInput","token","getRegex","substitutions","replaceTextAtLine","setStatusBarText","report","executeCommandWithCount","First","Last","New","isInWorkspace","workspaceFolders","currentFilePath","toOpenPath","workspacePath","Uri","Close","Only","Move","UndoCommand","VsCodeCommand","skipWhiteSpace","WallCommand","saveAll","WriteCommand","opt","append","background","fs","accessAsync","constants","W_OK","save","accessErr","chmodAsync","bgWrite","writeArgs","optValue","writeCmd","write","quitArgs","quitCmd","quit","WriteQuitAllCommand","wallCmd","wall","YankCommand","arg1","arg2","linesToYank","yank","EOF","backup","wordSeparators","skipRun","ignore","scannedArgs","parseQuitCommandArgs","regs","parseOption","optionArgs","Multiply","replaceEscapes","None","secondDelimiterFound","parsePattern","parseReplace","KeepPreviousFlags","SuppressError","NoIgnoreCase","PrintLastMatchedLine","PrintLastMatchedLineWithNumber","PrintLastMatchedLineWithList","UsePreviousPattern","parseSubstituteFlags","countStr","parseCount","isDigit","nextWhile","parseCountOrOffset","expect","expectOneOf","charToFind","charToStack","stackHeight","isNextMatchForward","allowCurrentPosition","linePosition","cursorChar","keepSearching","originalLineLength","nextChar","pairMemberChar","pairing","matchpairs","components","directionless","findPairedChar","QuoteMatch","corpus","quoteMap","openingQuote","escapeChar","Opening","Closing","cursorQuoteType","closing","getNextQuote","getPrevQuote","opening","TAG_REGEX","tags","CLOSE_FORWARD_SLASH","TAG_NAME","OPEN_FORWARD_SLASH","matchedTags","openNode","openingTagStart","openingTagEnd","closingTagStart","closingTagEnd","firstNonWhitespacePositionOnLine","startPosOffset","endPosOffset","tagsSurrounding","nodeSurrounding","determineRelevantTag","openStart","closeEnd","openEnd","closeStart","adjustedStartPosOffset","selectionActive","relevantTag","isValid","sel","PositionDiffType","Offset","ExactPosition","ObeyStartOfLine","EndOfLine","ExactCharacter","p1","p2","boundsCheck","resultLine","resultChar","validatePosition","getLineCount","lineDelta","includeEol","getSentenceEnd","newlines","startofline","numLength","negative","coreBegin","coreLength","coreRadix","coreSign","matchings","coreEnd","core","numPrefix","8","10","16","linesWithoutIndentation","lineToStartScanFrom","scanAboveFirst","distanceFromStartLine","sortPriority","getCompletionsForCurrentLine","currentFileName","currentPosition","matchedLines","startingFileName","documentsStartingWith","getCompletionsForText","completions","selectedCompletion","extensionVersion","packagejson","Configuration","leaderDefault","cursorTypeMap","TextEditorCursorStyle","Line","block","Block","underline","Underline","LineThin","BlockOutline","UnderlineThin","handleKeys","useCtrlKeys","overrideCopy","hlsearch","camelCaseMotion","replaceWithRegister","smartRelativeLine","argumentObjectSeparators","argumentObjectOpeningDelimiters","argumentObjectClosingDelimiters","easymotionMarkerForegroundColorTwoChar","easymotionIncSearchForegroundColor","easymotionMarkerWidthPerChar","easymotionMarkerFontFamily","easymotionMarkerFontSize","easymotionMarkerMargin","autoSwitchInputMethod","defaultIM","obtainIMCmd","switchIMCmd","maxmapdepth","showcmd","showmodename","incsearch","statusBarColorControl","statusBarColors","normal","visual","visualline","visualblock","silent","loggingLevelForAlert","loggingLevelForConsole","searchHighlightColor","searchHighlightTextColor","mouseSelectionGoesIntoVisualMode","neovimPath","neovimUseConfigFile","neovimConfigPath","showMarksInGutter","wrapscan","scroll","cursorStylePerMode","insertModeKeyBindings","insertModeKeyBindingsNonRecursive","normalModeKeyBindings","normalModeKeyBindingsNonRecursive","operatorPendingModeKeyBindings","operatorPendingModeKeyBindingsNonRecursive","visualModeKeyBindings","visualModeKeyBindingsNonRecursive","commandLineModeKeyBindings","commandLineModeKeyBindingsNonRecursive","insertModeKeyBindingsMap","normalModeKeyBindingsMap","operatorPendingModeKeyBindingsMap","visualModeKeyBindingsMap","commandLineModeKeyBindingsMap","vimConfigs","mockConfiguration","option","unproxify","SUPPORT_VIMRC","vimrcModel","clearKeyBindingsMaps","configurationValidator","validate","keybinding","contributes","keybindings","when","mac","linux","useKey","handleKey","section","resource","cursorStyle","cursorStyleFromString","editorCursorStyleRaw","overlapSetting","propertyKey","settingName","vscodeSetting","vimSetting","ConfigurationTarget","Global","validators","validator","ValidatorResults","hasError","disable","_markDecorationCache","svg","isWholeLine","gutterIconPath","gutterIconSize","_default","_searchHighlight","_easyMotionIncSearch","_easyMotionDimIncSearch","decorationType","getMarkDecoration","_createMarkDecoration","_insertModeVirtualCharacter","_operatorPendingModeCursor","_operatorPendingModeCursorChar","borderColor","borderStyle","borderWidth","overviewRulerColor","easyMotionIncSearch","fontWeight","easyMotionDimIncSearch","insertModeVirtualCharacter","operatorPendingModeCursor","operatorPendingModeCursorChar","errors","validationResult","validationResults","numWarnings","isSurroundedByAngleBrackets","leaderKey","standardNotation","notationMap","shiftedLetterRegex","normalized","remappers","InsertModeRemapper","NormalModeRemapper","VisualModeRemapper","CommandLineModeRemapper","OperatorPendingModeRemapper","isPotentialRemap","remapper","sendKey","Remapper","configKey","remappedModes","_isPotentialRemap","hasPotentialRemap","allowPotentialRemapOnFirstKey","remainingKeys","allowBufferingKeys","userDefinedRemappings","TimeoutFinished","remapping","findMatchingRemap","hasAmbiguousRemap","resetCommandList","wasPerformingRemapThatFinishedWaitingForTimeout","lastRemapLength","keysPressedByUser","ForceStopRemappingError","bufferedKeys","bufferedKeysTimeoutObj","newRemapping","skipFirstCharacter","hasParentRemapping","isCurrentlyPerformingRemapping","mapDepth","recursive","isCurrentlyPerformingNonRecursiveRemapping","remapFailed","vimError","RecursiveMapping","fromVimError","ms","remapUsedACharacter","handleRemapping","specialKey","lastRemapWithoutAmbiguousRemap","commandString","commandArgs","inputtedKeys","getRemappedKeysLengthRange","startingSliceLength","inputtedString","sliceLength","keySlice","verbose","precedingKeys","remappings","keyLengths","remap","countRemapAsPotential","keysAsString","re","keyBindingsConfigKey","InputMethodSwitcherConfigurationValidator","inputMethodConfig","existsAsync","getRawCmd","registerValidator","RemappingValidator","modeKeyBindingsKeys","modeKeyBindingsKey","pluginMapping","getPluginDefaultMappings","isRecursive","modeMapName","modeKeyBindingsMap","remappingError","isRemappingValid","beforeKeys","isCommandValid","getCommandMap","commandMap","getCommands","ErrorMessage","14","20","23","29","32","33","34","35","37","208","223","348","353","354","384","385","444","471","474","481","486","488","492","516","518","662","663","664","748","extraValue","reason","HistoryFile","historyFileName","HistoryBase","extensionStoragePath","historyKey","diffEngine","DiffMatchPatch","DocumentChange","beforeRange","afterRange","HistoryStep","isFinished","marks","cameFromU","timestamp","intersect","intersectLength","timeDiffMillis","timeDiffSeconds","getHours","getMinutes","getSeconds","globalMarks","UndoStack","historySteps","currentStepIndex","initialMarks","getCurrentHistoryStep","ChangeList","changeLocations","ChangeListIsEmpty","AtEndOfChangeList","AtStartOfChangeList","undoStack","changeList","previousDocumentState","getDocumentText","versionNumber","getDocumentVersion","previousMarks","getAllCurrentDocumentMarks","newMarks","newMark","ch","docEnd","isFileMark","getCurrentMarkList","putMarkInList","getMarkList","previousIndex","existingMark","getLastChangeStartPosition","getLastHistoryStartPosition","markNames","force","nextStepStartPosition","whatHappened","added","DIFF_INSERT","pushChange","currentHistoryStep","updateAndReturnMarks","changePos","addChangePosition","stepBackward","undo","ignoreChange","getCurrentHistoryStepIndex","howLongAgo","stepForward","do","changesToUndo","lastChange","undoLine","stepIdx","getHistoryStepAtIndex","matchAll","newStep","pushHistoryStep","lastChangeIndex","nextChangePosition","prevChangePosition","getStackDepth","_jumps","_currentJumpNumber","isJumpingThroughHistory","isSamePosition","pushJump","jumpThroughHistory","recordJumpForward","recordJumpBack","getJump","iterations","performFileJump","distance","changePositionForJumpNumber","newLineShiftedUp","removeDuplicateJumps","clearJumpsOnSameLine","linesSeenPerFile","VSCodeVimCursorType","cursorType","TextDecoration","Native","ModeHandler","handlerMap","disposables","Remappers","VimState","RemapState","_currentMode","isSnippetSelectionChange","contains","allowedModes","Command","Keyboard","isStatusBarMode","toDraw","lastClickWasPastEol","newStart","printableKey","oldMode","oldFullMode","oldStatusBarText","oldWaitingForAnotherActionKey","waitingForAnotherActionKey","handledAsRemap","handledAsAction","preventZeroRemap","handleKeyAsAnAction","lastKeyPressedTimestamp","updateShowCmd","forceClearStatusBar","lastMovementFailed","getRelevantAction","actionToRecord","actionCanBeMergedWithDocumentChange","addChanges","newContentChange","runAction","isInsertion","fromStateBefore","ranRepeatableAction","ranAction","executeMovement","executeTransformations","prevMode","getOperatorState","executeOperator","createUndoPointForBrackets","isReplayingMacro","documentEndPosition","documentLineCount","withNewStart","currentLineLength","currentStartLineLength","offsetAllowed","cursorsToRemove","oldCursorPositionStart","oldCursorPositionStop","startingMode","startingRegisterMode","operators","resultingCursor","recordedMacro","originalLocation","showHighlights","selectionMode","combinedSelections","previousSelection","getSelectionsCombined","isLastCursorTracked","cursorToTrack","isCursorAboveRange","isCursorBelowRange","revealType","Default","getCursorStyleForMode","getCursorType","getCursorStyle","editorCursorStyle","cursorStop","iModeVirtualCharDecorationOptions","virtualKey","eolRenderOptions","opCursorDecorations","opCursorCharDecorations","getCharAt","markDecoration","allMarkDecorations","getOrCreateMarkDecoration","markLine","markRange","updateSearchHighlights","easyMotionDimRanges","SearchByNCharCommand","getDocumentBegin","easyMotionHighlightRanges","toRange","viewChange","updateDecorations","modeHandlerMap","editorId","SUPPORT_NVIM","SUPPORT_IME_SWITCHER","UV_FS_SYMLINK_DIR","UV_FS_SYMLINK_JUNCTION","O_RDONLY","O_WRONLY","O_RDWR","UV_DIRENT_UNKNOWN","UV_DIRENT_FILE","UV_DIRENT_DIR","UV_DIRENT_LINK","UV_DIRENT_FIFO","UV_DIRENT_SOCKET","UV_DIRENT_CHAR","UV_DIRENT_BLOCK","S_IFMT","S_IFREG","S_IFDIR","S_IFCHR","S_IFBLK","S_IFIFO","S_IFLNK","S_IFSOCK","O_CREAT","O_EXCL","UV_FS_O_FILEMAP","O_NOCTTY","O_TRUNC","O_APPEND","O_DIRECTORY","O_NOFOLLOW","O_SYNC","O_DSYNC","O_SYMLINK","O_NONBLOCK","S_IRWXU","S_IRUSR","S_IWUSR","S_IXUSR","S_IRWXG","S_IRGRP","S_IWGRP","S_IXGRP","S_IRWXO","S_IROTH","S_IWOTH","S_IXOTH","F_OK","R_OK","X_OK","UV_FS_COPYFILE_EXCL","COPYFILE_EXCL","UV_FS_COPYFILE_FICLONE","COPYFILE_FICLONE","UV_FS_COPYFILE_FICLONE_FORCE","COPYFILE_FICLONE_FORCE","stat","_e","encoding","readFile","createDirectory","writeFile","workspaceState","parsedData","VsCodeMessage","actionMessages","errorMessage","log","debugMessage","warnMessage","verboseMessage","showMessage","copyToUnnamed","isBlackHoleRegister","isReadOnlyRegister","appendToRegister","overwriteRegister","isValidLowercaseRegister","specialRegisters","isClipboardRegister","processNumberedRegisters","contentByCursor","oldContent","baseOperator","clipboardContent","registerContent","supportNode","serializableRegisters","writeFileAsync","savedRegisters","_searchStatePrevious","JumpTracker","searchHistory","SearchHistory","states","prevSearchString","items","Transformer","regexEscape","regexLeader","regexBufferedKeys","matchRanges","_searchString","recalculateSearchRanges","oldNeedle","needleSegments","notEscapedQuestionMarkRegex","notEscapedSlashRegex","searchOffsetBeginRegex","searchOffsetEndRegex","_needleRegex","searchRE","ignorecaseOverride","caseOverrideRegex","cached","startOffset","needleRegex","wrappedOver","MAX_SEARCH_RANGES","matchRange","_cursors","_cursorsInitialState","inputMethodSwitcher","switchInputMethod","lineNumbers","TextEditorLineNumbersStyle","On","Relative","_currentRegisterMode","NeovimWrapper","ime","InputMethodSwitcher","leadingChar","searchWithCursor","commandWithCursor","statusBarCommandText","searchCharCount","wentOverEOL","pendingCommandString","showingDefaultMessage","statusBarItem","createStatusBarItem","StatusBarAlignment","Left","MIN_SAFE_INTEGER","recordedStateStatusBarItem","Right","hasModeChanged","updateText","updateColor","macroText","escaped","foreground","colorToSet","workbenchConfiguration","currentColorCustomizations","colorCustomizations","reportButton","showErrorMessage","body","letVSCodeHandleKeystrokes","editBuilder","firstNonBlank","whitespaceRegExp","iskeyword","foundRealWord","includeInWord","insertSpaces","visibleColumn","screenCharacters","indentString","expandtab","itrStart","itrEnd","runToLineEnd","lineIndex","endCharacter","wordEnd","isLineBlank","trimWhite","getLine","sentenceEndRegex","getFirstNonWhitespaceInParagraph","newCharacter","getAllPositions","getAllEndPositions","getNextSentenceBegin","paragraphBegin","getPreviousSentenceBegin","SelectWord","SelectABigWord","SelectAnExpandingBlock","blocks","smallestRange","cursorStartPos","iMotion","currentSelectedRange","contender","equals","SelectInnerWord","SelectInnerBigWord","SelectSentence","currentSentenceBegin","currentSentenceNonWhitespaceEnd","nextSentenceBegin","SelectInnerSentence","SelectParagraph","currentParagraphBegin","SelectInnerParagraph","SelectEntire","SelectEntireIgnoringLeadingTrailing","IndentObjectMatch","includeLineAbove","includeLineBelow","isChangeOperator","firstValidLineNumber","findFirstValidLine","cursorIndent","findRangeStartOrEnd","startCharacter","startIndex","InsideIndentObject","InsideIndentObjectAbove","InsideIndentObjectBoth","SelectArgument","selectAround","leftSearchStartPosition","rightSearchStartPosition","charAtPos","separatorCharacters","openingDelimiterCharacters","closingDelimiterCharacters","SelectInnerArgument","findLeftArgumentBoundary","findRightArgumentBoundary","leftArgumentBoundary","rightArgumentBoundary","isLeftOnOpening","isRightOnClosing","ignoreSeparators","delimiterPosition","walkingPosition","closedParensCount","isOnBoundary","openedParensCount","SelectAroundArgument","nonWordCharRegex","keywordChars","CharKind","symbolTable","Punctuation","Superscript","Subscript","Braille","Hiragana","Katakana","Ideograph","Hangul","codePointRangePatterns","escapedKeywordChars","codePointRanges","patterns","symbolSegments","wordSegment","segments","makeUnicodeWordRegex","nonBigWordCharRegex","makeWordRegex","nonCamelCaseWordCharRegex","characterSet","firstSegment","makeCamelCaseWordRegex","nonFileNameRegex","regexForWordType","CamelCase","getWordLeftOnLine","forceFirst","textTransformations","multicursorTextTransformations","isMultiCursorTextTransformation","otherTransformations","accumulatedPositionDifferences","doTextEditorEdit","overlapping","overlappingTransformations","msg","areAllSameTransformation","FromVSCodeSelection","showHistory","showSearchHistory","rerunRecordedState","runMacro","firstTransformation","getRangeFromTextTransformation","firstRange","secondRange","writeText","readText","previousExternalCommand","NoPreviousCommand","inputFile","outputFile","pipeIndex","SHELL","stdin","getRandomFileName","expandCommand","redirectCommand","promisify","unlink","LoggerImpl","os","separatePath","searchPath","baseNameIndex","absolutePath","isWindows","isLocalUntitled","updatedPartialPath","dirName","addCurrentAndUp","directoryUri","FileType","Directory","numLinesChanged","modified","progress","matchIdx","numMatches","NoRangeAllowed","getParser","fullName","parserMapping","parser","UnimplementedCommand","abbrev","LineRange","parseBangCommand","bdelete","parseBufferDeleteCommandArgs","bfirst","blast","bmodified","bnext","tabCmd","parseTabNCommandArgs","bNext","parseTabPCommandArgs","bprevious","brewind","buffers","center","clearjumps","close","parseCloseCommandArgs","parseArgs","parseDeleteRangeLinesCommandArgs","delmarks","parseMarksRemoveCommandArgs","parseDigraphCommandArgs","display","parseRegisterCommandArgs","fileCmd","parseEditFileCommandArgs","enew","parseEditNewFileCommandArgs","parseFileInfoCommandArgs","goto","help","parseHistoryCommandArgs","ls","parseMarksCommandArgs","move","new","parseEditNewFileInNewHorizontalWindowCommandArgs","nohlsearch","only","parsePutExCommandArgs","qall","parseQuitAllCommandArgs","quitall","read","parseReadCommandArgs","parseOptionsCommandArgs","shell","smile","parseSortCommandArgs","parseEditFileInNewHorizontalWindowCommandArgs","substitute","parseSubstituteCommandArgs","tabclose","parseTabCloseCommandArgs","tabedit","parseTabNewCommandArgs","tabfirst","parseTabFirstCommandArgs","tablast","parseTabLastCommandArgs","tabmove","parseTabMovementCommandArgs","tabnew","tabnext","tabNext","tabonly","parseTabOnlyCommandArgs","tabprevious","vglobal","vnew","parseEditNewFileInNewVerticalWindowCommandArgs","vsplit","parseEditFileInNewVerticalWindowCommandArgs","parseWallCommandArgs","wq","parseWriteQuitCommandArgs","wqall","parseWriteQuitAllCommandArgs","parseWriteCommandArgs","xall","commandText","lineSpecifierParser","numberParser","offsetParser","nums","Address","specifier","side","InvalidRange","sepEnd","homeDirectory","pathWithTilde","readUInt8","isArgumentsObject","isGeneratorFunction","whichTypedArray","uncurryThis","BigIntSupported","SymbolSupported","ObjectToString","numberValue","stringValue","booleanValue","bigIntValue","symbolValue","checkBoxedPrimitive","prototypeValueOf","isMapToString","isSetToString","isWeakMapToString","isWeakSetToString","isArrayBufferToString","working","isDataViewToString","isDataView","isPromise","isArrayBufferView","isView","isUint8Array","isUint8ClampedArray","isUint16Array","isUint32Array","isInt8Array","isInt16Array","isInt32Array","isFloat32Array","isFloat64Array","isBigInt64Array","isBigUint64Array","SharedArrayBufferCopy","isSharedArrayBufferToString","isSharedArrayBuffer","isNumberObject","isStringObject","isBooleanObject","isBigIntObject","isSymbolObject","isAsyncFunction","isMapIterator","isSetIterator","isGeneratorObject","isWebAssemblyCompiledModule","isBoxedPrimitive","isAnyArrayBuffer","getOwnPropertyDescriptors","descriptors","formatRegExp","objects","inspect","deprecate","noDeprecation","throwDeprecation","traceDeprecation","trace","debugs","debugEnvRegex","NODE_DEBUG","debugEnv","opts","stylize","stylizeNoColor","colors","showHidden","_extend","customInspect","stylizeWithColor","formatValue","styleType","style","styles","recurseTimes","primitive","simple","formatPrimitive","visibleKeys","arrayToHash","braces","toUTCString","formatProperty","formatArray","cur","reduceToSingleString","ar","debuglog","pid","isNullOrUndefined","isNativeError","isPrimitive","months","getDate","getMonth","origin","kCustomPromisifiedSymbol","callbackifyOnRejected","newReason","promiseResolve","promiseReject","setPrototypeOf","defineProperties","callbackify","callbackified","maybeCb","rej","foundName","possibleNames","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","nmd","children","activate"],"sourceRoot":""}